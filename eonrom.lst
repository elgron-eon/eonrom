####################### rom.asm
0000                  1	#
0000                  2	# rom.asm
0000                  3	#
0000                  4	# eon ROM
0000                  5	# (c) JCGV, junio del 2022
0000                  6	#
0000                  7	
0000                  8	#
0000                  9	# CONFIG
0000                 10	#
0000 = 0000.0010     11	KEYBUF_SIZE	.EQU	16
0000                 12	
0000                 13	# constants
0000 = 0000.0008     14	BS		.EQU	$08
0000 = 0000.007F     15	DEL		.EQU	$7f
0000 = 0000.0009     16	TAB		.EQU	$09
0000 = 0000.000A     17	LF		.EQU	$0a
0000 = 0000.000D     18	CR		.EQU	$0d
0000 = 0000.001B     19	ESC		.EQU	$1b
0000 = 0000.0008     20	MLINBYTES	.EQU	8
0000                 21	
0000                 22	# IRQs
0000 = 0000.0001     23	IRQ_RTC 	.EQU	$01
0000 = 0000.0004     24	IRQ_CON 	.EQU	$04
0000                 25	
0000                 26	# special registers
0000 = 0000.0000     27	REG_MOD 	.EQU	$00
0000 = 0000.0004     28	REG_IRQ_MASK	.EQU	$04
0000 = 0000.0005     29	REG_IRQ_PC	.EQU	$05
0000 = 0000.0006     30	REG_IRQ_SCRATCH .EQU	$06
0000 = 0000.0007     31	REG_IRQ_SAVE	.EQU	$07
0000 = 0000.000C     32	REG_EXC_CODE	.EQU	$0c
0000 = 0000.000D     33	REG_EXC_PC	.EQU	$0d
0000 = 0000.000E     34	REG_EXC_SCRATCH .EQU	$0e
0000 = 0000.000F     35	REG_EXC_SAVE	.EQU	$0f
0000                 36	
0000                 37	# I/O devices
0000 = 0000.0000     38	CON_CTRL	.EQU	$00
0000 = 0000.0001     39	CON_DATA	.EQU	CON_CTRL + 1
0000 = 0000.0002     40	RTC_CTRL	.EQU	$02
0000 = 0000.0003     41	RTC_DATA	.EQU	RTC_CTRL + 1
0000 = 0000.0004     42	RTC_WRITE	.EQU	RTC_CTRL + 2
0000 = 0000.00FF     43	DEBUG_IO	.EQU	$FF
0000                 44	
0000                 45	#
0000                 46	# memory map
0000                 47	#
0000 = 0000.0000     48	ROM_START	.EQU	$00000
0000 = 0000.2000     49	RAM_START	.EQU	$02000
0000 = 0000.3000     50	IRQ_STACK	.EQU	$03000
0000 = 0000.2FE0     51	EXC_STACK	.EQU	IRQ_STACK - 32
0000 = 0000.2F60     52	SYS_STACK	.EQU	EXC_STACK - 128
0000 = 0000.4000     53	RSTACK		.EQU	$04000
0000 = 0002.0000     54	TOP_RAM 	.EQU	$20000
0000                 55	
0000                 56	#
0000                 57	# RAM area
0000                 58	#
0000                 59			.ORG	RAM_START
2000                 60	SYSVARS_START
2000 ? 0004     4    61	MMON_VALUE	.SPACE	4
2004                 62	
2004                 63	# jforth vars
2004 ? 0004     4    64	FORTH_STATE	.SPACE	4
2008 ? 0004     4    65	FORTH_HERE	.SPACE	4
200C ? 0004     4    66	FORTH_LATEST	.SPACE	4
2010 ? 0004     4    67	FORTH_BASE	.SPACE	4
2014                 68	
2014                 69	# forth word buffer
2014 ? 0020    32    70	WORD_BUFFER	.SPACE	32
2034                 71	
2034                 72	# serial buffer
2034 ? 0012    18    73	KEYBUF		.SPACE	KEYBUF_SIZE + 2
2046                 74	
2046                 75	# rtc date buffer
2046 ? 0008     8    76	DATE_IO 	.SPACE	8
204E ? 0001     1    77	DATE_READY	.SPACE	1
204F                 78	
204F                 79	# align end marker
204F ? 0001     1    80			.SPACE	 8 - ($$ % 8)
2050                 81	SYSVARS_END
2050                 82	
2050                 83	#
2050                 84	# BIOS
2050                 85	#
2050                 86			.ORG	ROM_START
0000                 87	
0000                 88	# RESET system, power on entry point
0000 80FF            89	RESET		LI	R0, 0
0002 0F090004        90			SET	REG_IRQ_MASK, R0
0006 30F92F60        91			LI	R0, SYS_STACK
000A 9FF0            92			MV	SP, R0
000C 30F90020        93			LI	R0, IRQ_HANDLER
0010 0F090005        94			SET	REG_IRQ_PC, R0
0014 30F902B4        95			LI	R0, EXC_HANDLER
0018 0F09000D        96			SET	REG_EXC_PC, R0
001C 2FF001B8        97			BRA	MONITOR
0020                 98	
0020                 99	# IRQ handler
0020 0F090006       100	IRQ_HANDLER	SET	REG_IRQ_SCRATCH, R0
0024 0F0D00002FD6   101			LEA	R0, IRQ_STACK
002A 110AFFFF       102			ST4	[R0 - 1], R1
002E 120AFFFE       103			ST4	[R0 - 2], R2
0032 130AFFFD       104			ST4	[R0 - 3], R3
0036 140AFFFC       105			ST4	[R0 - 4], R4
003A 150AFFFB       106			ST4	[R0 - 5], R5
003E 0F14           107			ISTAT	R1
0040 32180004       108			AND	R2, R1, IRQ_CON
0044 22F00015       109			BZ	R2, .NOCON
0048                110	
0048                111			# key pressed
0048 34F92034       112			LI	R4, KEYBUF
004C 12400000       113			LD1	R2, [R4]	# head offset
0050 13400001       114			LD1	R3, [R4 + 1]	# tail offset
0054 33340001       115			ADD	R3, 1
0058 3338000F       116			AND	R3, KEYBUF_SIZE - 1
005C 23200009       117			BEQ	R3, R2, .NOCON	# buffer is full
0060                118	
0060 12400001       119			LD1	R2, [R4 + 1]	# get tail again
0064 13480001       120			ST1	[R4 + 1], R3	# store new tail
0068 4224           121			ADD	R2, R4
006A 04F8           122			LI	R4, CON_DATA
006C 044E           123			IN	R4, R4		# r4 = char
006E 14280002       124			ST1	[R2 + 2], R4	# store char
0072                125	
0072 32180001       126	.NOCON		AND	R2, R1, IRQ_RTC
0076 22F00015       127			BZ	R2, .DONE
007A 0F2D00001FC6   128			LEA	R2, DATE_IO
0080 0F3DFFFFFF7D   129			LEA	R3, RTC_DATA
0086 0F4DFFFFFF7C   130			LEA	R4, 8
008C 053E           131	.RTCDUMP	IN	R5, R3
008E 15280000       132			ST1	[R2], R5
0092 32240001       133			ADD	R2, 1
0096 34450001       134			SUB	R4, 1
009A 24F1FFF7       135			BNZ	R4, .RTCDUMP
009E 04F8           136			LI	R4, 1
00A0 14280000       137			ST1	[R2], R4
00A4                138	
00A4 1104FFFF       139	.DONE		LD4	R1, [R0 - 1]
00A8 1204FFFE       140			LD4	R2, [R0 - 2]
00AC 1304FFFD       141			LD4	R3, [R0 - 3]
00B0 1404FFFC       142			LD4	R4, [R0 - 4]
00B4 1504FFFB       143			LD4	R5, [R0 - 5]
00B8 0F080006       144			GET	R0, REG_IRQ_SCRATCH
00BC 0FF4           145			IRET
00BE                146	
00BE                147	# CONOUT: output R0 in serial line
00BE 82FF           148	CONOUT		LI	R2, CON_CTRL
00C0 012E           149			IN	R1, R2
00C2 21F0FFFC       150			BZ	R1, CONOUT     ; ready wait
00C6 02F8           151			LI	R2, CON_DATA
00C8 002F           152			OUT	R0, R2
00CA 0FE0           153			RET
00CC                154	
00CC                155	# CONSTR: output zero terminated string in R0
00CC 93F0           156	CONSTR		MV	R3, R0
00CE 94FE           157			MV	R4, R14
00D0 10300000       158	.AGAIN		LD1	R0, [R3]
00D4 20F00007       159			BZ	R0, .DONE
00D8 0FFDFFFFFFF0   160			JAL	CONOUT
00DE 33340001       161			ADD	R3, 1
00E2 2FF0FFF5       162			BRA	.AGAIN
00E6 9EF4           163	.DONE		MV	R14, R4
00E8 0FE0           164			RET
00EA                165	
00EA                166	# CONREAD: wait for console char
00EA 0FF3           167	CONREADWAIT	WAIT
00EC 34F92034       168	CONREAD 	LI	R4, KEYBUF
00F0 11400000       169			LD1	R1, [R4]
00F4 10400001       170			LD1	R0, [R4 + 1]
00F8 2100FFF7       171			BEQ	R1, R0, CONREADWAIT
00FC 4014           172			ADD	R0, R1, R4
00FE 10000002       173			LD1	R0, [R0 + 2]	# get character
0102 31140001       174			ADD	R1, 1
0106 3118000F       175			AND	R1, KEYBUF_SIZE - 1
010A 11480000       176			ST1	[R4], R1	# store new head
010E 0FE0           177			RET
0110                178	
0110                179	# CONREADECHO: read console with echo
0110 1EFAFFFF       180	CONREADECHO	ST4	[SP - 1], R14
0114 0FFDFFFFFFE9   181			JAL	CONREAD
011A 31F9000D       182			LI	R1, CR
011E 20110002       183			BNE	R0, R1, .NOCR
0122 30F9000A       184			LI	R0, LF
0126 0FFDFFFFFFC9   185	.NOCR		JAL	CONOUT
012C 1EF4FFFF       186			LD4	R14, [SP - 1]
0130 0FE0           187			RET
0132                188	
0132                189	#
0132                190	# utils
0132                191	#
0132                192	
0132                193	# DECNUM2: output decimal number < 100
0132 1EFAFFFF       194	DECNUM2 	ST4	[SP - 1], R14
0136 18FAFFFE       195			ST4	[SP - 2], R8
013A 31F9000A       196			LI	R1, 10
013E 82FF           197			LI	R2, 0
0140 20120005       198			BLT	R0, R1, .DONE
0144 5001           199	.AGAIN		SUB	R0, R1
0146 32240001       200			ADD	R2, 1
014A 2104FFFB       201			BLE	R1, R0, .AGAIN
014E                202	
014E                203	.DONE		# R2 = first digit
014E                204			# R0 = second digit
014E 98F0           205			MV	R8, R0
0150 30240030       206			ADD	R0, R2, '0'
0154 0FFDFFFFFFB2   207			JAL	CONOUT
015A 30840030       208			ADD	R0, R8, '0'
015E 0FFDFFFFFFAD   209			JAL	CONOUT
0164 1EF4FFFF       210			LD4	R14, [SP - 1]
0168 18F4FFFE       211			LD4	R8,  [SP - 2]
016C 0FE0           212			RET
016E                213	
016E                214	# DECNUM4: output decimal number < 10000
016E 0FF8FFFE       215	DECNUM4 	ENTER	-2
0172 1EFA0000       216			ST4	[SP + 0], R14
0176 18FA0001       217			ST4	[SP + 1], R8
017A 31F90064       218			LI	R1, 100
017E 82FF           219			LI	R2, 0
0180 20120005       220			BLT	R0, R1, .DONE
0184 5001           221	.AGAIN		SUB	R0, R1
0186 32240001       222			ADD	R2, 1
018A 2104FFFB       223			BLE	R1, R0, .AGAIN
018E 98F0           224	.DONE		MV	R8, R0
0190 90F2           225			MV	R0, R2
0192 0FFDFFFFFFCD   226			JAL	DECNUM2
0198 90F8           227			MV	R0, R8
019A 0FFDFFFFFFC9   228			JAL	DECNUM2
01A0 1EF40000       229			LD4	R14, [SP + 0]
01A4 18F40001       230			LD4	R8,  [SP + 1]
01A8 0FF80002       231			ENTER	2
01AC 0FE0           232			RET
01AE                233	
01AE                234	# MUL10: multiply R0 * 10
01AE 300B0001       235	MUL10		SHL	R0, R0, 1
01B2 91F0           236			MV	R1, R0
01B4 300B0002       237			SHL	R0, R0, 2
01B8 4001           238			ADD	R0, R1
01BA 0FE0           239			RET
01BC                240	
01BC                241	# UPDATE BYTE (decimal < 100)
01BC                242	# R0 = POINTER, R1 = DECIMAL DIGIT, R2 = LOW FLAG
01BC 13000000       243	UPDATE_BYTE:	LD1	R3, [R0]
01C0 34F9000A       244			LI	R4, 10
01C4 85FF           245			LI	R5, 0
01C6 23420005       246			BLT	R3, R4, .READY
01CA 5334           247	.AGAIN		SUB	R3, R4
01CC 35540001       248			ADD	R5, 1
01D0 2434FFFB       249			BLE	R4, R3, .AGAIN
01D4                250			# R5 = HI, R3 = LO
01D4 22F10003       251	.READY		BNZ	R2, .UPDLOW
01D8 95F1           252			MV	R5, R1
01DA 2FF00001       253			BRA	.DONE
01DE 93F1           254	.UPDLOW 	MV	R3, R1
01E0 355B0001       255	.DONE		SHL	R5, R5, 1
01E4 91F5           256			MV	R1, R5
01E6 311B0002       257			SHL	R1, R1, 2
01EA 4115           258			ADD	R1, R5
01EC 4113           259			ADD	R1, R3
01EE 11080000       260			ST1	[R0], R1
01F2 0FE0           261			RET
01F4                262	
01F4                263	# HEXBYTE: dump byte in r0 in hex
01F4 0FF8FFFE       264	HEXBYTE 	ENTER	-2
01F8 1EFA0000       265			ST4	[SP], R14
01FC 18FA0001       266			ST4	[SP + 1], R8
0200 98F0           267			MV	R8, R0
0202 300C0004       268			SHR	R0, 4
0206 3008000F       269			AND	R0, 15
020A 10001CEA       270			LD1	R0, [R0 + HTAB]
020E 0FFDFFFFFF55   271			JAL	CONOUT
0214 90F8           272			MV	R0, R8
0216 3008000F       273			AND	R0, 15
021A 10001CEA       274			LD1	R0, [R0 + HTAB]
021E 0FFDFFFFFF4D   275			JAL	CONOUT
0224 1EF40000       276			LD4	R14, [SP]
0228 18F40001       277			LD4	R8,  [SP + 1]
022C 0FF80002       278			ENTER	2
0230 0FE0           279			RET
0232                280	
0232                281	# HEXFULL: dump full word r0 in hex
0232 0FF8FFFE       282	HEXFULL 	ENTER	-2
0236 1EFA0000       283			ST4	[SP], R14
023A 18FA0001       284			ST4	[SP + 1], R8
023E 98F0           285			MV	R8, R0
0240 308C0018       286			SHR	R0, R8, 24
0244 0FFDFFFFFFD5   287			JAL	HEXBYTE
024A 308C0010       288			SHR	R0, R8, 16
024E 0FFDFFFFFFD0   289			JAL	HEXBYTE
0254 308C0008       290			SHR	R0, R8, 8
0258 0FFDFFFFFFCB   291			JAL	HEXBYTE
025E 90F8           292			MV	R0, R8
0260 0FFDFFFFFFC7   293			JAL	HEXBYTE
0266 1EF40000       294			LD4	R14, [SP]
026A 18F40001       295			LD4	R8,  [SP + 1]
026E 0FF80002       296			ENTER	2
0272 0FE0           297			RET
0274                298	
0274                299	# CRC32: R0 = ptr, R1 = bytes
0274 33F9FFFF       300	CRC32		LI	R3, -1
0278 0F6CEDB88320   301			LI	R6, $EDB88320
027E 21F00016       302			BZ	R1, .DONE
0282 12000000       303	.AGAIN		LD1	R2, [R0]
0286 30040001       304			ADD	R0, 1
028A 31150001       305			SUB	R1, 1
028E A332           306			XOR	R3, R2
0290 34F90008       307			LI	R4, 8
0294 35380001       308	.LOOP		AND	R5, R3, 1
0298 55F5           309			SUB	R5, SP, R5
029A 8556           310			AND	R5, R6
029C 333C0001       311			SHR	R3, 1
02A0 A335           312			XOR	R3, R5
02A2 34450001       313			SUB	R4, 1
02A6 24F1FFF5       314			BNZ	R4, .LOOP
02AA 21F1FFEA       315			BNZ	R1, .AGAIN
02AE 303AFFFF       316	.DONE		XOR	R0, R3, -1
02B2 0FE0           317			RET
02B4                318	
02B4                319	#
02B4                320	# exception handler
02B4                321	#
02B4                322	EXC_HANDLER	# save frame
02B4 0F09000E       323			SET	REG_EXC_SCRATCH, R0
02B8 30F92FA0       324			LI	R0, EXC_STACK - 16 * 4
02BC 110A0001       325			ST4	[R0 +  1], R1
02C0 120A0002       326			ST4	[R0 +  2], R2
02C4 130A0003       327			ST4	[R0 +  3], R3
02C8 140A0004       328			ST4	[R0 +  4], R4
02CC 150A0005       329			ST4	[R0 +  5], R5
02D0 160A0006       330			ST4	[R0 +  6], R6
02D4 170A0007       331			ST4	[R0 +  7], R7
02D8 180A0008       332			ST4	[R0 +  8], R8
02DC 190A0009       333			ST4	[R0 +  9], R9
02E0 1A0A000A       334			ST4	[R0 + 10], R10
02E4 1B0A000B       335			ST4	[R0 + 11], R11
02E8 1C0A000C       336			ST4	[R0 + 12], R12
02EC 1D0A000D       337			ST4	[R0 + 13], R13
02F0 1E0A000E       338			ST4	[R0 + 14], R14
02F4 1F0A000F       339			ST4	[R0 + 15], SP
02F8 9FF0           340			MV	SP, R0
02FA 0F08000E       341			GET	R0, REG_EXC_SCRATCH
02FE 10FA0000       342			ST4	[SP], R0
0302                343	
0302 30F91D43       344			LI	R0, EXC_HEADER
0306 0FFDFFFFFEE0   345			JAL	CONSTR
030C 0F08000C       346			GET	R0, REG_EXC_CODE
0310 0FFDFFFFFF8E   347			JAL	HEXFULL
0316 30F91D4F       348			LI	R0, EXC_MIDDLE
031A 0FFDFFFFFED6   349			JAL	CONSTR
0320 0F08000F       350			GET	R0, REG_EXC_SAVE
0324 0FFDFFFFFF84   351			JAL	HEXFULL
032A 30F91D54       352			LI	R0, EXC_FOOTER
032E 0FFDFFFFFECC   353			JAL	CONSTR
0334                354	
0334                355			# dump registers
0334 88FF           356			LI	R8, 0
0336 99FF           357			MV	R9, SP
0338 3AF92FE0       358			LI	R10, EXC_STACK
033C                359	.LOOP		# dump register
033C 30F90020       360			LI	R0, ' '
0340 31880003       361			AND	R1, R8, 3
0344 21F10002       362			BNZ	R1, .NOLF
0348 30F9000A       363			LI	R0, LF
034C 0FFDFFFFFEB6   364	.NOLF		JAL	CONOUT
0352 30F90052       365			LI	R0, 'R'
0356 0FFDFFFFFEB1   366			JAL	CONOUT
035C 90F8           367			MV	R0, R8
035E 0FFDFFFFFF48   368			JAL	HEXBYTE
0364 30F9003D       369			LI	R0, '='
0368 0FFDFFFFFEA8   370			JAL	CONOUT
036E 10940000       371			LD4	R0, [R9]
0372 0FFDFFFFFF5D   372			JAL	HEXFULL
0378                373	
0378                374			# next
0378 38840001       375			ADD	R8, 1
037C 39940004       376			ADD	R9, 4
0380 29A2FFDC       377			BLT	R9, R10, .LOOP
0384                378	
0384                379			# notify debugger
0384 30F900FF       380			LI	R0, DEBUG_IO
0388 000F           381			OUT	R0, R0
038A                382	
038A                383			# wait forever
038A 0FF3           384	.HALT		WAIT
038C 2FF0FFFD       385			BRA	.HALT
0390                386	
0390                387	#
0390                388	# monitor
0390                389	#
0390                390	MONITOR 	# zero sysvars area
0390 30F92000       391			LI	R0, SYSVARS_START
0394 31F92050       392			LI	R1, SYSVARS_END
0398 82FF           393			LI	R2, 0
039A 120A0000       394	.ZEROVARS	ST4	[R0], R2
039E 30040004       395			ADD	R0, 4
03A2 2012FFFA       396			BLT	R0, R1, .ZEROVARS
03A6                397	
03A6                398			# init serial console
03A6                399			;LD	 A, :RTS_LOW
03A6                400			;OUT	 (:IODEV_CONSOLE), A
03A6                401	
03A6                402			# enable irqs
03A6 30F9FFFF       403			LI	R0, -1
03AA 0F090004       404			SET	REG_IRQ_MASK, R0
03AE                405	
03AE                406			# say hello
03AE 30F91C08       407			LI	R0, HELLO
03B2 0FFDFFFFFE8A   408			JAL	CONSTR
03B8                409	
03B8                410			# output menu
03B8 30F91C17       411	MAINMENU	LI	R0, MENU
03BC 0FFDFFFFFE85   412			JAL	CONSTR
03C2                413	
03C2                414			# read option
03C2 0FFDFFFFFEA4   415			JAL	CONREADECHO
03C8                416	
03C8                417			# check option
03C8 31050030       418			SUB	R1, R0, '0'
03CC 21F0FE18       419			BZ	R1, RESET
03D0 31050039       420			SUB	R1, R0, '9'
03D4 21F0001B       421			BZ	R1, .ILLEGAL
03D8 31050031       422			SUB	R1, R0, '1'
03DC 21F0002E       423			BZ	R1, DATE
03E0 31050032       424			SUB	R1, R0, '2'
03E4 21F0014C       425			BZ	R1, MEMMON
03E8 31050033       426			SUB	R1, R0, '3'
03EC 21F0023E       427			BZ	R1, JFORTH
03F0 31050034       428			SUB	R1, R0, '4'
03F4 21F0000C       429			BZ	R1, BENCH
03F8 3105001B       430			SUB	R1, R0, ESC
03FC 21F1FFDC       431			BNZ	R1, MAINMENU
0400                432	
0400                433			# ouput space to disable esc
0400 30F91CFA       434			LI	R0, ESCOFF
0404 0FFDFFFFFE61   435			JAL	CONSTR
040A 2FF0FFD5       436			BRA	MAINMENU
040E                437	
040E 0FF0           438	.ILLEGAL	ILLEGAL
0410                439	
0410                440	#
0410                441	# BENCH
0410                442	#
0410 30F91D60       443	BENCH		LI	R0, BENCH_HEADER
0414 0FFDFFFFFE59   444			JAL	CONSTR
041A 38F90064       445			LI	R8, 100
041E 80FF           446	.LOOP		LI	R0, 0
0420 31F90040       447			LI	R1, 64
0424 0FFDFFFFFF25   448			JAL	CRC32
042A 38850001       449			SUB	R8, 1
042E 28F1FFF6       450			BNZ	R8, .LOOP
0432 0FFDFFFFFEFD   451			JAL	HEXFULL
0438 2FF0FFBE       452			BRA	MAINMENU
043C                453	
043C                454	#
043C                455	# GET/SET DATE
043C                456	#
043C                457	DATE		# request date
043C 80FF           458			LI	R0, 0
043E 1008204E       459			ST1	[R0 + DATE_READY], R0
0442                460	
0442                461			# request date
0442 30F90002       462	.POLL		LI	R0, RTC_CTRL
0446 000E           463			IN	R0, R0
0448 20F0FFFB       464			BZ	R0, .POLL
044C 31F90003       465			LI	R1, RTC_DATA
0450 80FF           466			LI	R0, 0
0452 001F           467			OUT	R0, R1
0454                468	
0454                469			# wait response
0454 80FF           470	.AGAIN		LI	R0, 0
0456 1000204E       471			LD1	R0, [R0 + DATE_READY]
045A 20F10003       472			BNZ	R0, .READY
045E 0FF3           473			WAIT
0460 2FF0FFF8       474			BRA	.AGAIN
0464                475	
0464                476			# output date
0464 89FF           477	.READY		LI	R9, 0		# cursor
0466 30F9000A       478			LI	R0, LF
046A 0FFDFFFFFE27   479			JAL	CONOUT
0470 30F91C9A       480	.REFRESH	LI	R0, DATE_HEADER
0474 0FFDFFFFFE29   481			JAL	CONSTR
047A 38F92046       482			LI	R8, DATE_IO
047E 10820000       483			LD2	R0, [R8]	# year
0482 0FFDFFFFFE73   484			JAL	DECNUM4
0488 10800002       485			LD1	R0, [R8 + 2]	# month
048C 0FFDFFFFFE50   486			JAL	DECNUM2
0492 10800003       487			LD1	R0, [R8 + 3]	# day
0496 0FFDFFFFFE4B   488			JAL	DECNUM2
049C 30F90020       489			LI	R0, ' '
04A0 0FFDFFFFFE0C   490			JAL	CONOUT
04A6 10800004       491			LD1	R0, [R8 + 4]	# day of week
04AA 30040030       492			ADD	R0, '0'
04AE 0FFDFFFFFE05   493			JAL	CONOUT
04B4 30F90020       494			LI	R0, ' '
04B8 0FFDFFFFFE00   495			JAL	CONOUT
04BE 10800005       496			LD1	R0, [R8 + 5]	# hour
04C2 0FFDFFFFFE35   497			JAL	DECNUM2
04C8 10800006       498			LD1	R0, [R8 + 6]	# minute
04CC 0FFDFFFFFE30   499			JAL	DECNUM2
04D2 10800007       500			LD1	R0, [R8 + 7]	# second
04D6 0FFDFFFFFE2B   501			JAL	DECNUM2
04DC 30F91C9E       502			LI	R0, DATE_FOOTER
04E0 0FFDFFFFFDF3   503			JAL	CONSTR
04E6                504	
04E6                505			# set cursor pos
04E6 10901CCB       506			LD1	R0, [R9 + DATE_COLS]
04EA 0FFDFFFFFE21   507			JAL	DECNUM2
04F0 30F90047       508			LI	R0, 'G'
04F4 0FFDFFFFFDE2   509			JAL CONOUT
04FA                510	
04FA                511			# readcmd
04FA 0FFDFFFFFDF6   512	.READCMD	JAL	CONREAD
0500 31050058       513			SUB	R1, R0, 'X'
0504 21F0FF58       514			BZ	R1, MAINMENU
0508 31050078       515			SUB	R1, R0, 'x'
050C 21F0FF54       516			BZ	R1, MAINMENU
0510 3105001B       517			SUB	R1, R0, ESC
0514 21F0FF50       518			BZ	R1, MAINMENU
0518 31050009       519			SUB	R1, R0, TAB
051C 21F00088       520			BZ	R1, .NEXT
0520 31050020       521			SUB	R1, R0, ' '
0524 21F00084       522			BZ	R1, .NEXT
0528 3105000A       523			SUB	R1, R0, LF
052C 21F00089       524			BZ	R1, .CHANGE
0530 3105000D       525			SUB	R1, R0, CR
0534 21F00085       526			BZ	R1, .CHANGE
0538 31050039       527			SUB	R1, R0, '9'
053C 2F13FFDD       528			BLTI	SP, R1, .READCMD
0540 31050030       529			SUB	R1, R0, '0'
0544 21F3FFD9       530			BLTI	R1, SP, .READCMD
0548                531	
0548                532			# update state with new digit (R1)
0548 32F92046       533			LI	R2, DATE_IO
054C 30F90008       534			LI	R0, 8
0550 29010004       535			BNE	R9, R0, .NODOW
0554 11280004       536			ST1	[R2 + 4], R1
0558 2FF0006A       537			BRA	.NEXT
055C 29020010       538	.NODOW		BLT	R9, R0, .NOTIME
0560 30950009       539			SUB	R0, R9, 9
0564 300C0001       540			SHR	R0, 1
0568 4002           541			ADD	R0, R2
056A 30040005       542			ADD	R0, 5
056E 32980001       543			AND	R2, R9, 1
0572 322A0001       544			XOR	R2, 1
0576 0FFDFFFFFE20   545			JAL	UPDATE_BYTE
057C 2FF00058       546			BRA	.NEXT
0580 30F90004       547	.NOTIME 	LI	R0, 4
0584 2902000D       548			BLT	R9, R0, .YEAR
0588 5090           549			SUB	R0, R9, R0
058A 300C0001       550			SHR	R0, 1
058E 4020           551			ADD	R0, R2, R0
0590 30040002       552			ADD	R0, 2
0594 32980001       553			AND	R2, R9, 1
0598 0FFDFFFFFE0F   554			JAL	UPDATE_BYTE
059E 2FF00047       555			BRA	.NEXT
05A2 10220000       556	.YEAR		LD2	R0, [R2]
05A6 37F903E8       557			LI	R7, 1000
05AA 83FF           558			LI	R3, 0
05AC 20720005       559			BLT	R0, R7, .P1000
05B0 5007           560	.A1000		SUB	R0, R7
05B2 33340001       561			ADD	R3, 1
05B6 2704FFFB       562			BLE	R7, R0, .A1000
05BA 37F90064       563	.P1000		LI	R7, 100
05BE 84FF           564			LI	R4, 0
05C0 20720005       565			BLT	R0, R7, .P100
05C4 5007           566	.A100		SUB	R0, R7
05C6 34440001       567			ADD	R4, 1
05CA 2704FFFB       568			BLE	R7, R0, .A100
05CE 37F9000A       569	.P100		LI	R7, 10
05D2 85FF           570			LI	R5, 0
05D4 20720005       571			BLT	R0, R7, .UPDY
05D8 5007           572	.A10		SUB	R0, R7
05DA 35540001       573			ADD	R5, 1
05DE 2704FFFB       574			BLE	R7, R0, .A10
05E2 96F9           575	.UPDY		MV	R6, R9
05E4 26F10003       576			BNZ	R6, .NOUPD0
05E8 93F1           577			MV	R3, R1
05EA 2FF0000F       578			BRA	.YBUILD
05EE 36650001       579	.NOUPD0 	SUB	R6, 1
05F2 26F10003       580			BNZ	R6, .NOUPD1
05F6 94F1           581			MV	R4, R1
05F8 2FF00008       582			BRA	.YBUILD
05FC 36650001       583	.NOUPD1 	SUB	R6, 1
0600 26F10003       584			BNZ	R6, .NOUPD2
0604 95F1           585			MV	R5, R1
0606 2FF00001       586			BRA	.YBUILD
060A 90F1           587	.NOUPD2 	MV	R0, R1
060C 96F0           588	.YBUILD 	MV	R6, R0
060E 90F3           589			MV	R0, R3
0610 0FFDFFFFFDCC   590			JAL	MUL10
0616 4004           591			ADD	R0, R4
0618 0FFDFFFFFDC8   592			JAL	MUL10
061E 4005           593			ADD	R0, R5
0620 0FFDFFFFFDC4   594			JAL	MUL10
0626 4006           595			ADD	R0, R6
0628 10290000       596			ST2	[R2], R0
062C 2FF00000       597			BRA	.NEXT
0630                598	
0630                599	.NEXT		# inc cursor
0630 39940001       600			ADD	R9, 1
0634 30F9000F       601			LI	R0, 15
0638 2902FF1A       602			BLT	R9, R0, .REFRESH
063C 89FF           603			LI	R9, 0
063E 2FF0FF17       604			BRA	.REFRESH
0642                605	
0642 30F90002       606	.CHANGE 	LI	R0, RTC_CTRL
0646 000E           607			IN	R0, R0
0648 20F0FFFB       608			BZ	R0, .CHANGE
064C 31F90003       609			LI	R1, RTC_DATA
0650 00F8           610			LI	R0, 1	# write cmd
0652 001F           611			OUT	R0, R1
0654 31F90004       612			LI	R1, RTC_WRITE
0658 32F92046       613			LI	R2, DATE_IO
065C 33F90008       614			LI	R3, 8
0660 10200000       615	.WRITE		LD1	R0, [R2]
0664 32240001       616			ADD	R2, 1
0668 33350001       617			SUB	R3, 1
066C 001F           618			OUT	R0, R1
066E 23F1FFF7       619			BNZ	R3, .WRITE
0672 30F91CDA       620			LI	R0, DATE_WRITTEN
0676 0FFDFFFFFD28   621			JAL	CONSTR
067C 2FF0FE9C       622			BRA	MAINMENU
0680                623	
0680                624	#
0680                625	# Memory monitor
0680                626	#
0680 8DFF           627	MEMMON		LI	R13, 0	# base addr
0682 3CF90004       628			LI	R12, 4	# mem lines
0686 1DDA2000       629			ST4	[R13 + MMON_VALUE], R13
068A 30F91CFD       630	.REFRESH	LI	R0, MMON_HEADER
068E 0FFDFFFFFD1C   631			JAL	CONSTR
0694 98FD           632			MV	R8, R13
0696 99FC           633			MV	R9, R12
0698                634	.NEXTLINE	# show addr
0698 90F8           635			MV	R0, R8
069A 0FFDFFFFFDC9   636			JAL	HEXFULL
06A0                637	
06A0                638			# hex dump
06A0 3AF90008       639			LI	R10, MLINBYTES
06A4 9BF8           640			MV	R11, R8
06A6 30F90020       641	.HEXDUMP	LI	R0, ' '
06AA 0FFDFFFFFD07   642			JAL	CONOUT
06B0 10B00000       643			LD1	R0, [R11]
06B4 0FFDFFFFFD9D   644			JAL	HEXBYTE
06BA 3BB40001       645			ADD	R11, 1
06BE 3AA50001       646			SUB	R10, 1
06C2 2AF1FFF0       647			BNZ	R10, .HEXDUMP
06C6                648	
06C6                649			# ascii dump
06C6 30F90020       650			LI	R0, ' '
06CA 0FFDFFFFFCF7   651			JAL	CONOUT
06D0 3AF90008       652			LI	R10, MLINBYTES
06D4 10800000       653	.ASCIIDUMP	LD1	R0, [R8]
06D8 31F90020       654			LI	R1, ' '
06DC 20120004       655			BLT	R0, R1, .MKPOINT
06E0 31F90080       656			LI	R1, 128
06E4 20120002       657			BLT	R0, R1, .READY
06E8 30F9002E       658	.MKPOINT	LI	R0, '.'
06EC 0FFDFFFFFCE6   659	.READY		JAL	CONOUT
06F2 38840001       660			ADD	R8, 1
06F6 3AA50001       661			SUB	R10, 1
06FA 2AF1FFEB       662			BNZ	R10, .ASCIIDUMP
06FE                663	
06FE                664			# end of line
06FE 30F9000A       665			LI	R0, LF
0702 0FFDFFFFFCDB   666			JAL	CONOUT
0708 39950001       667			SUB	R9, 1
070C 29F1FFC4       668			BNZ	R9, .NEXTLINE
0710                669	
0710                670			# dump value
0710 30F9000D       671	.PARTIAL	LI	R0, CR
0714 0FFDFFFFFCD2   672			JAL	CONOUT
071A 30F92000       673			LI	R0, MMON_VALUE
071E 10040000       674			LD4	R0, [R0]
0722 0FFDFFFFFD85   675			JAL	HEXFULL
0728                676	
0728                677			# readcmd
0728 0FFDFFFFFCDF   678	.READCMD	JAL	CONREAD
072E 31050058       679			SUB	R1, R0, 'X'
0732 21F0FE41       680			BZ	R1, MAINMENU
0736 31050078       681			SUB	R1, R0, 'x'
073A 21F0FE3D       682			BZ	R1, MAINMENU
073E 3105001B       683			SUB	R1, R0, ESC
0742 21F0FE39       684			BZ	R1, MAINMENU
0746 31050049       685			SUB	R1, R0, 'I'
074A 21F0005B       686			BZ	R1, .INCLINE
074E 31050069       687			SUB	R1, R0, 'i'
0752 21F00057       688			BZ	R1, .INCLINE
0756 3105007A       689			SUB	R1, R0, 'z'
075A 21F00057       690			BZ	R1, .ZEROVAL
075E 3105005A       691			SUB	R1, R0, 'Z'
0762 21F00053       692			BZ	R1, .ZEROVAL
0766 3105000A       693			SUB	R1, R0, LF
076A 21F00056       694			BZ	R1, .GOTO
076E 3105000D       695			SUB	R1, R0, CR
0772 21F00052       696			BZ	R1, .GOTO
0776 31050008       697			SUB	R1, R0, BS
077A 21F00054       698			BZ	R1, .BACK
077E 3105007F       699			SUB	R1, R0, DEL
0782 21F00050       700			BZ	R1, .BACK
0786 31050052       701			SUB	R1, R0, 'R'
078A 21F00062       702			BZ	R1, .EXEC
078E 31050072       703			SUB	R1, R0, 'r'
0792 21F0005E       704			BZ	R1, .EXEC
0796 31050050       705			SUB	R1, R0, 'P'
079A 21F0004E       706			BZ	R1, .POKE
079E 31050070       707			SUB	R1, R0, 'p'
07A2 21F0004A       708			BZ	R1, .POKE
07A6 3105004B       709			SUB	R1, R0, 'K'
07AA 21F00046       710			BZ	R1, .POKE
07AE 3105006B       711			SUB	R1, R0, 'k'
07B2 21F00042       712			BZ	R1, .POKE
07B6 31050009       713			SUB	R1, R0, TAB
07BA 21F00046       714			BZ	R1, .NEXT
07BE                715	
07BE                716			# hex digit ?
07BE 31F90030       717			LI	R1, '0'
07C2 2012FFB1       718			BLT	R0, R1, .READCMD
07C6 32F90039       719			LI	R2, '9'
07CA 22020003       720			BLT	R2, R0, .NODEC
07CE 5001           721			SUB	R0, R1
07D0 2FF0000D       722			BRA	.ADDVAL
07D4 30090020       723	.NODEC		OR	R0, $20 # lowercase
07D8 31F90061       724			LI	R1, 'a'
07DC 2012FFA4       725			BLT	R0, R1, .READCMD
07E0 32F90066       726			LI	R2, 'f'
07E4 2202FFA0       727			BLT	R2, R0, .READCMD
07E8 5001           728			SUB	R0, R1
07EA 3004000A       729			ADD	R0, 10
07EE 31F92000       730	.ADDVAL 	LI	R1, MMON_VALUE
07F2 12140000       731			LD4	R2, [R1]
07F6 322B0004       732			SHL	R2, 4
07FA 9220           733			OR	R2, R0
07FC 121A0000       734			ST4	[R1], R2
0800 2FF0FF86       735			BRA	.PARTIAL
0804                736	
0804 3CC40001       737	.INCLINE	ADD	R12, 1
0808 2FF0FF3F       738			BRA	.REFRESH
080C 31F92000       739	.ZEROVAL	LI	R1, MMON_VALUE
0810 80FF           740			LI	R0, 0
0812 101A0000       741			ST4	[R1], R0
0816 2FF0FF7B       742			BRA	.PARTIAL
081A 31F92000       743	.GOTO		LI	R1, MMON_VALUE
081E 1D140000       744			LD4	R13, [R1]
0822 2FF0FF32       745			BRA	.REFRESH
0826 31F92000       746	.BACK		LI	R1, MMON_VALUE
082A 10140000       747			LD4	R0, [R1]
082E 300C0004       748			SHR	R0, 4
0832 101A0000       749			ST4	[R1], R0
0836 2FF0FF6B       750			BRA	.PARTIAL
083A 31F92000       751	.POKE		LI	R1, MMON_VALUE
083E 10140000       752			LD4	R0, [R1]
0842 10D80000       753			ST1	[R13], R0
0846 2FF0FF20       754			BRA	.REFRESH
084A 3DD40001       755	.NEXT		ADD	R13, 1
084E 2FF0FF1C       756			BRA	.REFRESH
0852 31F92000       757	.EXEC		LI	R1, MMON_VALUE
0856 11140000       758			LD4	R1, [R1]
085A 0F10           759			JMP	R1
####################### jforth.asm
085C                  1	#
085C                  2	# jonesforth.S translated to eon cpu
085C                  3	# (c) JCGV, agosto del 2022
085C                  4	#
085C                  5	
085C                  6	#
085C                  7	#	A sometimes minimal FORTH compiler and tutorial for Linux / i386 systems. -*- asm -*-
085C                  8	#	By Richard W.M. Jones <rich@annexia.org> http://annexia.org/forth
085C                  9	#	This is PUBLIC DOMAIN (see public domain release statement below).
085C                 10	#	$Id: jonesforth.S,v 1.47 2009-09-11 08:33:13 rich Exp $
085C                 11	#
085C                 12	#	gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
085C                 13	#
085C = 0000.002F     14	JONES_VERSION	.EQU	47
085C                 15	
085C                 16	#	INTRODUCTION ----------------------------------------------------------------------
085C                 17	#
085C                 18	#	FORTH is one of those alien languages which most working programmers regard in the same
085C                 19	#	way as Haskell, LISP, and so on.  Something so strange that they'd rather any thoughts
085C                 20	#	of it just go away so they can get on with writing this paying code.  But that's wrong
085C                 21	#	and if you care at all about programming then you should at least understand all these
085C                 22	#	languages, even if you will never use them.
085C                 23	
085C                 24	#	LISP is the ultimate high-level language, and features from LISP are being added every
085C                 25	#	decade to the more common languages.  But FORTH is in some ways the ultimate in low level
085C                 26	#	programming.  Out of the box it lacks features like dynamic memory management and even
085C                 27	#	strings.  In fact, at its primitive level it lacks even basic concepts like IF-statements
085C                 28	#	and loops.
085C                 29	
085C                 30	#	Why then would you want to learn FORTH?  There are several very good reasons.  First
085C                 31	#	and foremost, FORTH is minimal.  You really can write a complete FORTH in, say, 2000
085C                 32	#	lines of code.	I don't just mean a FORTH program, I mean a complete FORTH operating
085C                 33	#	system, environment and language.  You could boot such a FORTH on a bare PC and it would
085C                 34	#	come up with a prompt where you could start doing useful work.	The FORTH you have here
085C                 35	#	isn't minimal and uses a Linux process as its 'base PC' (both for the purposes of making
085C                 36	#	it a good tutorial). It's possible to completely understand the system.  Who can say they
085C                 37	#	completely understand how Linux works, or gcc?
085C                 38	
085C                 39	#	Secondly FORTH has a peculiar bootstrapping property.  By that I mean that after writing
085C                 40	#	a little bit of assembly to talk to the hardware and implement a few primitives, all the
085C                 41	#	rest of the language and compiler is written in FORTH itself.  Remember I said before
085C                 42	#	that FORTH lacked IF-statements and loops?  Well of course it doesn't really because
085C                 43	#	such a lanuage would be useless, but my point was rather that IF-statements and loops are
085C                 44	#	written in FORTH itself.
085C                 45	
085C                 46	#	Now of course this is common in other languages as well, and in those languages we call
085C                 47	#	them 'libraries'.  For example in C, 'printf' is a library function written in C.  But
085C                 48	#	in FORTH this goes way beyond mere libraries.  Can you imagine writing C's 'if' in C?
085C                 49	#	And that brings me to my third reason: If you can write 'if' in FORTH, then why restrict
085C                 50	#	yourself to the usual if/while/for/switch constructs?  You want a construct that iterates
085C                 51	#	over every other element in a list of numbers?	You can add it to the language.  What
085C                 52	#	about an operator which pulls in variables directly from a configuration file and makes
085C                 53	#	them available as FORTH variables?  Or how about adding Makefile-like dependencies to
085C                 54	#	the language?  No problem in FORTH.  How about modifying the FORTH compiler to allow
085C                 55	#	complex inlining strategies -- simple.	This concept isn't common in programming languages,
085C                 56	#	but it has a name (in fact two names): "macros" (by which I mean LISP-style macros, not
085C                 57	#	the lame C preprocessor) and "domain specific languages" (DSLs).
085C                 58	
085C                 59	#	This tutorial isn't about learning FORTH as the language.  I'll point you to some references
085C                 60	#	you should read if you're not familiar with using FORTH.  This tutorial is about how to
085C                 61	#	write FORTH.  In fact, until you understand how FORTH is written, you'll have only a very
085C                 62	#	superficial understanding of how to use it.
085C                 63	
085C                 64	#	So if you're not familiar with FORTH or want to refresh your memory here are some online
085C                 65	#	references to read:
085C                 66	
085C                 67	#	http://en.wikipedia.org/wiki/Forth_%28programming_language%29
085C                 68	#	http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm
085C                 69	#	http://wiki.laptop.org/go/Forth_Lessons
085C                 70	#	http://www.albany.net/~hello/simple.htm
085C                 71	#	Here is another "Why FORTH?" essay: http://www.jwdt.com/~paysan/why-forth.html
085C                 72	#	Discussion and criticism of this FORTH here: http://lambda-the-ultimate.org/node/2452
085C                 73	
085C                 74	#	ACKNOWLEDGEMENTS ----------------------------------------------------------------------
085C                 75	
085C                 76	#	This code draws heavily on the design of LINA FORTH (http://home.hccnet.nl/a.w.m.van.der.horst/lina.html)
085C                 77	#	by Albert van der Horst.  Any similarities in the code are probably not accidental.
085C                 78	
085C                 79	#	Some parts of this FORTH are also based on this IOCCC entry from 1992:
085C                 80	#	http://ftp.funet.fi/pub/doc/IOCCC/1992/buzzard.2.design.
085C                 81	#	I was very proud when Sean Barrett, the original author of the IOCCC entry, commented in the LtU thread
085C                 82	#	http://lambda-the-ultimate.org/node/2452#comment-36818 about this FORTH.
085C                 83	
085C                 84	#	And finally I'd like to acknowledge the (possibly forgotten?) authors of ARTIC FORTH because their
085C                 85	#	original program which I still have on original cassette tape kept nagging away at me all these years.
085C                 86	#	http://en.wikipedia.org/wiki/Artic_Software
085C                 87	
085C                 88	#	PUBLIC DOMAIN ----------------------------------------------------------------------
085C                 89	
085C                 90	#	I, the copyright holder of this work, hereby release it into the public domain. This applies worldwide.
085C                 91	
085C                 92	#	In case this is not legally possible, I grant any entity the right to use this work for any purpose,
085C                 93	#	without any conditions, unless such conditions are required by law.
085C                 94	
085C                 95	#	SETTING UP ----------------------------------------------------------------------
085C                 96	
085C                 97	#	Let's get a few housekeeping things out of the way.  Firstly because I need to draw lots of
085C                 98	#	ASCII-art diagrams to explain concepts, the best way to look at this is using a window which
085C                 99	#	uses a fixed width font and is at least this wide:
085C                100	
085C                101	#<------------------------------------------------------------------------------------------------------------------------>
085C                102	
085C                103	#	Secondly make sure TABS are set to 8 characters.  The following should be a vertical
085C                104	#	line.  If not, sort out your tabs.
085C                105	
085C                106	#		|
085C                107	#		|
085C                108	#		|
085C                109	
085C                110	#	Thirdly I assume that your screen is at least 50 characters high.
085C                111	
085C                112	#	ASSEMBLING ----------------------------------------------------------------------
085C                113	
085C                114	#	If you want to actually run this FORTH, rather than just read it, you will need Linux on an
085C                115	#	i386.  Linux because instead of programming directly to the hardware on a bare PC which I
085C                116	#	could have done, I went for a simpler tutorial by assuming that the 'hardware' is a Linux
085C                117	#	process with a few basic system calls (read, write and exit and that's about all).  i386
085C                118	#	is needed because I had to write the assembly for a processor, and i386 is by far the most
085C                119	#	common.  (Of course when I say 'i386', any 32- or 64-bit x86 processor will do.  I'm compiling
085C                120	#	this on a 64 bit AMD Opteron).
085C                121	
085C                122	#	Again, to assemble this you will need gcc and gas (the GNU assembler).	The commands to
085C                123	#	assemble and run the code (save this file as 'jonesforth.S') are:
085C                124	
085C                125	#	gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
085C                126	#	cat jonesforth.f - | ./jonesforth
085C                127	
085C                128	#	If you want to run your own FORTH programs you can do:
085C                129	
085C                130	#	cat jonesforth.f myprog.f | ./jonesforth
085C                131	
085C                132	#	If you want to load your own FORTH code and then continue reading user commands, you can do:
085C                133	
085C                134	#	cat jonesforth.f myfunctions.f - | ./jonesforth
085C                135	
085C                136	#	ASSEMBLER ----------------------------------------------------------------------
085C                137	
085C                138	#	(You can just skip to the next section -- you don't need to be able to read assembler to
085C                139	#	follow this tutorial).
085C                140	
085C                141	#	However if you do want to read the assembly code here are a few notes about gas (the GNU assembler):
085C                142	
085C                143	#	(1) Register names are prefixed with '%', so %eax is the 32 bit i386 accumulator.  The registers
085C                144	#	    available on i386 are: %eax, %ebx, %ecx, %edx, %esi, %edi, %ebp and %esp, and most of them
085C                145	#	    have special purposes.
085C                146	
085C                147	#	(2) Add, mov, etc. take arguments in the form SRC,DEST.  So mov %eax,%ecx moves %eax -> %ecx
085C                148	
085C                149	#	(3) Constants are prefixed with '$', and you mustn't forget it!  If you forget it then it
085C                150	#	    causes a read from memory instead, so:
085C                151	#	    mov $2,%eax 	moves number 2 into %eax
085C                152	#	    mov 2,%eax		reads the 32 bit word from address 2 into %eax (ie. most likely a mistake)
085C                153	
085C                154	#	(4) gas has a funky syntax for local labels, where '1f' (etc.) means label '1:' "forwards"
085C                155	#	    and '1b' (etc.) means label '1:' "backwards".  Notice that these labels might be mistaken
085C                156	#	    for hex numbers (eg. you might confuse 1b with $0x1b).
085C                157	
085C                158	#	(5) 'ja' is "jump if above", 'jb' for "jump if below", 'je' "jump if equal" etc.
085C                159	
085C                160	#	(6) gas has a reasonably nice .macro syntax, and I use them a lot to make the code shorter and
085C                161	#	    less repetitive.
085C                162	
085C                163	#	For more help reading the assembler, do "info gas" at the Linux prompt.
085C                164	
085C                165	#	Now the tutorial starts in earnest.
085C                166	
085C                167	#	THE DICTIONARY ----------------------------------------------------------------------
085C                168	
085C                169	#	In FORTH as you will know, functions are called "words", and just as in other languages they
085C                170	#	have a name and a definition.  Here are two FORTH words:
085C                171	
085C                172	#	: DOUBLE DUP + ;		\ name is "DOUBLE", definition is "DUP +"
085C                173	#	: QUADRUPLE DOUBLE DOUBLE ;	\ name is "QUADRUPLE", definition is "DOUBLE DOUBLE"
085C                174	
085C                175	#	Words, both built-in ones and ones which the programmer defines later, are stored in a dictionary
085C                176	#	which is just a linked list of dictionary entries.
085C                177	
085C                178	#	<--- DICTIONARY ENTRY (HEADER) ----------------------->
085C                179	#	+------------------------+--------+---------- - - - - +----------- - - - -
085C                180	#	| LINK POINTER		 | LENGTH/| NAME	      | DEFINITION
085C                181	#	|			 | FLAGS  |		      |
085C                182	#	+--- (4 bytes) ----------+- byte -+- n bytes  - - - - +----------- - - - -
085C                183	
085C                184	#	I'll come to the definition of the word later.	For now just look at the header.  The first
085C                185	#	4 bytes are the link pointer.  This points back to the previous word in the dictionary, or, for
085C                186	#	the first word in the dictionary it is just a NULL pointer.  Then comes a length/flags byte.
085C                187	#	The length of the word can be up to 31 characters (5 bits used) and the top three bits are used
085C                188	#	for various flags which I'll come to later.  This is followed by the name itself, and in this
085C                189	#	implementation the name is rounded up to a multiple of 4 bytes by padding it with zero bytes.
085C                190	#	That's just to ensure that the definition starts on a 32 bit boundary.
085C                191	
085C                192	#	A FORTH variable called LATEST contains a pointer to the most recently defined word, in
085C                193	#	other words, the head of this linked list.
085C                194	
085C                195	#	DOUBLE and QUADRUPLE might look like this:
085C                196	
085C                197	#	  pointer to previous word
085C                198	#	   ^
085C                199	#	   |
085C                200	#	+--|------+---+---+---+---+---+---+---+---+------------- - - - -
085C                201	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | (definition ...)
085C                202	#	+---------+---+---+---+---+---+---+---+---+------------- - - - -
085C                203	#	   ^	   len			       padding
085C                204	#	   |
085C                205	#	+--|------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
085C                206	#	| LINK	  | 9 | Q | U | A | D | R | U | P | L | E | 0 | 0 | (definition ...)
085C                207	#	+---------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
085C                208	#	   ^	   len					   padding
085C                209	#	   |
085C                210	#	   |
085C                211	#	  LATEST
085C                212	
085C                213	#	You should be able to see from this how you might implement functions to find a word in
085C                214	#	the dictionary (just walk along the dictionary entries starting at LATEST and matching
085C                215	#	the names until you either find a match or hit the NULL pointer at the end of the dictionary);
085C                216	#	and add a word to the dictionary (create a new definition, set its LINK to LATEST, and set
085C                217	#	LATEST to point to the new word).  We'll see precisely these functions implemented in
085C                218	#	assembly code later on.
085C                219	
085C                220	#	One interesting consequence of using a linked list is that you can redefine words, and
085C                221	#	a newer definition of a word overrides an older one.  This is an important concept in
085C                222	#	FORTH because it means that any word (even "built-in" or "standard" words) can be
085C                223	#	overridden with a new definition, either to enhance it, to make it faster or even to
085C                224	#	disable it.  However because of the way that FORTH words get compiled, which you'll
085C                225	#	understand below, words defined using the old definition of a word continue to use
085C                226	#	the old definition.  Only words defined after the new definition use the new definition.
085C                227	
085C                228	#	DIRECT THREADED CODE ----------------------------------------------------------------------
085C                229	
085C                230	#	Now we'll get to the really crucial bit in understanding FORTH, so go and get a cup of tea
085C                231	#	or coffee and settle down.  It's fair to say that if you don't understand this section, then you
085C                232	#	won't "get" how FORTH works, and that would be a failure on my part for not explaining it well.
085C                233	#	So if after reading this section a few times you don't understand it, please email me
085C                234	#	(rich@annexia.org).
085C                235	
085C                236	#	Let's talk first about what "threaded code" means.  Imagine a peculiar version of C where
085C                237	#	you are only allowed to call functions without arguments.  (Don't worry for now that such a
085C                238	#	language would be completely useless!)	So in our peculiar C, code would look like this:
085C                239	
085C                240	#	f ()
085C                241	#	{
085C                242	#	  a ();
085C                243	#	  b ();
085C                244	#	  c ();
085C                245	#	}
085C                246	
085C                247	#	and so on.  How would a function, say 'f' above, be compiled by a standard C compiler?
085C                248	#	Probably into assembly code like this.	On the right hand side I've written the actual
085C                249	#	i386 machine code.
085C                250	
085C                251	#	f:
085C                252	#	  CALL a			E8 08 00 00 00
085C                253	#	  CALL b			E8 1C 00 00 00
085C                254	#	  CALL c			E8 2C 00 00 00
085C                255	#	  ; ignore the return from the function for now
085C                256	
085C                257	#	"E8" is the x86 machine code to "CALL" a function.  In the first 20 years of computing
085C                258	#	memory was hideously expensive and we might have worried about the wasted space being used
085C                259	#	by the repeated "E8" bytes.  We can save 20% in code size (and therefore, in expensive memory)
085C                260	#	by compressing this into just:
085C                261	
085C                262	#	08 00 00 00		Just the function addresses, without
085C                263	#	1C 00 00 00		the CALL prefix.
085C                264	#	2C 00 00 00
085C                265	
085C                266	#	On a 16-bit machine like the ones which originally ran FORTH the savings are even greater - 33%.
085C                267	
085C                268	#	[Historical note: If the execution model that FORTH uses looks strange from the following
085C                269	#	paragraphs, then it was motivated entirely by the need to save memory on early computers.
085C                270	#	This code compression isn't so important now when our machines have more memory in their L1
085C                271	#	caches than those early computers had in total, but the execution model still has some
085C                272	#	useful properties].
085C                273	
085C                274	#	Of course this code won't run directly on the CPU any more.  Instead we need to write an
085C                275	#	interpreter which takes each set of bytes and calls it.
085C                276	
085C                277	#	On an i386 machine it turns out that we can write this interpreter rather easily, in just
085C                278	#	two assembly instructions which turn into just 3 bytes of machine code.  Let's store the
085C                279	#	pointer to the next word to execute in the %esi register:
085C                280	
085C                281	#		08 00 00 00	<- We're executing this one now.  %esi is the _next_ one to execute.
085C                282	#	%esi -> 1C 00 00 00
085C                283	#		2C 00 00 00
085C                284	
085C                285	#	The all-important i386 instruction is called LODSL (or in Intel manuals, LODSW).  It does
085C                286	#	two things.  Firstly it reads the memory at %esi into the accumulator (%eax).  Secondly it
085C                287	#	increments %esi by 4 bytes.  So after LODSL, the situation now looks like this:
085C                288	
085C                289	#		08 00 00 00	<- We're still executing this one
085C                290	#		1C 00 00 00	<- %eax now contains this address (0x0000001C)
085C                291	#	%esi -> 2C 00 00 00
085C                292	
085C                293	#	Now we just need to jump to the address in %eax.  This is again just a single x86 instruction
085C                294	#	written JMP *(%eax).  And after doing the jump, the situation looks like:
085C                295	
085C                296	#		08 00 00 00
085C                297	#		1C 00 00 00	<- Now we're executing this subroutine.
085C                298	#	%esi -> 2C 00 00 00
085C                299	
085C                300	#	To make this work, each subroutine is followed by the two instructions 'LODSL; JMP *(%eax)'
085C                301	#	which literally make the jump to the next subroutine.
085C                302	
085C                303	#	And that brings us to our first piece of actual code!  Well, it's a macro.
085C                304	#
085C                305	
085C                306	#	.macro NEXT
085C                307	#	lodsl
085C                308	#	jmp *(%eax)
085C                309	#	.endm
085C                310	#EON#	R12 = ESI, R0 = EAX
085C                311	#EON#	ld4	r0, [r12]
085C                312	#EON#	add	4, r12
085C                313	#EON#	ld4	r1, [r0]
085C                314	#EON#	jmp	r1
085C                315	
085C                316	#	The macro is called NEXT.  That's a FORTH-ism.	It expands to those two instructions.
085C                317	
085C                318	#	Every FORTH primitive that we write has to be ended by NEXT.  Think of it kind of like
085C                319	#	a return.
085C                320	
085C                321	#	The above describes what is known as direct threaded code.
085C                322	
085C                323	#	To sum up: We compress our function calls down to a list of addresses and use a somewhat
085C                324	#	magical macro to act as a "jump to next function in the list".	We also use one register (%esi)
085C                325	#	to act as a kind of instruction pointer, pointing to the next function in the list.
085C                326	
085C                327	#	I'll just give you a hint of what is to come by saying that a FORTH definition such as:
085C                328	
085C                329	#	: QUADRUPLE DOUBLE DOUBLE ;
085C                330	
085C                331	#	actually compiles (almost, not precisely but we'll see why in a moment) to a list of
085C                332	#	function addresses for DOUBLE, DOUBLE and a special function called EXIT to finish off.
085C                333	
085C                334	#	At this point, REALLY EAGLE-EYED ASSEMBLY EXPERTS are saying "JONES, YOU'VE MADE A MISTAKE!".
085C                335	
085C                336	#	I lied about JMP *(%eax).
085C                337	
085C                338	#	INDIRECT THREADED CODE ----------------------------------------------------------------------
085C                339	
085C                340	#	It turns out that direct threaded code is interesting but only if you want to just execute
085C                341	#	a list of functions written in assembly language.  So QUADRUPLE would work only if DOUBLE
085C                342	#	was an assembly language function.  In the direct threaded code, QUADRUPLE would look like:
085C                343	
085C                344	#		+------------------+
085C                345	#		| addr of DOUBLE  --------------------> (assembly code to do the double)
085C                346	#		+------------------+			NEXT
085C                347	#	%esi -> | addr of DOUBLE   |
085C                348	#		+------------------+
085C                349	
085C                350	#	We can add an extra indirection to allow us to run both words written in assembly language
085C                351	#	(primitives written for speed) and words written in FORTH themselves as lists of addresses.
085C                352	
085C                353	#	The extra indirection is the reason for the brackets in JMP *(%eax).
085C                354	
085C                355	#	Let's have a look at how QUADRUPLE and DOUBLE really look in FORTH:
085C                356	
085C                357	#		: QUADRUPLE DOUBLE DOUBLE ;
085C                358	
085C                359	#		+------------------+
085C                360	#		| codeword	   |		   : DOUBLE DUP + ;
085C                361	#		+------------------+
085C                362	#		| addr of DOUBLE  ---------------> +------------------+
085C                363	#		+------------------+		   | codeword	      |
085C                364	#		| addr of DOUBLE   |		   +------------------+
085C                365	#		+------------------+		   | addr of DUP   --------------> +------------------+
085C                366	#		| addr of EXIT	   |		   +------------------+ 	   | codeword	   -------+
085C                367	#		+------------------+	   %esi -> | addr of +	   --------+	   +------------------+   |
085C                368	#						   +------------------+    |	   | assembly to    <-----+
085C                369	#						   | addr of EXIT     |    |	   | implement DUP    |
085C                370	#						   +------------------+    |	   |	..	      |
085C                371	#									   |	   |	..	      |
085C                372	#									   |	   | NEXT	      |
085C                373	#									   |	   +------------------+
085C                374	#									   |
085C                375	#									   +-----> +------------------+
085C                376	#										   | codeword	   -------+
085C                377	#										   +------------------+   |
085C                378	#										   | assembly to   <------+
085C                379	#										   | implement +      |
085C                380	#										   |	..	      |
085C                381	#										   |	..	      |
085C                382	#										   | NEXT	      |
085C                383	#										   +------------------+
085C                384	
085C                385	#	This is the part where you may need an extra cup of tea/coffee/favourite caffeinated
085C                386	#	beverage.  What has changed is that I've added an extra pointer to the beginning of
085C                387	#	the definitions.  In FORTH this is sometimes called the "codeword".  The codeword is
085C                388	#	a pointer to the interpreter to run the function.  For primitives written in
085C                389	#	assembly language, the "interpreter" just points to the actual assembly code itself.
085C                390	#	They don't need interpreting, they just run.
085C                391	
085C                392	#	In words written in FORTH (like QUADRUPLE and DOUBLE), the codeword points to an interpreter
085C                393	#	function.
085C                394	
085C                395	#	I'll show you the interpreter function shortly, but let's recall our indirect
085C                396	#	JMP *(%eax) with the "extra" brackets.	Take the case where we're executing DOUBLE
085C                397	#	as shown, and DUP has been called.  Note that %esi is pointing to the address of +
085C                398	
085C                399	#	The assembly code for DUP eventually does a NEXT.  That:
085C                400	
085C                401	#	(1) reads the address of + into %eax		%eax points to the codeword of +
085C                402	#	(2) increments %esi by 4
085C                403	#	(3) jumps to the indirect %eax			jumps to the address in the codeword of +,
085C                404	#							ie. the assembly code to implement +
085C                405	
085C                406	#		+------------------+
085C                407	#		| codeword	   |
085C                408	#		+------------------+
085C                409	#		| addr of DOUBLE  ---------------> +------------------+
085C                410	#		+------------------+		   | codeword	      |
085C                411	#		| addr of DOUBLE   |		   +------------------+
085C                412	#		+------------------+		   | addr of DUP   --------------> +------------------+
085C                413	#		| addr of EXIT	   |		   +------------------+ 	   | codeword	   -------+
085C                414	#		+------------------+		   | addr of +	   --------+	   +------------------+   |
085C                415	#						   +------------------+    |	   | assembly to    <-----+
085C                416	#					   %esi -> | addr of EXIT     |    |	   | implement DUP    |
085C                417	#						   +------------------+    |	   |	..	      |
085C                418	#									   |	   |	..	      |
085C                419	#									   |	   | NEXT	      |
085C                420	#									   |	   +------------------+
085C                421	#									   |
085C                422	#									   +-----> +------------------+
085C                423	#										   | codeword	   -------+
085C                424	#										   +------------------+   |
085C                425	#									now we're  | assembly to    <-----+
085C                426	#									executing  | implement +      |
085C                427	#									this	   |	..	      |
085C                428	#									function   |	..	      |
085C                429	#										   | NEXT	      |
085C                430	#										   +------------------+
085C                431	
085C                432	#	So I hope that I've convinced you that NEXT does roughly what you'd expect.  This is
085C                433	#	indirect threaded code.
085C                434	
085C                435	#	I've glossed over four things.	I wonder if you can guess without reading on what they are?
085C                436	
085C                437	#	.
085C                438	#	.
085C                439	#	.
085C                440	
085C                441	#	My list of four things are: (1) What does "EXIT" do?  (2) which is related to (1) is how do
085C                442	#	you call into a function, ie. how does %esi start off pointing at part of QUADRUPLE, but
085C                443	#	then point at part of DOUBLE.  (3) What goes in the codeword for the words which are written
085C                444	#	in FORTH?  (4) How do you compile a function which does anything except call other functions
085C                445	#	ie. a function which contains a number like : DOUBLE 2 * ; ?
085C                446	
085C                447	#	THE INTERPRETER AND RETURN STACK ------------------------------------------------------------
085C                448	
085C                449	#	Going at these in no particular order, let's talk about issues (3) and (2), the interpreter
085C                450	#	and the return stack.
085C                451	
085C                452	#	Words which are defined in FORTH need a codeword which points to a little bit of code to
085C                453	#	give them a "helping hand" in life.  They don't need much, but they do need what is known
085C                454	#	as an "interpreter", although it doesn't really "interpret" in the same way that, say,
085C                455	#	Java bytecode used to be interpreted (ie. slowly).  This interpreter just sets up a few
085C                456	#	machine registers so that the word can then execute at full speed using the indirect
085C                457	#	threaded model above.
085C                458	
085C                459	#	One of the things that needs to happen when QUADRUPLE calls DOUBLE is that we save the old
085C                460	#	%esi ("instruction pointer") and create a new one pointing to the first word in DOUBLE.
085C                461	#	Because we will need to restore the old %esi at the end of DOUBLE (this is, after all, like
085C                462	#	a function call), we will need a stack to store these "return addresses" (old values of %esi).
085C                463	
085C                464	#	As you will have seen in the background documentation, FORTH has two stacks, an ordinary
085C                465	#	stack for parameters, and a return stack which is a bit more mysterious.  But our return
085C                466	#	stack is just the stack I talked about in the previous paragraph, used to save %esi when
085C                467	#	calling from a FORTH word into another FORTH word.
085C                468	
085C                469	#	In this FORTH, we are using the normal stack pointer (%esp) for the parameter stack.
085C                470	#	We will use the i386's "other" stack pointer (%ebp, usually called the "frame pointer")
085C                471	#	for our return stack.
085C                472	#EON#	SP = parameter stack, R13 = return stack, R12 = ESI, R0 = EAX
085C                473	
085C                474	#	I've got two macros which just wrap up the details of using %ebp for the return stack.
085C                475	#	You use them as for example "PUSHRSP %eax" (push %eax on the return stack) or "POPRSP %ebx"
085C                476	#	(pop top of return stack into %ebx).
085C                477	
085C                478	
085C                479	# Macros to deal with the return stack.
085C                480	#	.macro PUSHRSP reg
085C                481	#	lea -4(%ebp),%ebp	// push reg on to return stack
085C                482	#	movl \reg,(%ebp)
085C                483	#	.endm
085C                484	#EON#	sub	r13, 4
085C                485	#EON#	st4	[r13], r0
085C                486	
085C                487	#	.macro POPRSP reg
085C                488	#	mov (%ebp),\reg 	// pop top of return stack to reg
085C                489	#	lea 4(%ebp),%ebp
085C                490	#	.endm
085C                491	#EON#	ld4	reg, [r13]
085C                492	#EON#	add	r13, 4
085C                493	
085C                494	#	And with that we can now talk about the interpreter.
085C                495	
085C                496	#	In FORTH the interpreter function is often called DOCOL (I think it means "DO COLON" because
085C                497	#	all FORTH definitions start with a colon, as in : DOUBLE DUP + ;
085C                498	
085C                499	#	The "interpreter" (it's not really "interpreting") just needs to push the old %esi on the
085C                500	#	stack and set %esi to the first word in the definition.  Remember that we jumped to the
085C                501	#	function using JMP *(%eax)?  Well a consequence of that is that conveniently %eax contains
085C                502	#	the address of this codeword, so just by adding 4 to it we get the address of the first
085C                503	#	data word.  Finally after setting up %esi, it just does NEXT which causes that first word
085C                504	#	to run.
085C                505	
085C                506	# DOCOL - the interpreter!
085C 3DD50004       507	DOCOL		SUB	R13, 4
0860 1CDA0000       508			ST4	[R13], R12	; push %esi on to the return stack
0864 3C040004       509			ADD	R12, R0, 4	; %eax points to codeword, make %esi point to first data word
0868 2FF0001E       510			BRA	NEXT
086C                511	
086C                512	#	Just to make this absolutely clear, let's see how DOCOL works when jumping from QUADRUPLE
086C                513	#	into DOUBLE:
086C                514	
086C                515	#		QUADRUPLE:
086C                516	#		+------------------+
086C                517	#		| codeword	   |
086C                518	#		+------------------+		   DOUBLE:
086C                519	#		| addr of DOUBLE  ---------------> +------------------+
086C                520	#		+------------------+	   %eax -> | addr of DOCOL    |
086C                521	#	%esi -> | addr of DOUBLE   |		   +------------------+
086C                522	#		+------------------+		   | addr of DUP      |
086C                523	#		| addr of EXIT	   |		   +------------------+
086C                524	#		+------------------+		   | etc.	      |
086C                525	
086C                526	#	First, the call to DOUBLE calls DOCOL (the codeword of DOUBLE).  DOCOL does this:  It
086C                527	#	pushes the old %esi on the return stack.  %eax points to the codeword of DOUBLE, so we
086C                528	#	just add 4 on to it to get our new %esi:
086C                529	
086C                530	#		 QUADRUPLE:
086C                531	#		 +------------------+
086C                532	#		 | codeword	    |
086C                533	#		 +------------------+		    DOUBLE:
086C                534	#		 | addr of DOUBLE  ---------------> +------------------+
086C                535	#top of return	 +------------------+	    %eax -> | addr of DOCOL    |
086C                536	#stack points -> | addr of DOUBLE   |	    + 4 =   +------------------+
086C                537	#		 +------------------+	    %esi -> | addr of DUP      |
086C                538	#		 | addr of EXIT     |		    +------------------+
086C                539	#		 +------------------+		    | etc.	       |
086C                540	
086C                541	#	Then we do NEXT, and because of the magic of threaded code that increments %esi again
086C                542	#	and calls DUP.
086C                543	
086C                544	#	Well, it seems to work.
086C                545	
086C                546	#	One minor point here.  Because DOCOL is the first bit of assembly actually to be defined
086C                547	#	in this file (the others were just macros), and because I usually compile this code with the
086C                548	#	text segment starting at address 0, DOCOL has address 0.  So if you are disassembling the
086C                549	#	code and see a word with a codeword of 0, you will immediately know that the word is
086C                550	#	written in FORTH (it's not an assembler primitive) and so uses DOCOL as the interpreter.
086C                551	#EON#	not true DOCOL has address 0 ! (it resides in ROM)
086C                552	
086C                553	#	STARTING UP ----------------------------------------------------------------------
086C                554	
086C                555	#	Now let's get down to nuts and bolts.  When we start the program we need to set up
086C                556	#	a few things like the return stack.  But as soon as we can, we want to jump into FORTH
086C                557	#	code (albeit much of the "early" FORTH code will still need to be written as
086C                558	#	assembly language primitives).
086C                559	
086C                560	#	This is what the set up code does.  Does a tiny bit of house-keeping, sets up the
086C                561	#	separate return stack (NB: Linux gives us the ordinary parameter stack already), then
086C                562	#	immediately jumps to a FORTH word called QUIT.	Despite its name, QUIT doesn't quit
086C                563	#	anything.  It resets some internal state and starts reading and interpreting commands.
086C                564	#	(The reason it is called QUIT is because you can call QUIT from your own FORTH code
086C                565	#	to "quit" your program and go back to interpreting).
086C                566	
086C 80FF           567	JFORTH		LI	R0, 0		; setup forth vars
086E 100A0801       568			ST4	[R0 + FORTH_STATE / 4], R0
0872 31F9000A       569			LI	R1, 10
0876 110A0804       570			ST4	[R0 + FORTH_BASE / 4], R1
087A 31F91BF0       571			LI	R1, F_INTERPRET
087E 110A0803       572			ST4	[R0 + FORTH_LATEST / 4], R1
0882 3DF94000       573			LI	R13, RSTACK
0886 1D0A0802       574			ST4	[R0 + FORTH_HERE / 4], R13
088A 30F91C78       575			LI	R0, FORTH_HELLO ; say hello
088E 0FFDFFFFFC1C   576			JAL	CONSTR
0894 3CF91C04       577			LI	R12, W_QUIT	; jump interpreter
0898 2FF00006       578			BRA	NEXT
089C                579	
089C 30F92F60       580	C_BYE		LI	R0, SYS_STACK
08A0 9FF0           581			MV	SP, R0
08A2 0FFCFFFFFD88   582			JMP	MAINMENU
08A8                583	
08A8                584	
08A8                585	#	BUILT-IN WORDS ----------------------------------------------------------------------
08A8                586	
08A8                587	#	Remember our dictionary entries (headers)?  Let's bring those together with the codeword
08A8                588	#	and data words to see how : DOUBLE DUP + ; really looks in memory.
08A8                589	
08A8                590	#	  pointer to previous word
08A8                591	#	   ^
08A8                592	#	   |
08A8                593	#	+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
08A8                594	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
08A8                595	#	+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
08A8                596	#	   ^	   len			       pad  codeword	  |
08A8                597	#	   |							  V
08A8                598	#	  LINK in next word				points to codeword of DUP
08A8                599	
08A8                600	#	Initially we can't just write ": DOUBLE DUP + ;" (ie. that literal string) here because we
08A8                601	#	don't yet have anything to read the string, break it up at spaces, parse each word, etc. etc.
08A8                602	#	So instead we will have to define built-in words using the GNU assembler data constructors
08A8                603	#	(like .int, .byte, .string, .ascii and so on -- look them up in the gas info page if you are
08A8                604	#	unsure of them).
08A8                605	
08A8                606	#	The long way would be:
08A8                607	
08A8                608	#	.int <link to previous word>
08A8                609	#	.byte 6 		// len
08A8                610	#	.ascii "DOUBLE" 	// string
08A8                611	#	.byte 0 		// padding
08A8                612	#DOUBLE:.int DOCOL		// codeword
08A8                613	#	.int DUP		// pointer to codeword of DUP
08A8                614	#	.int PLUS		// pointer to codeword of +
08A8                615	#	.int EXIT		// pointer to codeword of EXIT
08A8                616	
08A8                617	#	That's going to get quite tedious rather quickly, so here I define an assembler macro
08A8                618	#	so that I can just write:
08A8                619	
08A8                620	#	defword "DOUBLE",6,,DOUBLE
08A8                621	#	.int DUP,PLUS,EXIT
08A8                622	
08A8                623	#	and I'll get exactly the same effect.
08A8                624	
08A8                625	#	Don't worry too much about the exact implementation details of this macro - it's complicated!
08A8                626	
08A8                627	# Flags - these are discussed later.
08A8                628	#	.set F_IMMED,0x80
08A8                629	#	.set F_HIDDEN,0x20
08A8                630	#	.set F_LENMASK,0x1f	// length mask
08A8 = 0000.0080    631	F_IMMED 	.EQU	$80
08A8 = 0000.0020    632	F_HIDDEN	.EQU	$20
08A8 = 0000.001F    633	F_LENMASK	.EQU	$1F
08A8                634	
08A8                635	#	// Store the chain of links.
08A8                636	#	.set link,0
08A8                637	
08A8                638	#	.macro defword name, namelen, flags=0, label
08A8                639	#	.section .rodata
08A8                640	#	.align 4
08A8                641	#	.globl name_\label
08A8                642	#name_\label :
08A8                643	#	.int link		// link
08A8                644	#	.set link,name_\label
08A8                645	#	.byte \flags+\namelen	// flags + length byte
08A8                646	#	.ascii "\name"		// the name
08A8                647	#	.align 4		// padding to next 4 byte boundary
08A8                648	#	.globl \label
08A8                649	#\label :
08A8                650	#	.int DOCOL		// codeword - the interpreter
08A8                651	#	// list of word pointers follow
08A8                652	#	.endm
08A8                653	
08A8                654	#	Similarly I want a way to write words written in assembly language.  There will quite a few
08A8                655	#	of these to start with because, well, everything has to start in assembly before there's
08A8                656	#	enough "infrastructure" to be able to start writing FORTH words, but also I want to define
08A8                657	#	some common FORTH words in assembly language for speed, even though I could write them in FORTH.
08A8                658	
08A8                659	#	This is what DUP looks like in memory:
08A8                660	
08A8                661	#	  pointer to previous word
08A8                662	#	   ^
08A8                663	#	   |
08A8                664	#	+--|------+---+---+---+---+------------+
08A8                665	#	| LINK	  | 3 | D | U | P | code_DUP ---------------------> points to the assembly
08A8                666	#	+---------+---+---+---+---+------------+		    code used to write DUP,
08A8                667	#	   ^	   len		    codeword			    which ends with NEXT.
08A8                668	#	   |
08A8                669	#	  LINK in next word
08A8                670	
08A8                671	#	Again, for brevity in writing the header I'm going to write an assembler macro called defcode.
08A8                672	#	As with defword above, don't worry about the complicated details of the macro.
08A8                673	
08A8                674	#	.macro defcode name, namelen, flags=0, label
08A8                675	#	.section .rodata
08A8                676	#	.align 4
08A8                677	#	.globl name_\label
08A8                678	#name_\label :
08A8                679	#	.int link		// link
08A8                680	#	.set link,name_\label
08A8                681	#	.byte \flags+\namelen	// flags + length byte
08A8                682	#	.ascii "\name"		// the name
08A8                683	#	.align 4		// padding to next 4 byte boundary
08A8                684	#	.globl \label
08A8                685	#\label :
08A8                686	#	.int code_\label	// codeword
08A8                687	#	.text
08A8                688	#	//.align 4
08A8                689	#	.globl code_\label
08A8                690	#code_\label :			 // assembler code follows
08A8                691	#	.endm
08A8                692	
08A8                693	# next code
08A8 10C40000       694	NEXT		LD4	R0, [R12]	; R12 = ESI
08AC 3CC40004       695			ADD	R12, 4		; INC4 ESI
08B0 11040000       696			LD4	R1, [R0]	; GET CODEWORD
08B4 0F10           697			JMP	R1		; JUMP CODEWORD
08B6                698	
08B6                699	# illegal exception
08B6 0FF0           700	C_ILLEGAL	ILLEGAL
08B8                701	
08B8                702	# drop top of stack
08B8 0FF80001       703	C_DROP		ENTER	1		; drop top of stack
08BC 2FF0FFF4       704			BRA	NEXT
08C0                705	
08C0                706	# swap top two elements on stack
08C0 10F40000       707	C_SWAP		LD4	R0, [SP]
08C4 11F40002       708			LD4	R1, [SP + 2]
08C8 10FA0002       709			ST4	[SP + 2], R0
08CC 11FA0000       710			ST4	[SP], R1
08D0 2FF0FFEA       711			BRA	NEXT
08D4                712	
08D4                713	# duplicate top of stack
08D4 10F40000       714	C_DUP		LD4	R0, [SP]
08D8 0FF8FFFF       715			ENTER	-1
08DC 10FA0000       716			ST4	[SP], R0
08E0 2FF0FFE2       717			BRA	NEXT
08E4                718	
08E4                719	# get the second element of stack and push it on top
08E4 10F40002       720	C_OVER		LD4	R0, [SP + 2]
08E8 0FF8FFFF       721			ENTER	-1
08EC 10FA0000       722			ST4	[SP], R0
08F0 2FF0FFDA       723			BRA	NEXT
08F4                724	
08F4                725	# rotate elements on stack
08F4 10F40000       726	C_ROT		LD4	R0, [SP]
08F8 11F40002       727			LD4	R1, [SP + 2]
08FC 12F40004       728			LD4	R2, [SP + 4]
0900 11FA0004       729			ST4	[SP + 4], R1
0904 10FA0002       730			ST4	[SP + 2], R0
0908 12FA0000       731			ST4	[SP], R2
090C 2FF0FFCC       732			BRA	NEXT
0910                733	
0910 10F40000       734	C_NROT		LD4	R0, [SP]
0914 11F40002       735			LD4	R1, [SP + 2]
0918 12F40004       736			LD4	R2, [SP + 4]
091C 10FA0004       737			ST4	[SP + 4], R0
0920 12FA0002       738			ST4	[SP + 2], R2
0924 11FA0000       739			ST4	[SP], R1
0928 2FF0FFBE       740			BRA	NEXT
092C                741	
092C                742	#	 defcode "2DROP",5,,TWODROP // drop top two elements of stack
092C                743	#	 pop %eax
092C                744	#	 pop %eax
092C                745	#	 NEXT
092C                746	
092C                747	#	 defcode "2DUP",4,,TWODUP // duplicate top two elements of stack
092C                748	#	 mov (%esp),%eax
092C                749	#	 mov 4(%esp),%ebx
092C                750	#	 push %ebx
092C                751	#	 push %eax
092C                752	#	 NEXT
092C                753	
092C                754	#	 defcode "2SWAP",5,,TWOSWAP // swap top two pairs of elements of stack
092C                755	#	 pop %eax
092C                756	#	 pop %ebx
092C                757	#	 pop %ecx
092C                758	#	 pop %edx
092C                759	#	 push %ebx
092C                760	#	 push %eax
092C                761	#	 push %edx
092C                762	#	 push %ecx
092C                763	#	 NEXT
092C                764	
092C                765	# duplicate top of stack if non-zero
092C 10F40000       766	C_QDUP		LD4	R0, [SP]
0930 20F00004       767			BZ	R0, .DONE
0934 0FF8FFFF       768			ENTER	-1
0938 10FA0000       769			ST4	[SP], R0
093C 2FF0FFB4       770	.DONE		BRA	NEXT
0940                771	
0940                772	# aritmethic
0940 10F40000       773	C_INCR		LD4	R0, [SP]
0944 30040001       774			ADD	R0, 1
0948 10FA0000       775			ST4	[SP], R0
094C 2FF0FFAC       776			BRA	NEXT
0950                777	
0950 10F40000       778	C_DECR		LD4	R0, [SP]
0954 30050001       779			SUB	R0, 1
0958 10FA0000       780			ST4	[SP], R0
095C 2FF0FFA4       781			BRA	NEXT
0960                782	
0960 10F40000       783	C_INCR4 	LD4	R0, [SP]
0964 30040004       784			ADD	R0, 4
0968 10FA0000       785			ST4	[SP], R0
096C 2FF0FF9C       786			BRA	NEXT
0970                787	
0970 10F40000       788	C_DECR4 	LD4	R0, [SP]
0974 30050004       789			SUB	R0, 4
0978 10FA0000       790			ST4	[SP], R0
097C 2FF0FF94       791			BRA	NEXT
0980                792	
0980 10F40000       793	C_ADD		LD4	R0, [SP]
0984 0FF80001       794			ENTER	1
0988 11F40000       795			LD4	R1, [SP]
098C 4001           796			ADD	R0, R1
098E 10FA0000       797			ST4	[SP], R0
0992 2FF0FF89       798			BRA	NEXT
0996                799	
0996 11F40000       800	C_SUB		LD4	R1, [SP]
099A 0FF80001       801			ENTER	1
099E 10F40000       802			LD4	R0, [SP]
09A2 5001           803			SUB	R0, R1
09A4 10FA0000       804			ST4	[SP], R0
09A8 2FF0FF7E       805			BRA	NEXT
09AC                806	
09AC 11F40000       807	C_CRC32 	LD4	R1, [SP]
09B0 0FF80001       808			ENTER	1
09B4 10F40000       809			LD4	R0, [SP]
09B8 0FFDFFFFFC5B   810			JAL	CRC32
09BE 10FA0000       811			ST4	[SP], R0
09C2 2FF0FF71       812			BRA	NEXT
09C6                813	
09C6 10F40000       814	C_MUL		LD4	R0, [SP]
09CA 0FF80001       815			ENTER	1
09CE 11F40000       816			LD4	R1, [SP]
09D2 6001           817			MUL	R0, R1
09D4 10FA0000       818			ST4	[SP], R0
09D8 2FF0FF66       819			BRA	NEXT
09DC                820	
09DC                821	#	 defcode "*",1,,MUL
09DC                822	#	 pop %eax
09DC                823	#	 pop %ebx
09DC                824	#	 imull %ebx,%eax
09DC                825	#	 push %eax		 // ignore overflow
09DC                826	#	 NEXT
09DC                827	
09DC                828	#	In this FORTH, only /MOD is primitive.	Later we will define the / and MOD words in
09DC                829	#	terms of the primitive /MOD.  The design of the i386 assembly instruction idiv which
09DC                830	#	leaves both quotient and remainder makes this the obvious choice.
09DC                831	
09DC 11F40000       832	C_DIVMOD	LD4	R1, [SP]
09E0 10F40002       833			LD4	R0, [SP + 2]
09E4 7001           834			DIV	R0, R1
09E6 0F180000       835			GET	R1, REG_MOD
09EA 11FA0002       836			ST4	[SP + 2], R1	; remainder
09EE 10FA0000       837			ST4	[SP], R0	; quotient
09F2 2FF0FF59       838			BRA	NEXT
09F6                839	
09F6                840	#	Lots of comparison operations like =, <, >, etc..
09F6                841	#	ANS FORTH says that the comparison words should return all (binary) 1's for
09F6                842	#	TRUE and all 0's for FALSE.  However this is a bit of a strange convention
09F6                843	#	so this FORTH breaks it and returns the more normal (for C programmers ...)
09F6                844	#	1 meaning TRUE and 0 meaning FALSE.
09F6                845	
09F6 10F40000       846	C_EQU		LD4	R0, [SP]
09FA 0FF80001       847			ENTER	1
09FE 11F40000       848			LD4	R1, [SP]
0A02 5110           849			SUB	R1, R0
0A04 0018           850			CSETZ	R0, R1
0A06 10FA0000       851			ST4	[SP], R0
0A0A 2FF0FF4D       852			BRA	NEXT
0A0E                853	
0A0E 10F40000       854	C_NEQU		LD4	R0, [SP]
0A12 0FF80001       855			ENTER	1
0A16 11F40000       856			LD4	R1, [SP]
0A1A 5110           857			SUB	R1, R0
0A1C 0019           858			CSETNZ	R0, R1
0A1E 10FA0000       859			ST4	[SP], R0
0A22 2FF0FF41       860			BRA	NEXT
0A26                861	
0A26 10F40000       862	C_LT		LD4	R0, [SP]
0A2A 0FF80001       863			ENTER	1
0A2E 11F40000       864			LD4	R1, [SP]
0A32 5110           865			SUB	R1, R0
0A34 001A           866			CSETN	R0, R1
0A36 10FA0000       867			ST4	[SP], R0
0A3A 2FF0FF35       868			BRA	NEXT
0A3E                869	
0A3E 10F40000       870	C_GT		LD4	R0, [SP]
0A42 0FF80001       871			ENTER	1
0A46 11F40000       872			LD4	R1, [SP]
0A4A 5110           873			SUB	R1, R0
0A4C 001C           874			CSETP	R0, R1
0A4E 10FA0000       875			ST4	[SP], R0
0A52 2FF0FF29       876			BRA	NEXT
0A56                877	
0A56 10F40000       878	C_LE		LD4	R0, [SP]
0A5A 0FF80001       879			ENTER	1
0A5E 11F40000       880			LD4	R1, [SP]
0A62 5110           881			SUB	R1, R0
0A64 001D           882			CSETNP	R0, R1
0A66 10FA0000       883			ST4	[SP], R0
0A6A 2FF0FF1D       884			BRA	NEXT
0A6E                885	
0A6E 10F40000       886	C_GE		LD4	R0, [SP]
0A72 0FF80001       887			ENTER	1
0A76 11F40000       888			LD4	R1, [SP]
0A7A 5110           889			SUB	R1, R0
0A7C 001B           890			CSETNN	R0, R1
0A7E 10FA0000       891			ST4	[SP], R0
0A82 2FF0FF11       892			BRA	NEXT
0A86                893	
0A86 10F40000       894	C_ZEQU		LD4	R0, [SP]
0A8A 0008           895			CSETZ	R0, R0
0A8C 10FA0000       896			ST4	[SP], R0
0A90 2FF0FF0A       897			BRA	NEXT
0A94                898	
0A94 10F40000       899	C_ZNEQU 	LD4	R0, [SP]
0A98 0009           900			CSETNZ	R0, R0
0A9A 10FA0000       901			ST4	[SP], R0
0A9E 2FF0FF03       902			BRA	NEXT
0AA2                903	
0AA2 10F40000       904	C_ZLT		LD4	R0, [SP]
0AA6 000A           905			CSETN	R0, R0
0AA8 10FA0000       906			ST4	[SP], R0
0AAC 2FF0FEFC       907			BRA	NEXT
0AB0                908	
0AB0 10F40000       909	C_ZGT		LD4	R0, [SP]
0AB4 000C           910			CSETP	R0, R0
0AB6 10FA0000       911			ST4	[SP], R0
0ABA 2FF0FEF5       912			BRA	NEXT
0ABE                913	
0ABE 10F40000       914	C_ZLE		LD4	R0, [SP]
0AC2 000D           915			CSETNP	R0, R0
0AC4 10FA0000       916			ST4	[SP], R0
0AC8 2FF0FEEE       917			BRA	NEXT
0ACC                918	
0ACC 10F40000       919	C_ZGE		LD4	R0, [SP]
0AD0 000B           920			CSETNN	R0, R0
0AD2 10FA0000       921			ST4	[SP], R0
0AD6 2FF0FEE7       922			BRA	NEXT
0ADA                923	
0ADA 10F40000       924	C_AND		LD4	R0, [SP]
0ADE 0FF80001       925			ENTER	1
0AE2 11F40000       926			LD4	R1, [SP]
0AE6 8001           927			AND	R0, R1
0AE8 10FA0000       928			ST4	[SP], R0
0AEC 2FF0FEDC       929			BRA	NEXT
0AF0                930	
0AF0 10F40000       931	C_OR		LD4	R0, [SP]
0AF4 0FF80001       932			ENTER	1
0AF8 11F40000       933			LD4	R1, [SP]
0AFC 9001           934			OR	R0, R1
0AFE 10FA0000       935			ST4	[SP], R0
0B02 2FF0FED1       936			BRA	NEXT
0B06                937	
0B06 10F40000       938	C_XOR		LD4	R0, [SP]
0B0A 0FF80001       939			ENTER	1
0B0E 11F40000       940			LD4	R1, [SP]
0B12 A001           941			XOR	R0, R1
0B14 10FA0000       942			ST4	[SP], R0
0B18 2FF0FEC6       943			BRA	NEXT
0B1C                944	
0B1C                945	#	 defcode "INVERT",6,,INVERT // this is the FORTH bitwise "NOT" function (cf. NEGATE and NOT)
0B1C                946	#	 notl (%esp)
0B1C                947	#	 NEXT
0B1C                948	
0B1C                949	#	RETURNING FROM FORTH WORDS ----------------------------------------------------------------------
0B1C                950	
0B1C                951	#	Time to talk about what happens when we EXIT a function.  In this diagram QUADRUPLE has called
0B1C                952	#	DOUBLE, and DOUBLE is about to exit (look at where %esi is pointing):
0B1C                953	
0B1C                954	#		QUADRUPLE
0B1C                955	#		+------------------+
0B1C                956	#		| codeword	   |
0B1C                957	#		+------------------+		   DOUBLE
0B1C                958	#		| addr of DOUBLE  ---------------> +------------------+
0B1C                959	#		+------------------+		   | codeword	      |
0B1C                960	#		| addr of DOUBLE   |		   +------------------+
0B1C                961	#		+------------------+		   | addr of DUP      |
0B1C                962	#		| addr of EXIT	   |		   +------------------+
0B1C                963	#		+------------------+		   | addr of +	      |
0B1C                964	#						   +------------------+
0B1C                965	#					   %esi -> | addr of EXIT     |
0B1C                966	#						   +------------------+
0B1C                967	
0B1C                968	#	What happens when the + function does NEXT?  Well, the following code is executed.
0B1C 1CD40000       969	C_EXIT		LD4	R12, [R13]	; R12 = ESI, R13 = RSP
0B20 3DD40004       970			ADD	R13, 4
0B24 2FF0FEC0       971			BRA	NEXT
0B28                972	
0B28                973	#	EXIT gets the old %esi which we saved from before on the return stack, and puts it in %esi.
0B28                974	#	So after this (but just before NEXT) we get:
0B28                975	
0B28                976	#		QUADRUPLE
0B28                977	#		+------------------+
0B28                978	#		| codeword	   |
0B28                979	#		+------------------+		   DOUBLE
0B28                980	#		| addr of DOUBLE  ---------------> +------------------+
0B28                981	#		+------------------+		   | codeword	      |
0B28                982	#	%esi -> | addr of DOUBLE   |		   +------------------+
0B28                983	#		+------------------+		   | addr of DUP      |
0B28                984	#		| addr of EXIT	   |		   +------------------+
0B28                985	#		+------------------+		   | addr of +	      |
0B28                986	#						   +------------------+
0B28                987	#						   | addr of EXIT     |
0B28                988	#						   +------------------+
0B28                989	
0B28                990	#	And NEXT just completes the job by, well, in this case just by calling DOUBLE again :-)
0B28                991	
0B28                992	#	LITERALS ----------------------------------------------------------------------
0B28                993	
0B28                994	#	The final point I "glossed over" before was how to deal with functions that do anything
0B28                995	#	apart from calling other functions.  For example, suppose that DOUBLE was defined like this:
0B28                996	
0B28                997	#	: DOUBLE 2 * ;
0B28                998	
0B28                999	#	It does the same thing, but how do we compile it since it contains the literal 2?  One way
0B28               1000	#	would be to have a function called "2" (which you'd have to write in assembler), but you'd need
0B28               1001	#	a function for every single literal that you wanted to use.
0B28               1002	
0B28               1003	#	FORTH solves this by compiling the function using a special word called LIT:
0B28               1004	
0B28               1005	#	+---------------------------+-------+-------+-------+-------+-------+
0B28               1006	#	| (usual header of DOUBLE)  | DOCOL | LIT   | 2     | *     | EXIT  |
0B28               1007	#	+---------------------------+-------+-------+-------+-------+-------+
0B28               1008	
0B28               1009	#	LIT is executed in the normal way, but what it does next is definitely not normal.  It
0B28               1010	#	looks at %esi (which now points to the number 2), grabs it, pushes it on the stack, then
0B28               1011	#	manipulates %esi in order to skip the number as if it had never been there.
0B28               1012	
0B28               1013	#	What's neat is that the whole grab/manipulate can be done using a single byte single
0B28               1014	#	i386 instruction, our old friend LODSL.  Rather than me drawing more ASCII-art diagrams,
0B28               1015	#	see if you can find out how LIT works:
0B28 0FF8FFFF      1016	C_LIT		ENTER	-1
0B2C 10C50000      1017			LD4I	R0, [R12]
0B30 3CC40004      1018			ADD	R12, 4
0B34 10FA0000      1019			ST4	[SP], R0
0B38 2FF0FEB6      1020			BRA	NEXT
0B3C               1021	
0B3C               1022	#	MEMORY ----------------------------------------------------------------------
0B3C               1023	
0B3C               1024	#	As important point about FORTH is that it gives you direct access to the lowest levels
0B3C               1025	#	of the machine.  Manipulating memory directly is done frequently in FORTH, and these are
0B3C               1026	#	the primitive words for doing it.
0B3C 10F50000      1027	C_STORE 	LD4I	R0, [SP]
0B40 11F40002      1028			LD4	R1, [SP + 2]
0B44 0FF80002      1029			ENTER	2
0B48 110A0000      1030			ST4	[R0], R1
0B4C 2FF0FEAC      1031			BRA	NEXT
0B50               1032	
0B50 10F50000      1033	C_FETCH 	LD4I	R0, [SP]
0B54 11050000      1034			LD4I	R1, [R0]
0B58 11FA0000      1035			ST4	[SP], R1
0B5C 2FF0FEA4      1036			BRA	NEXT
0B60               1037	
0B60 10F50000      1038	C_ADDSTORE	LD4I	R0, [SP]
0B64 11F40002      1039			LD4	R1, [SP + 2]
0B68 0FF80002      1040			ENTER	2
0B6C 12040000      1041			LD4	R2, [R0]
0B70 4221          1042			ADD	R2, R1
0B72 120A0000      1043			ST4	[R0], R2
0B76 2FF0FE97      1044			BRA	NEXT
0B7A               1045	
0B7A 10F50000      1046	C_SUBSTORE	LD4I	R0, [SP]
0B7E 11F40002      1047			LD4	R1, [SP + 2]
0B82 0FF80002      1048			ENTER	2
0B86 12040000      1049			LD4	R2, [R0]
0B8A 5221          1050			SUB	R2, R1
0B8C 120A0000      1051			ST4	[R0], R2
0B90 2FF0FE8A      1052			BRA	NEXT
0B94               1053	
0B94               1054	#	! and @ (STORE and FETCH) store 32-bit words.  It's also useful to be able to read and write bytes
0B94               1055	#	so we also define standard words C@ and C!.
0B94               1056	#	Byte-oriented operations only work on architectures which permit them (i386 is one of those).
0B94 10F50000      1057	C_STOREBYTE	LD4I	R0, [SP]
0B98 11F00002      1058			LD1	R1, [SP + 2]
0B9C 0FF80002      1059			ENTER	2
0BA0 11080000      1060			ST1	[R0], R1
0BA4 2FF0FE80      1061			BRA	NEXT
0BA8               1062	
0BA8 10F50000      1063	C_FETCHBYTE	LD4I	R0, [SP]
0BAC 11000000      1064			LD1	R1, [R0]
0BB0 11FA0000      1065			ST4	[SP], R1
0BB4 2FF0FE78      1066			BRA	NEXT
0BB8               1067	
0BB8               1068	# C@C! is a useful byte copy primitive
0BB8               1069	#	 defcode "C@C!",4,,CCOPY
0BB8               1070	#	 movl 4(%esp),%ebx	 // source address
0BB8               1071	#	 movb (%ebx),%al	 // get source character
0BB8               1072	#	 pop %edi		 // destination address
0BB8               1073	#	 stosb			 // copy to destination
0BB8               1074	#	 push %edi		 // increment destination address
0BB8               1075	#	 incl 4(%esp)		 // increment source address
0BB8               1076	#	 NEXT
0BB8               1077	
0BB8               1078	# and CMOVE is a block copy operation.
0BB8               1079	#	 defcode "CMOVE",5,,CMOVE
0BB8               1080	#	 mov %esi,%edx		 // preserve %esi
0BB8               1081	#	 pop %ecx		 // length
0BB8               1082	#	 pop %edi		 // destination address
0BB8               1083	#	 pop %esi		 // source address
0BB8               1084	#	 rep movsb		 // copy source to destination
0BB8               1085	#	 mov %edx,%esi		 // restore %esi
0BB8               1086	#	 NEXT
0BB8               1087	
0BB8               1088	#	BUILT-IN VARIABLES ----------------------------------------------------------------------
0BB8               1089	
0BB8               1090	#	These are some built-in variables and related standard FORTH words.  Of these, the only one that we
0BB8               1091	#	have discussed so far was LATEST, which points to the last (most recently defined) word in the
0BB8               1092	#	FORTH dictionary.  LATEST is also a FORTH word which pushes the address of LATEST (the variable)
0BB8               1093	#	on to the stack, so you can read or write it using @ and ! operators.  For example, to print
0BB8               1094	#	the current value of LATEST (and this can apply to any FORTH variable) you would do:
0BB8               1095	
0BB8               1096	#	LATEST @ . CR
0BB8               1097	
0BB8               1098	#	To make defining variables shorter, I'm using a macro called defvar, similar to defword and
0BB8               1099	#	defcode above.	(In fact the defvar macro uses defcode to do the dictionary header).
0BB8               1100	
0BB8               1101	#	.macro defvar name, namelen, flags=0, label, initial=0
0BB8               1102	#	defcode \name,\namelen,\flags,\label
0BB8               1103	#	push $var_\name
0BB8               1104	#	NEXT
0BB8               1105	#	.data
0BB8               1106	#	.align 4
0BB8               1107	#v ar_\name :
0BB8               1108	#	.int \initial
0BB8               1109	#	.endm
0BB8               1110	
0BB8               1111	#	The built-in variables are:
0BB8               1112	#	STATE		Is the interpreter executing code (0) or compiling a word (non-zero)?
0BB8               1113	#	LATEST		Points to the latest (most recently defined) word in the dictionary.
0BB8               1114	#	HERE		Points to the next free byte of memory.  When compiling, compiled words go here.
0BB8               1115	#	S0		Stores the address of the top of the parameter stack.
0BB8               1116	#	BASE		The current base for printing and reading numbers.
0BB8               1117	
0BB8 30F92004      1118	C_STATE 	LI	R0, FORTH_STATE
0BBC 0FF8FFFF      1119			ENTER	-1
0BC0 10FA0000      1120			ST4	[SP], R0
0BC4 2FF0FE70      1121			BRA	NEXT
0BC8               1122	
0BC8 30F92008      1123	C_HERE		LI	R0, FORTH_HERE
0BCC 0FF8FFFF      1124			ENTER	-1
0BD0 10FA0000      1125			ST4	[SP], R0
0BD4 2FF0FE68      1126			BRA	NEXT
0BD8               1127	
0BD8 30F9200C      1128	C_LATEST	LI	R0, FORTH_LATEST
0BDC 0FF8FFFF      1129			ENTER	-1
0BE0 10FA0000      1130			ST4	[SP], R0
0BE4 2FF0FE60      1131			BRA	NEXT
0BE8               1132	
0BE8 30F92F60      1133	C_S0		LI	R0, SYS_STACK
0BEC 0FF8FFFF      1134			ENTER	-1
0BF0 10FA0000      1135			ST4	[SP], R0
0BF4 2FF0FE58      1136			BRA	NEXT
0BF8               1137	
0BF8 30F92010      1138	C_BASE		LI	R0, FORTH_BASE
0BFC 0FF8FFFF      1139			ENTER	-1
0C00 10FA0000      1140			ST4	[SP], R0
0C04 2FF0FE50      1141			BRA	NEXT
0C08               1142	
0C08               1143	#	BUILT-IN CONSTANTS ----------------------------------------------------------------------
0C08               1144	
0C08               1145	#	It's also useful to expose a few constants to FORTH.  When the word is executed it pushes a
0C08               1146	#	constant value on the stack.
0C08               1147	
0C08               1148	#	The built-in constants are:
0C08               1149	
0C08               1150	#	VERSION 	Is the current version of this FORTH.
0C08               1151	#	R0		The address of the top of the return stack.
0C08               1152	#	DOCOL		Pointer to DOCOL.
0C08               1153	#	F_IMMED 	The IMMEDIATE flag's actual value.
0C08               1154	#	F_HIDDEN	The HIDDEN flag's actual value.
0C08               1155	#	F_LENMASK	The length mask in the flags/len byte.
0C08               1156	
0C08               1157	#	SYS_*		and the numeric codes of various Linux syscalls (from <asm/unistd.h>)
0C08               1158	
0C08               1159	##include <asm-i386/unistd.h>  // you might need this instead
0C08               1160	##include <asm/unistd.h>
0C08               1161	
0C08               1162	#	 .macro defconst name, namelen, flags=0, label, value
0C08               1163	#	 defcode \name,\namelen,\flags,\label
0C08               1164	#	 push $\value
0C08               1165	#	 NEXT
0C08               1166	#	 .endm
0C08               1167	
0C08 30F9002F      1168	C_VERSION	LI	R0, JONES_VERSION
0C0C 0FF8FFFF      1169			ENTER	-1
0C10 10FA0000      1170			ST4	[SP], R0
0C14 2FF0FE48      1171			BRA	NEXT
0C18               1172	
0C18 30F94000      1173	C_R0		LI	R0, RSTACK
0C1C 0FF8FFFF      1174			ENTER	-1
0C20 10FA0000      1175			ST4	[SP], R0
0C24 2FF0FE40      1176			BRA	NEXT
0C28               1177	
0C28 30F9085C      1178	C_DOCOL 	LI	R0, DOCOL
0C2C 0FF8FFFF      1179			ENTER	-1
0C30 10FA0000      1180			ST4	[SP], R0
0C34 2FF0FE38      1181			BRA	NEXT
0C38               1182	
0C38 30F90080      1183	C_F_IMMED	LI	R0, F_IMMED
0C3C 0FF8FFFF      1184			ENTER	-1
0C40 10FA0000      1185			ST4	[SP], R0
0C44 2FF0FE30      1186			BRA	NEXT
0C48               1187	
0C48 30F90020      1188	C_F_HIDDEN	LI	R0, F_HIDDEN
0C4C 0FF8FFFF      1189			ENTER	-1
0C50 10FA0000      1190			ST4	[SP], R0
0C54 2FF0FE28      1191			BRA	NEXT
0C58               1192	
0C58 30F9001F      1193	C_F_LENMASK	LI	R0, F_LENMASK
0C5C 0FF8FFFF      1194			ENTER	-1
0C60 10FA0000      1195			ST4	[SP], R0
0C64 2FF0FE20      1196			BRA	NEXT
0C68               1197	
0C68               1198	#	RETURN STACK ----------------------------------------------------------------------
0C68               1199	#	These words allow you to access the return stack.  Recall that the register %ebp always points to
0C68               1200	#	the top of the return stack.
0C68 10F40000      1201	C_TOR		LD4	R0, [SP]
0C6C 0FF80001      1202			ENTER	1
0C70 3DD50004      1203			SUB	R13, 4
0C74 10DA0000      1204			ST4	[R13], R0
0C78 2FF0FE16      1205			BRA	NEXT
0C7C               1206	
0C7C 10D40000      1207	C_FROMR 	LD4	R0, [R13]
0C80 0FF8FFFF      1208			ENTER	-1
0C84 3DD40004      1209			ADD	R13, 4
0C88 10FA0000      1210			ST4	[SP], R0
0C8C 2FF0FE0C      1211			BRA	NEXT
0C90               1212	
0C90 0FF8FFFF      1213	C_RSPFETCH	ENTER	-1
0C94 1DFA0000      1214			ST4	[SP], R13
0C98 2FF0FE06      1215			BRA	NEXT
0C9C               1216	
0C9C 1DF40000      1217	C_RSPSTORE	LD4	R13, [SP]
0CA0 0FF80001      1218			ENTER	1
0CA4 2FF0FE00      1219			BRA	NEXT
0CA8               1220	
0CA8 3DD40004      1221	C_RDROP 	ADD	R13, 4
0CAC 2FF0FDFC      1222			BRA	NEXT
0CB0               1223	
0CB0               1224	
0CB0               1225	#	PARAMETER (DATA) STACK ----------------------------------------------------------------------
0CB0               1226	#	These functions allow you to manipulate the parameter stack.  Recall that Linux sets up the parameter
0CB0               1227	#	stack for us, and it is accessed through %esp.
0CB0               1228	
0CB0 90FF          1229	C_DSPFETCH	MV	R0, SP
0CB2 0FF8FFFF      1230			ENTER	-1
0CB6 10FA0000      1231			ST4	[SP], R0
0CBA 2FF0FDF5      1232			BRA	NEXT
0CBE               1233	
0CBE 1FF40000      1234	C_DSPSTORE	LD4	SP, [SP]
0CC2 2FF0FDF1      1235			BRA	NEXT
0CC6               1236	
0CC6               1237	#	INPUT AND OUTPUT ----------------------------------------------------------------------
0CC6               1238	
0CC6               1239	#	These are our first really meaty/complicated FORTH primitives.	I have chosen to write them in
0CC6               1240	#	assembler, but surprisingly in "real" FORTH implementations these are often written in terms
0CC6               1241	#	of more fundamental FORTH primitives.  I chose to avoid that because I think that just obscures
0CC6               1242	#	the implementation.  After all, you may not understand assembler but you can just think of it
0CC6               1243	#	as an opaque block of code that does what it says.
0CC6               1244	
0CC6               1245	#	Let's discuss input first.
0CC6               1246	
0CC6               1247	#	The FORTH word KEY reads the next byte from stdin (and pushes it on the parameter stack).
0CC6               1248	#	So if KEY is called and someone hits the space key, then the number 32 (ASCII code of space)
0CC6               1249	#	is pushed on the stack.
0CC6               1250	
0CC6               1251	#	In FORTH there is no distinction between reading code and reading input.  We might be reading
0CC6               1252	#	and compiling code, we might be reading words to execute, we might be asking for the user
0CC6               1253	#	to type their name -- ultimately it all comes in through KEY.
0CC6               1254	
0CC6               1255	#	The implementation of KEY uses an input buffer of a certain size (defined at the end of this
0CC6               1256	#	file).	It calls the Linux read(2) system call to fill this buffer and tracks its position
0CC6               1257	#	in the buffer using a couple of variables, and if it runs out of input buffer then it refills
0CC6               1258	#	it automatically.  The other thing that KEY does is if it detects that stdin has closed, it
0CC6               1259	#	exits the program, which is why when you hit ^D the FORTH system cleanly exits.
0CC6               1260	
0CC6               1261	#    buffer			      bufftop
0CC6               1262	#	|				 |
0CC6               1263	#	V				 V
0CC6               1264	#	+-------------------------------+--------------------------------------+
0CC6               1265	#	| INPUT READ FROM STDIN ....... | unused part of the buffer	       |
0CC6               1266	#	+-------------------------------+--------------------------------------+
0CC6               1267	#			  ^
0CC6               1268	#			  |
0CC6               1269	#		       currkey (next character to read)
0CC6               1270	
0CC6               1271	#	<---------------------- BUFFER_SIZE (4096 bytes) ---------------------->
0CC6               1272	
0CC6 0FFDFFFFFA22  1273	C_KEY		JAL	CONREADECHO
0CCC 0FF8FFFF      1274			ENTER	-1
0CD0 10FA0000      1275			ST4	[SP], R0
0CD4 2FF0FDE8      1276			BRA	NEXT
0CD8               1277	
0CD8               1278	#	By contrast, output is much simpler.  The FORTH word EMIT writes out a single byte to stdout.
0CD8               1279	#	This implementation just uses the write system call.  No attempt is made to buffer output, but
0CD8               1280	#	it would be a good exercise to add it.
0CD8               1281	
0CD8 10F40000      1282	C_EMIT		LD4	R0, [SP]
0CDC 0FF80001      1283			ENTER	1
0CE0 0FFDFFFFF9EC  1284			JAL	CONOUT
0CE6 2FF0FDDF      1285			BRA	NEXT
0CEA               1286	
0CEA               1287	#	Back to input, WORD is a FORTH word which reads the next full word of input.
0CEA               1288	
0CEA               1289	#	What it does in detail is that it first skips any blanks (spaces, tabs, newlines and so on).
0CEA               1290	#	Then it calls KEY to read characters into an internal buffer until it hits a blank.  Then it
0CEA               1291	#	calculates the length of the word it read and returns the address and the length as
0CEA               1292	#	two words on the stack (with the length at the top of stack).
0CEA               1293	
0CEA               1294	#	Notice that WORD has a single internal buffer which it overwrites each time (rather like
0CEA               1295	#	a static C string).  Also notice that WORD's internal buffer is just 32 bytes long and
0CEA               1296	#	there is NO checking for overflow.  31 bytes happens to be the maximum length of a
0CEA               1297	#	FORTH word that we support, and that is what WORD is used for: to read FORTH words when
0CEA               1298	#	we are compiling and executing code.  The returned strings are not NUL-terminated.
0CEA               1299	
0CEA               1300	#	Start address+length is the normal way to represent strings in FORTH (not ending in an
0CEA               1301	#	ASCII NUL character as in C), and so FORTH strings can contain any character including NULs
0CEA               1302	#	and can be any length.
0CEA               1303	
0CEA               1304	#	WORD is not suitable for just reading strings (eg. user input) because of all the above
0CEA               1305	#	peculiarities and limitations.
0CEA               1306	
0CEA               1307	#	Note that when executing, you'll see:
0CEA               1308	#	WORD FOO
0CEA               1309	#	which puts "FOO" and length 3 on the stack, but when compiling:
0CEA               1310	#	: BAR WORD FOO ;
0CEA               1311	#	is an error (or at least it doesn't do what you might expect).	Later we'll talk about compiling
0CEA               1312	#	and immediate mode, and you'll understand why.
0CEA 0FFD00000008  1313	C_WORD		JAL	WORD
0CF0 0FF8FFFE      1314			ENTER	-2
0CF4 10FA0002      1315			ST4	[SP + 2], R0	; base address
0CF8 11FA0000      1316			ST4	[SP], R1	; length
0CFC 2FF0FDD4      1317			BRA	NEXT
0D00               1318	
0D00 0FF8FFFF      1319	WORD		ENTER	-1
0D04 1EFA0000      1320			ST4	[SP], R14
0D08 1AFA0001      1321			ST4	[SP + 1], R10
0D0C               1322	
0D0C               1323	.READ		; search for first non-blank character.  Also skip \ comments
0D0C 0FFDFFFFF9FF  1324			JAL	CONREADECHO	; get next key, returned in R0
0D12 3105005C      1325			SUB	R1, R0, '\'
0D16 21F0001B      1326			BZ	R1, .COMMENT
0D1A 31F90020      1327			LI	R1, ' '
0D1E 2014FFF5      1328			BLE	R0, R1, .READ
0D22               1329	
0D22               1330			; search for the end of the word, storing chars as we go
0D22 3AF92014      1331			LI	R10, WORD_BUFFER
0D26 10A80000      1332	.STORE		ST1	[R10], R0
0D2A 3AA40001      1333			ADD	R10, 1
0D2E 0FFDFFFFF9EE  1334			JAL	CONREADECHO
0D34 31F90020      1335			LI	R1, ' '
0D38 2102FFF5      1336			BLT	R1, R0, .STORE
0D3C               1337	
0D3C               1338			; return result
0D3C 30F92014      1339			LI	R0, WORD_BUFFER
0D40 51A0          1340			SUB	R1, R10, R0
0D42 1AF40001      1341			LD4	R10, [SP + 1]
0D46 1EF40000      1342			LD4	R14, [SP]
0D4A 0FF80001      1343			ENTER	1
0D4E 0FE0          1344			RET
0D50               1345	
0D50               1346	.COMMENT	; skip comments to end of the current line
0D50 0FFDFFFFF9DD  1347			JAL	CONREADECHO
0D56 31F9000D      1348			LI	R1, CR
0D5A 2011FFF9      1349			BNE	R0, R1, .COMMENT
0D5E 2FF0FFD5      1350			BRA	.READ
0D62               1351	
0D62               1352	#	As well as reading in words we'll need to read in numbers and for that we are using a function
0D62               1353	#	called NUMBER.	This parses a numeric string such as one returned by WORD and pushes the
0D62               1354	#	number on the parameter stack.
0D62               1355	
0D62               1356	#	The function uses the variable BASE as the base (radix) for conversion, so for example if
0D62               1357	#	BASE is 2 then we expect a binary number.  Normally BASE is 10.
0D62               1358	
0D62               1359	#	If the word starts with a '-' character then the returned value is negative.
0D62               1360	
0D62               1361	#	If the string can't be parsed as a number (or contains characters outside the current BASE)
0D62               1362	#	then we need to return an error indication.  So NUMBER actually returns two items on the stack.
0D62               1363	#	At the top of stack we return the number of unconverted characters (ie. if 0 then all characters
0D62               1364	#	were converted, so there is no error).	Second from top of stack is the parsed number or a
0D62               1365	#	partial value if there was an error.
0D62               1366	
0D62 10F40002      1367	C_NUMBER	LD4	R0,[SP + 2]	; begin
0D66 11F40000      1368			LD4	R1,[SP] 	; len
0D6A 0FFD00000006  1369			JAL	NUMBER
0D70 10FA0002      1370			ST4	[SP + 2], R0	; parsed number
0D74 11FA0000      1371			ST4	[SP], R1	; number of unparsed characters (0 = no error)
0D78 2FF0FD96      1372			BRA	NEXT
0D7C               1373	
0D7C 83FF          1374	NUMBER: 	LI	R3, 0
0D7E 21F00039      1375			BZ	R1, .DONE
0D82               1376	
0D82 35F92010      1377			LI	R5, FORTH_BASE
0D86 15540000      1378			LD4	R5, [R5]
0D8A               1379	
0D8A 14000000      1380			LD1	R4, [R0]	; fetch first char
0D8E 36450024      1381			SUB	R6, R4, '$'	; hex prefix ?
0D92 26F10005      1382			BNZ	R6, .NOHEX
0D96 35F90010      1383			LI	R5, 16
0D9A 06F8          1384			LI	R6, 1
0D9C 2FF00004      1385			BRA	.CONSUME
0DA0 3645002D      1386	.NOHEX		SUB	R6, R4, '-'
0DA4 26F10009      1387			BNZ	R6, .CONTINUE	; non negative
0DA8 30040001      1388	.CONSUME	ADD	R0, 1
0DAC 31150001      1389			SUB	R1, 1
0DB0 21F10003      1390			BNZ	R1, .CONTINUE
0DB4 01F8          1391			LI	R1, 1		; only -
0DB6 2FF0001D      1392			BRA	.DONE
0DBA               1393	
0DBA               1394	.CONTINUE	; loop reading digits
0DBA 6335          1395			MUL	R3, R5		; R3 *= BASE
0DBC 14000000      1396			LD1	R4, [R0]
0DC0 30040001      1397			ADD	R0, 1
0DC4               1398	
0DC4               1399			; have a digit ?
0DC4 34450030      1400			SUB	R4, '0'
0DC8 24F30011      1401			BLTI	R4, SP, .DONEG
0DCC 32F9000A      1402			LI	R2, 10
0DD0 24220006      1403			BLT	R4, R2, .CHECK
0DD4 34450011      1404			SUB	R4, 17	; 17 == 'A' - '0'
0DD8 24F30009      1405			BLTI	R4, SP, .DONEG
0DDC 3444000A      1406			ADD	R4, 10
0DE0               1407	
0DE0               1408	.CHECK		; digit fits ?
0DE0 25440005      1409			BLE	R5, R4, .DONEG
0DE4               1410	
0DE4               1411			; add digit and loop
0DE4 4334          1412			ADD	R3, R4
0DE6 31150001      1413			SUB	R1, 1
0DEA 21F1FFE6      1414			BNZ	R1, .CONTINUE
0DEE               1415	
0DEE 26F10001      1416	.DONEG		BNZ	R6, .DONE
0DF2 53F3          1417			SUB	R3, SP, R3	; negate if '-'
0DF4               1418	
0DF4 90F3          1419	.DONE		MV	R0, R3
0DF6 0FE0          1420			RET
0DF8               1421	
0DF8               1422	#	DICTIONARY LOOK UPS ----------------------------------------------------------------------
0DF8               1423	#	We're building up to our prelude on how FORTH code is compiled, but first we need yet more infrastructure.
0DF8               1424	#	The FORTH word FIND takes a string (a word as parsed by WORD -- see above) and looks it up in the
0DF8               1425	#	dictionary.  What it actually returns is the address of the dictionary header, if it finds it,
0DF8               1426	#	or 0 if it didn't.
0DF8               1427	#	So if DOUBLE is defined in the dictionary, then WORD DOUBLE FIND returns the following pointer:
0DF8               1428	#   pointer to this
0DF8               1429	#	|
0DF8               1430	#	|
0DF8               1431	#	V
0DF8               1432	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0DF8               1433	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0DF8               1434	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0DF8               1435	
0DF8               1436	#	See also >CFA and >DFA.
0DF8               1437	#	FIND doesn't find dictionary entries which are flagged as HIDDEN.  See below for why.
0DF8               1438	
0DF8 10F40002      1439	C_FIND		LD4	R0,[SP + 2]	; begin
0DFC 11F40000      1440			LD4	R1,[SP] 	; len
0E00 0FF80001      1441			ENTER	1
0E04 0FFD00000004  1442			JAL	FIND
0E0A 10FA0000      1443			ST4	[SP], R0
0E0E 2FF0FD4B      1444			BRA	NEXT
0E12               1445	
0E12 32F9200C      1446	FIND		LI	R2, FORTH_LATEST
0E16 12240000      1447			LD4	R2, [R2]
0E1A 22F0001D      1448	.LOOP		BZ	R2, .DONE
0E1E 13200004      1449			LD1	R3, [R2 + 4]	; load len + flags
0E22 3338003F      1450			AND	R3, F_LENMASK | F_HIDDEN
0E26 21310013      1451			BNE	R1, R3, .NEXT
0E2A               1452	
0E2A               1453			# compare strings in detail
0E2A 34240005      1454			ADD	R4, R2, 5
0E2E 95F0          1455			MV	R5, R0
0E30 16400000      1456	.CMP		LD1	R6, [R4]
0E34 17500000      1457			LD1	R7, [R5]
0E38 2671000A      1458			BNE	R6, R7, .NEXT
0E3C 34440001      1459			ADD	R4, 1
0E40 35540001      1460			ADD	R5, 1
0E44 33350001      1461			SUB	R3, 1
0E48 23F1FFF2      1462			BNZ	R3, .CMP
0E4C               1463	
0E4C               1464			# found
0E4C 90F2          1465			MV	R0, R2
0E4E 0FE0          1466			RET
0E50               1467	
0E50 12240000      1468	.NEXT		LD4	R2, [R2]	; load previous
0E54 2FF0FFE1      1469			BRA	.LOOP
0E58               1470	
0E58 80FF          1471	.DONE		LI	R0, 0		; not found
0E5A 0FE0          1472			RET
0E5C               1473	
0E5C               1474	#	FIND returns the dictionary pointer, but when compiling we need the codeword pointer (recall
0E5C               1475	#	that FORTH definitions are compiled into lists of codeword pointers).  The standard FORTH
0E5C               1476	#	word >CFA turns a dictionary pointer into a codeword pointer.
0E5C               1477	#	The example below shows the result of:
0E5C               1478	#		WORD DOUBLE FIND >CFA
0E5C               1479	
0E5C               1480	#	FIND returns a pointer to this
0E5C               1481	#	|				>CFA converts it to a pointer to this
0E5C               1482	#	|					   |
0E5C               1483	#	V					   V
0E5C               1484	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0E5C               1485	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0E5C               1486	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0E5C               1487	#						   codeword
0E5C               1488	
0E5C               1489	#	Notes:
0E5C               1490	
0E5C               1491	#	Because names vary in length, this isn't just a simple increment.
0E5C               1492	
0E5C               1493	#	In this FORTH you cannot easily turn a codeword pointer back into a dictionary entry pointer, but
0E5C               1494	#	that is not true in most FORTH implementations where they store a back pointer in the definition
0E5C               1495	#	(with an obvious memory/complexity cost).  The reason they do this is that it is useful to be
0E5C               1496	#	able to go backwards (codeword -> dictionary entry) in order to decompile FORTH definitions
0E5C               1497	#	quickly.
0E5C               1498	
0E5C               1499	#	What does CFA stand for?  My best guess is "Code Field Address".
0E5C               1500	
0E5C 10F40000      1501	C_TCFA		LD4	R0, [SP]
0E60 0FFD00000004  1502			JAL	TCFA
0E66 10FA0000      1503			ST4	[SP], R0
0E6A 2FF0FD1D      1504			BRA	NEXT
0E6E               1505	
0E6E 30040004      1506	TCFA		ADD	R0, 4		; skip link pointer
0E72 11000000      1507			LD1	R1, [R0]	; load flags + len
0E76 3118001F      1508			AND	R1, F_LENMASK	; drop flags
0E7A 31140004      1509			ADD	R1, 4		; align to 4
0E7E 311800FC      1510			AND	R1, $fc
0E82 4001          1511			ADD	R0, R1
0E84 0FE0          1512			RET
0E86               1513	
0E86               1514	#	Related to >CFA is >DFA which takes a dictionary entry address as returned by FIND and
0E86               1515	#	returns a pointer to the first data field.
0E86               1516	#	FIND returns a pointer to this
0E86               1517	#	|				>CFA converts it to a pointer to this
0E86               1518	#	|					   |
0E86               1519	#	|					   |	>DFA converts it to a pointer to this
0E86               1520	#	|					   |		 |
0E86               1521	#	V					   V		 V
0E86               1522	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0E86               1523	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0E86               1524	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0E86               1525	#						   codeword
0E86               1526	#	(Note to those following the source of FIG-FORTH / ciforth: My >DFA definition is
0E86               1527	#	different from theirs, because they have an extra indirection).
0E86               1528	#	You can see that >DFA is easily defined in FORTH just by adding 4 to the result of >CFA.
0E86               1529	
0E86               1530	#	defword ">DFA",4,,TDFA
0E86               1531	#	.int TCFA		// >CFA 	(get code field address)
0E86               1532	#	.int INCR4		// 4+		(add 4 to it to get to next word)
0E86               1533	#	.int EXIT		// EXIT 	(return from FORTH word)
0E86               1534	
0E86               1535	#	COMPILING ----------------------------------------------------------------------
0E86               1536	#	Now we'll talk about how FORTH compiles words.	Recall that a word definition looks like this:
0E86               1537	#		: DOUBLE DUP + ;
0E86               1538	#	and we have to turn this into:
0E86               1539	#	  pointer to previous word
0E86               1540	#	   ^
0E86               1541	#	   |
0E86               1542	#	+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0E86               1543	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0E86               1544	#	+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
0E86               1545	#	   ^	   len			       pad  codeword	  |
0E86               1546	#	   |							  V
0E86               1547	#	  LATEST points here				points to codeword of DUP
0E86               1548	
0E86               1549	#	There are several problems to solve.  Where to put the new word?  How do we read words?  How
0E86               1550	#	do we define the words : (COLON) and ; (SEMICOLON)?
0E86               1551	
0E86               1552	#	FORTH solves this rather elegantly and as you might expect in a very low-level way which
0E86               1553	#	allows you to change how the compiler works on your own code.
0E86               1554	
0E86               1555	#	FORTH has an INTERPRET function (a true interpreter this time, not DOCOL) which runs in a
0E86               1556	#	loop, reading words (using WORD), looking them up (using FIND), turning them into codeword
0E86               1557	#	pointers (using >CFA) and deciding what to do with them.
0E86               1558	
0E86               1559	#	What it does depends on the mode of the interpreter (in variable STATE).
0E86               1560	
0E86               1561	#	When STATE is zero, the interpreter just runs each word as it looks them up.  This is known as
0E86               1562	#	immediate mode.
0E86               1563	
0E86               1564	#	The interesting stuff happens when STATE is non-zero -- compiling mode.  In this mode the
0E86               1565	#	interpreter appends the codeword pointer to user memory (the HERE variable points to the next
0E86               1566	#	free byte of user memory -- see DATA SEGMENT section below).
0E86               1567	
0E86               1568	#	So you may be able to see how we could define : (COLON).  The general plan is:
0E86               1569	
0E86               1570	#	(1) Use WORD to read the name of the function being defined.
0E86               1571	#	(2) Construct the dictionary entry -- just the header part -- in user memory:
0E86               1572	
0E86               1573	#   pointer to previous word (from LATEST)			+-- Afterwards, HERE points here, where
0E86               1574	#	   ^							|   the interpreter will start appending
0E86               1575	#	   |							V   codewords.
0E86               1576	#	+--|------+---+---+---+---+---+---+---+---+------------+
0E86               1577	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      |
0E86               1578	#	+---------+---+---+---+---+---+---+---+---+------------+
0E86               1579	#		   len			       pad  codeword
0E86               1580	
0E86               1581	#	(3) Set LATEST to point to the newly defined word, ...
0E86               1582	#	(4) .. and most importantly leave HERE pointing just after the new codeword.  This is where
0E86               1583	#	    the interpreter will append codewords.
0E86               1584	#	(5) Set STATE to 1.  This goes into compile mode so the interpreter starts appending codewords to
0E86               1585	#	    our partially-formed header.
0E86               1586	
0E86               1587	#	After : has run, our input is here:
0E86               1588	
0E86               1589	#	: DOUBLE DUP + ;
0E86               1590	#		 ^
0E86               1591	#		 |
0E86               1592	#		Next byte returned by KEY will be the 'D' character of DUP
0E86               1593	
0E86               1594	#	so the interpreter (now it's in compile mode, so I guess it's really the compiler) reads "DUP",
0E86               1595	#	looks it up in the dictionary, gets its codeword pointer, and appends it:
0E86               1596	
0E86               1597	#									     +-- HERE updated to point here.
0E86               1598	#									     |
0E86               1599	#									     V
0E86               1600	#	+---------+---+---+---+---+---+---+---+---+------------+------------+
0E86               1601	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    |
0E86               1602	#	+---------+---+---+---+---+---+---+---+---+------------+------------+
0E86               1603	#		   len			       pad  codeword
0E86               1604	
0E86               1605	#	Next we read +, get the codeword pointer, and append it:
0E86               1606	
0E86               1607	#											  +-- HERE updated to point here.
0E86               1608	#											  |
0E86               1609	#											  V
0E86               1610	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
0E86               1611	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 |
0E86               1612	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
0E86               1613	#		   len			       pad  codeword
0E86               1614	
0E86               1615	#	The issue is what happens next.  Obviously what we _don't_ want to happen is that we
0E86               1616	#	read ";" and compile it and go on compiling everything afterwards.
0E86               1617	
0E86               1618	#	At this point, FORTH uses a trick.  Remember the length byte in the dictionary definition
0E86               1619	#	isn't just a plain length byte, but can also contain flags.  One flag is called the
0E86               1620	#	IMMEDIATE flag (F_IMMED in this code).	If a word in the dictionary is flagged as
0E86               1621	#	IMMEDIATE then the interpreter runs it immediately _even if it's in compile mode_.
0E86               1622	
0E86               1623	#	This is how the word ; (SEMICOLON) works -- as a word flagged in the dictionary as IMMEDIATE.
0E86               1624	
0E86               1625	#	And all it does is append the codeword for EXIT on to the current definition and switch
0E86               1626	#	back to immediate mode (set STATE back to 0).  Shortly we'll see the actual definition
0E86               1627	#	of ; and we'll see that it's really a very simple definition, declared IMMEDIATE.
0E86               1628	
0E86               1629	#	After the interpreter reads ; and executes it 'immediately', we get this:
0E86               1630	
0E86               1631	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0E86               1632	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0E86               1633	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0E86               1634	#		   len			       pad  codeword					       ^
0E86               1635	#												       |
0E86               1636	#												      HERE
0E86               1637	#	STATE is set to 0.
0E86               1638	
0E86               1639	#	And that's it, job done, our new definition is compiled, and we're back in immediate mode
0E86               1640	#	just reading and executing words, perhaps including a call to test our new word DOUBLE.
0E86               1641	
0E86               1642	#	The only last wrinkle in this is that while our word was being compiled, it was in a
0E86               1643	#	half-finished state.  We certainly wouldn't want DOUBLE to be called somehow during
0E86               1644	#	this time.  There are several ways to stop this from happening, but in FORTH what we
0E86               1645	#	do is flag the word with the HIDDEN flag (F_HIDDEN in this code) just while it is
0E86               1646	#	being compiled.  This prevents FIND from finding it, and thus in theory stops any
0E86               1647	#	chance of it being called.
0E86               1648	
0E86               1649	#	The above explains how compiling, : (COLON) and ; (SEMICOLON) works and in a moment I'm
0E86               1650	#	going to define them.  The : (COLON) function can be made a little bit more general by writing
0E86               1651	#	it in two parts.  The first part, called CREATE, makes just the header:
0E86               1652	
0E86               1653	#						   +-- Afterwards, HERE points here.
0E86               1654	#						   |
0E86               1655	#						   V
0E86               1656	#	+---------+---+---+---+---+---+---+---+---+
0E86               1657	#	| LINK	  | 6 | D | O | U | B | L | E | 0 |
0E86               1658	#	+---------+---+---+---+---+---+---+---+---+
0E86               1659	#		   len			       pad
0E86               1660	
0E86               1661	#	and the second part, the actual definition of : (COLON), calls CREATE and appends the
0E86               1662	#	DOCOL codeword, so leaving:
0E86               1663	
0E86               1664	#								+-- Afterwards, HERE points here.
0E86               1665	#								|
0E86               1666	#								V
0E86               1667	#	+---------+---+---+---+---+---+---+---+---+------------+
0E86               1668	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      |
0E86               1669	#	+---------+---+---+---+---+---+---+---+---+------------+
0E86               1670	#		   len			       pad  codeword
0E86               1671	
0E86               1672	#	CREATE is a standard FORTH word and the advantage of this split is that we can reuse it to
0E86               1673	#	create other types of words (not just ones which contain code, but words which contain variables,
0E86               1674	#	constants and other data).
0E86               1675	
0E86 10F40002      1676	C_CREATE	LD4	R0, [SP + 2]
0E8A 11F40000      1677			LD4	R1, [SP]
0E8E 0FF80002      1678			ENTER	2
0E92 82FF          1679			LI	R2, 0
0E94 13240802      1680			LD4	R3, [R2 + FORTH_HERE / 4]
0E98 14240803      1681			LD4	R4, [R2 + FORTH_LATEST / 4]
0E9C 143A0000      1682			ST4	[R3], R4	; store link pointer
0EA0               1683	
0EA0               1684			# update LATEST
0EA0 132A0803      1685			ST4	[R2 + FORTH_LATEST / 4], R3
0EA4 33340004      1686			ADD	R3, 4
0EA8               1687	
0EA8               1688			# store length & flags
0EA8 11380000      1689			ST1	[R3], R1
0EAC               1690	
0EAC               1691			# store name
0EAC 14000000      1692	.COPY		LD1	R4, [R0]
0EB0 33340001      1693			ADD	R3, 1
0EB4 30040001      1694			ADD	R0, 1
0EB8 31150001      1695			SUB	R1, 1
0EBC 14380000      1696			ST1	[R3], R4
0EC0 21F1FFF4      1697			BNZ	R1, .COPY
0EC4               1698	
0EC4               1699			# align to 4
0EC4 33340004      1700			ADD	R3, 4
0EC8 3338FFFC      1701			AND	R3, -4	; #~3
0ECC               1702	
0ECC               1703			# update HERE
0ECC 132A0802      1704			ST4	[R2 + FORTH_HERE / 4], R3
0ED0 2FF0FCEA      1705			BRA	NEXT
0ED4               1706	
0ED4               1707	#	Because I want to define : (COLON) in FORTH, not assembler, we need a few more FORTH words
0ED4               1708	#	to use.
0ED4               1709	
0ED4               1710	#	The first is , (COMMA) which is a standard FORTH word which appends a 32 bit integer to the user
0ED4               1711	#	memory pointed to by HERE, and adds 4 to HERE.	So the action of , (COMMA) is:
0ED4               1712	
0ED4               1713	#							previous value of HERE
0ED4               1714	#								 |
0ED4               1715	#								 V
0ED4               1716	#	+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
0ED4               1717	#	| LINK	  | 6 | D | O | U | B | L | E | 0 |		|  <data>    |
0ED4               1718	#	+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
0ED4               1719	#		   len			       pad			      ^
0ED4               1720	#									      |
0ED4               1721	#									new value of HERE
0ED4               1722	
0ED4               1723	#	and <data> is whatever 32 bit integer was at the top of the stack.
0ED4               1724	
0ED4               1725	#	, (COMMA) is quite a fundamental operation when compiling.  It is used to append codewords
0ED4               1726	#	to the current word that is being compiled.
0ED4               1727	
0ED4 10F40000      1728	C_COMMA 	LD4	R0, [SP]
0ED8 0FF80001      1729			ENTER	1
0EDC 0FFD00000002  1730			JAL	COMMA
0EE2 2FF0FCE1      1731			BRA	NEXT
0EE6               1732	
0EE6 81FF          1733	COMMA:		LI	R1, 0
0EE8 12140802      1734			LD4	R2, [R1 + FORTH_HERE / 4]
0EEC 102A0000      1735			ST4	[R2], R0
0EF0 32240004      1736			ADD	R2, 4
0EF4 121A0802      1737			ST4	[R1 + FORTH_HERE / 4], R2
0EF8 0FE0          1738			RET
0EFA               1739	
0EFA               1740	#	Our definitions of : (COLON) and ; (SEMICOLON) will need to switch to and from compile mode.
0EFA               1741	#	Immediate mode vs. compile mode is stored in the global variable STATE, and by updating this
0EFA               1742	#	variable we can switch between the two modes.
0EFA               1743	
0EFA               1744	#	For various reasons which may become apparent later, FORTH defines two standard words called
0EFA               1745	#	[ and ] (LBRAC and RBRAC) which switch between modes:
0EFA               1746	
0EFA               1747	#	Word	Assembler	Action		Effect
0EFA               1748	#	[	LBRAC		STATE := 0	Switch to immediate mode.
0EFA               1749	#	]	RBRAC		STATE := 1	Switch to compile mode.
0EFA               1750	
0EFA               1751	#	[ (LBRAC) is an IMMEDIATE word.  The reason is as follows: If we are in compile mode and the
0EFA               1752	#	interpreter saw [ then it would compile it rather than running it.  We would never be able to
0EFA               1753	#	switch back to immediate mode!	So we flag the word as IMMEDIATE so that even in compile mode
0EFA               1754	#	the word runs immediately, switching us back to immediate mode.
0EFA               1755	
0EFA 80FF          1756	C_LBRAC 	LI	R0, 0
0EFC 100A0801      1757			ST4	[R0 + FORTH_STATE / 4], R0
0F00 2FF0FCD2      1758			BRA	NEXT
0F04               1759	
0F04 80FF          1760	C_RBRAC 	LI	R0, 0
0F06 01F8          1761			LI	R1, 1
0F08 110A0801      1762			ST4	[R0 + FORTH_STATE / 4], R1
0F0C 2FF0FCCC      1763			BRA	NEXT
0F10               1764	
0F10               1765	#	Now we can define : (COLON) using CREATE.  It just calls CREATE, appends DOCOL (the codeword), sets
0F10               1766	#	the word HIDDEN and goes into compile mode.
0F10               1767	
0F10               1768	#	defword ":",1,,COLON
0F10               1769	#	.int WORD		// Get the name of the new word
0F10               1770	#	.int CREATE		// CREATE the dictionary entry / header
0F10               1771	#	.int LIT, DOCOL, COMMA	// Append DOCOL  (the codeword).
0F10               1772	#	.int LATEST, FETCH, HIDDEN // Make the word hidden (see below for definition).
0F10               1773	#	.int RBRAC		// Go into compile mode.
0F10               1774	#	.int EXIT		// Return from the function.
0F10               1775	
0F10               1776	# (SEMICOLON) is also elegantly simple.  Notice the F_IMMED flag.
0F10               1777	
0F10               1778	#	defword ";",1,F_IMMED,SEMICOLON
0F10               1779	#	.int LIT, EXIT, COMMA	// Append EXIT (so the word will return).
0F10               1780	#	.int LATEST, FETCH, HIDDEN // Toggle hidden flag -- unhide the word (see below for definition).
0F10               1781	#	.int LBRAC		// Go back to IMMEDIATE mode.
0F10               1782	#	.int EXIT		// Return from the function.
0F10               1783	
0F10               1784	#	EXTENDING THE COMPILER ----------------------------------------------------------------------
0F10               1785	
0F10               1786	#	Words flagged with IMMEDIATE (F_IMMED) aren't just for the FORTH compiler to use.  You can define
0F10               1787	#	your own IMMEDIATE words too, and this is a crucial aspect when extending basic FORTH, because
0F10               1788	#	it allows you in effect to extend the compiler itself.	Does gcc let you do that?
0F10               1789	
0F10               1790	#	Standard FORTH words like IF, WHILE, ." and so on are all written as extensions to the basic
0F10               1791	#	compiler, and are all IMMEDIATE words.
0F10               1792	
0F10               1793	#	The IMMEDIATE word toggles the F_IMMED (IMMEDIATE flag) on the most recently defined word,
0F10               1794	#	or on the current word if you call it in the middle of a definition.
0F10               1795	
0F10               1796	#	Typical usage is:
0F10               1797	#	: MYIMMEDWORD IMMEDIATE
0F10               1798	#		...definition...
0F10               1799	#	;
0F10               1800	
0F10               1801	#	but some FORTH programmers write this instead:
0F10               1802	#	: MYIMMEDWORD
0F10               1803	#		...definition...
0F10               1804	#	; IMMEDIATE
0F10               1805	
0F10               1806	#	The two usages are equivalent, to a first approximation.
0F10               1807	
0F10 80FF          1808	C_IMMEDIATE	LI	R0, 0
0F12 1104200C      1809			LD4	R1, [R0 + FORTH_LATEST]
0F16 12100004      1810			LD1	R2, [R1 + 4]
0F1A 322A0080      1811			XOR	R2, F_IMMED
0F1E 12180004      1812			ST1	[R1 + 4], R2
0F22 2FF0FCC1      1813			BRA	NEXT
0F26               1814	
0F26               1815	#	'addr HIDDEN' toggles the hidden flag (F_HIDDEN) of the word defined at addr.  To hide the
0F26               1816	#	most recently defined word (used above in : and ; definitions) you would do:
0F26               1817	#		LATEST @ HIDDEN
0F26               1818	
0F26               1819	#	'HIDE word' toggles the flag on a named 'word'.
0F26               1820	
0F26               1821	#	Setting this flag stops the word from being found by FIND, and so can be used to make 'private'
0F26               1822	#	words.	For example, to break up a large word into smaller parts you might do:
0F26               1823	#		: SUB1 ... subword ... ;
0F26               1824	#		: SUB2 ... subword ... ;
0F26               1825	#		: SUB3 ... subword ... ;
0F26               1826	#		: MAIN ... defined in terms of SUB1, SUB2, SUB3 ... ;
0F26               1827	#		HIDE SUB1
0F26               1828	#		HIDE SUB2
0F26               1829	#		HIDE SUB3
0F26               1830	
0F26               1831	#	After this, only MAIN is 'exported' or seen by the rest of the program.
0F26               1832	
0F26 10F40000      1833	C_HIDDEN	LD4	R0, [SP]
0F2A 0FF80001      1834			ENTER	1
0F2E 11000004      1835			LD1	R1, [R0 + 4]
0F32 311A0020      1836			XOR	R1, F_HIDDEN
0F36 11080004      1837			ST1	[R0 + 4], R1
0F3A 2FF0FCB5      1838			BRA	NEXT
0F3E               1839	
0F3E               1840	#	defword "HIDE",4,,HIDE
0F3E               1841	#	.int WORD		// Get the word (after HIDE).
0F3E               1842	#	.int FIND		// Look up in the dictionary.
0F3E               1843	#	.int HIDDEN		// Set F_HIDDEN flag.
0F3E               1844	#	.int EXIT		// Return.
0F3E               1845	
0F3E               1846	#	' (TICK) is a standard FORTH word which returns the codeword pointer of the next word.
0F3E               1847	#	The common usage is:
0F3E               1848	#	' FOO ,
0F3E               1849	
0F3E               1850	#	which appends the codeword of FOO to the current word we are defining (this only works in compiled code).
0F3E               1851	#	You tend to use ' in IMMEDIATE words.  For example an alternate (and rather useless) way to define
0F3E               1852	#	a literal 2 might be:
0F3E               1853	
0F3E               1854	#	: LIT2 IMMEDIATE
0F3E               1855	#		' LIT , 	\ Appends LIT to the currently-being-defined word
0F3E               1856	#		2 ,		\ Appends the number 2 to the currently-being-defined word
0F3E               1857	#	;
0F3E               1858	
0F3E               1859	#	So you could do:
0F3E               1860	
0F3E               1861	#	: DOUBLE LIT2 * ;
0F3E               1862	
0F3E               1863	#	(If you don't understand how LIT2 works, then you should review the material about compiling words
0F3E               1864	#	and immediate mode).
0F3E               1865	
0F3E               1866	#	This definition of ' uses a cheat which I copied from buzzard92.  As a result it only works in
0F3E               1867	#	compiled code.	It is possible to write a version of ' based on WORD, FIND, >CFA which works in
0F3E               1868	#	immediate mode too.
0F3E 10C40000      1869	C_TICK		LD4	R0, [R12]
0F42 0FF8FFFF      1870			ENTER	-1
0F46 3CC40004      1871			ADD	R12, 4
0F4A 10FA0000      1872			ST4	[SP], R0
0F4E 2FF0FCAB      1873			BRA	NEXT
0F52               1874	
0F52               1875	#	BRANCHING ----------------------------------------------------------------------
0F52               1876	
0F52               1877	#	It turns out that all you need in order to define looping constructs, IF-statements, etc.
0F52               1878	#	are two primitives.
0F52               1879	
0F52               1880	#	BRANCH is an unconditional branch. 0BRANCH is a conditional branch (it only branches if the
0F52               1881	#	top of stack is zero).
0F52               1882	
0F52               1883	#	The diagram below shows how BRANCH works in some imaginary compiled word.  When BRANCH executes,
0F52               1884	#	%esi starts by pointing to the offset field (compare to LIT above):
0F52               1885	
0F52               1886	#	+---------------------+-------+---- - - ---+------------+------------+---- - - - ----+------------+
0F52               1887	#	| (Dictionary header) | DOCOL | 	   | BRANCH	| offset     | (skipped)     | word	  |
0F52               1888	#	+---------------------+-------+---- - - ---+------------+-----|------+---- - - - ----+------------+
0F52               1889	#								   ^  | 		      ^
0F52               1890	#								   |  | 		      |
0F52               1891	#								   |  +-----------------------+
0F52               1892	#								  %esi added to offset
0F52               1893	
0F52               1894	#	The offset is added to %esi to make the new %esi, and the result is that when NEXT runs, execution
0F52               1895	#	continues at the branch target.  Negative offsets work as expected.
0F52               1896	
0F52               1897	#	0BRANCH is the same except the branch happens conditionally.
0F52               1898	
0F52               1899	#	Now standard FORTH words such as IF, THEN, ELSE, WHILE, REPEAT, etc. can be implemented entirely
0F52               1900	#	in FORTH.  They are IMMEDIATE words which append various combinations of BRANCH or 0BRANCH
0F52               1901	#	into the word currently being compiled.
0F52               1902	
0F52               1903	#	As an example, code written like this:
0F52               1904	
0F52               1905	#		condition-code IF true-part THEN rest-code
0F52               1906	
0F52               1907	#	compiles to:
0F52               1908	
0F52               1909	#		condition-code 0BRANCH OFFSET true-part rest-code
0F52               1910	#					  |		^
0F52               1911	#					  |		|
0F52               1912	#					  +-------------+
0F52 10C40000      1913	C_BRANCH	LD4	R0, [R12]
0F56 4CC0          1914			ADD	R12, R0
0F58 2FF0FCA6      1915			BRA	NEXT
0F5C               1916	
0F5C 10F40000      1917	C_ZBRANCH	LD4	R0, [SP]
0F60 0FF80001      1918			ENTER	1
0F64 20F0FFF5      1919			BZ	R0, C_BRANCH	; branch if zero
0F68 3CC40004      1920			ADD	R12, 4		; skip offset
0F6C 2FF0FC9C      1921			BRA	NEXT
0F70               1922	
0F70               1923	#	LITERAL STRINGS ----------------------------------------------------------------------
0F70               1924	
0F70               1925	#	LITSTRING is a primitive used to implement the ." and S" operators (which are written in
0F70               1926	#	FORTH).  See the definition of those operators later.
0F70               1927	
0F70               1928	#	TELL just prints a string.  It's more efficient to define this in assembly because we
0F70               1929	#	can make it a single Linux syscall.
0F70               1930	
0F70 10C40000      1931	C_LITSTRING	LD4	R0, [R12]
0F74 0FF8FFFE      1932			ENTER	-2
0F78 3CC40004      1933			ADD	R12, 4
0F7C 1CFAFFFE      1934			ST4	[SP - 2], R12	; push string start addr
0F80 10FA0000      1935			ST4	[SP], R0	; push len
0F84 4CC0          1936			ADD	R12, R0 	; skip past the string
0F86 3CC40003      1937			ADD	R12, 3
0F8A 3CC8FFFC      1938			AND	R12, -4 	; align to 4
0F8E 2FF0FC8B      1939			BRA	NEXT
0F92               1940	
0F92 13F40002      1941	C_TELL		LD4	R3, [SP + 2]	; string addr
0F96 14F40000      1942			LD4	R4, [SP]	; len
0F9A 24F0FC85      1943	.LOOP		BZ	R4, NEXT
0F9E 10300000      1944			LD1	R0, [R3]
0FA2 33340001      1945			ADD	R3, 1
0FA6 0FFDFFFFF889  1946			JAL	CONOUT
0FAC 34450001      1947			SUB	R4, 1
0FB0 2FF0FFF3      1948			BRA	.LOOP
0FB4               1949	
0FB4               1950	
0FB4               1951	#	CHAR puts the ASCII code of the first character of the following word on the stack.  For example
0FB4               1952	#	CHAR A puts 65 on the stack.
0FB4               1953	
0FB4               1954	#	EXECUTE is used to run execution tokens.  See the discussion of execution tokens in the
0FB4               1955	#	FORTH code for more details.
0FB4 0FFDFFFFFEA3  1956	C_CHAR		JAL	WORD	; R0 = word addr, R1 = len
0FBA 0FF8FFFF      1957			ENTER	-1
0FBE 10000000      1958			LD1	R0, [R0]
0FC2 10FA0000      1959			ST4	[SP], R0
0FC6 2FF0FC6F      1960			BRA	NEXT
0FCA               1961	
0FCA 10F40000      1962	C_EXECUTE	LD4	R0, [SP]
0FCE 0FF80001      1963			ENTER	1
0FD2 10040000      1964			LD4	R0, [R0]
0FD6 0F00          1965			JMP	R0
0FD8               1966	
0FD8               1967	#	QUIT AND INTERPRET ----------------------------------------------------------------------
0FD8               1968	
0FD8               1969	#	QUIT is the first FORTH function called, almost immediately after the FORTH system "boots".
0FD8               1970	#	As explained before, QUIT doesn't "quit" anything.  It does some initialisation (in particular
0FD8               1971	#	it clears the return stack) and it calls INTERPRET in a loop to interpret commands.  The
0FD8               1972	#	reason it is called QUIT is because you can call it from your own FORTH words in order to
0FD8               1973	#	"quit" your program and start again at the user prompt.
0FD8               1974	
0FD8               1975	#	INTERPRET is the FORTH interpreter ("toploop", "toplevel" or "REPL" might be a more accurate
0FD8               1976	#	description -- see: http://en.wikipedia.org/wiki/REPL).
0FD8               1977	
0FD8               1978	#	defword "QUIT",4,,QUIT
0FD8               1979	#	.int RZ,RSPSTORE	// R0 RSP!, clear the return stack
0FD8               1980	#	.int INTERPRET		// interpret the next word
0FD8               1981	#	.int BRANCH,-8		// and loop (indefinitely)
0FD8               1982	
0FD8               1983	#	This interpreter is pretty simple, but remember that in FORTH you can always override
0FD8               1984	#	it later with a more powerful one!
0FD8 0FFDFFFFFE91  1985	C_INTERPRET	JAL	WORD		; R0 = addr, R1 = len
0FDE 8AFF          1986			LI	R10, 0		; literal flag
0FE0 9BF0          1987			MV	R11, R0 	; save R0
0FE2 0FFDFFFFFF15  1988			JAL	FIND
0FE8 20F0000C      1989			BZ	R0, .NOTFOUND
0FEC 92F0          1990			MV	R2, R0
0FEE 13200004      1991			LD1	R3, [R2 + 4]	; get len + flags
0FF2 0FFDFFFFFF3B  1992			JAL	TCFA		; get codeword
0FF8 33380080      1993			AND	R3, F_IMMED
0FFC 23F1001D      1994			BNZ	R3, .DOEXEC
1000 2FF0000A      1995			BRA	.CHOICE
1004               1996	
1004               1997	.NOTFOUND	; not a word, assume a literal
1004 0AF8          1998			LI	R10, 1
1006 90FB          1999			MV	R0, R11
1008 0FFDFFFFFEB7  2000			JAL	NUMBER
100E 21F1001F      2001			BNZ	R1, .ERROR
1012 93F0          2002			MV	R3, R0
1014 30F91208      2003			LI	R0, B_LIT
1018               2004	
1018               2005	.CHOICE 	; codeword in R0: compiling or executing ?
1018 31F92004      2006			LI	R1, FORTH_STATE
101C 11140000      2007			LD4	R1, [R1]
1020 21F0000B      2008			BZ	R1, .DOEXEC
1024               2009	
1024               2010			; compiling: just append the word
1024 0FFDFFFFFF5E  2011			JAL	COMMA
102A 2AF00004      2012			BZ	R10, .NOLIT
102E 90F3          2013			MV	R0, R3
1030 0FFDFFFFFF58  2014			JAL	COMMA
1036 2FF0FC37      2015	.NOLIT		BRA	NEXT
103A               2016	
103A               2017	.DOEXEC 	; executing: run it
103A 2AF10003      2018			BNZ	R10, .ISLIT
103E 11040000      2019			LD4	R1, [R0]
1042 0F10          2020			JMP	R1
1044 0FF8FFFF      2021	.ISLIT		ENTER	-1
1048 13FA0000      2022			ST4	[SP], R3
104C 2FF0FC2C      2023			BRA	NEXT
1050               2024	
1050               2025	.ERROR		; parser error
1050 30F91C8C      2026			LI	R0, PARSER_ERROR
1054 0FFDFFFFF839  2027			JAL	CONSTR
105A 2FF0FC25      2028			BRA	NEXT
####################### dict.asm
105E                  1	#
105E                  2	# jforth builtin dictionary
105E                  3	#
105E 0000             4			.ALIGN	4
1060                  5	
1060 00000000         6	F_DROP		.LONG	0	; link to previous
1064 04               7			.BYTE	4	; flags + namelen
1065 44524F50         8			.BYTE	"DROP"
1069 000000           9			.ALIGN	4
106C 000008B8        10	B_DROP		.LONG	C_DROP
1070                 11	
1070 00001060        12	F_ILLEGAL	.LONG	F_DROP
1074 07              13			.BYTE	7
1075 494C4C454741    14			.BYTE	"ILLEGAL"
107B 4C          
107C                 15			.ALIGN	4
107C 000008B6        16			.LONG	C_ILLEGAL
1080                 17	
1080 00001070        18	F_SWAP		.LONG	F_ILLEGAL
1084 04              19			.BYTE	4	; flags + namelen
1085 53574150        20			.BYTE	"SWAP"
1089 000000          21			.ALIGN	4
108C 000008C0        22	B_SWAP		.LONG	C_SWAP
1090                 23	
1090 00001080        24	F_DUP		.LONG	F_SWAP	; link to previous
1094 03              25			.BYTE	3	; flags + namelen
1095 445550          26			.BYTE	"DUP"
1098                 27			.ALIGN	4
1098 000008D4        28	B_DUP		.LONG	C_DUP
109C                 29	
109C 00001090        30	F_OVER		.LONG	F_DUP	; link to previous
10A0 04              31			.BYTE	4	; flags + namelen
10A1 4F564552        32			.BYTE	"OVER"
10A5 000000          33			.ALIGN	4
10A8 000008E4        34			.LONG	C_OVER
10AC                 35	
10AC 0000109C        36	F_ROT		.LONG	F_OVER	; link to previous
10B0 03              37			.BYTE	3	; flags + namelen
10B1 524F54          38			.BYTE	"ROT"
10B4                 39			.ALIGN	4
10B4 000008F4        40	B_ROT		.LONG	C_ROT
10B8                 41	
10B8 000010AC        42	F_NROT		.LONG	F_ROT	; link to previous
10BC 04              43			.BYTE	4	; flags + namelen
10BD 2D524F54        44			.BYTE	"-ROT"
10C1 000000          45			.ALIGN	4
10C4 00000910        46			.LONG	C_NROT
10C8                 47	
10C8 000010B8        48	F_QDUP		.LONG	F_NROT	; link to previous
10CC 04              49			.BYTE	4	; flags + namelen
10CD 3F445550        50			.BYTE	"?DUP"
10D1 000000          51			.ALIGN	4
10D4 0000092C        52	B_QDUP		.LONG	C_QDUP
10D8                 53	
10D8 000010C8        54	F_INCR		.LONG	F_QDUP	; link to previous
10DC 02              55			.BYTE	2	; flags + namelen
10DD 312B            56			.BYTE	"1+"
10DF 00              57			.ALIGN	4
10E0 00000940        58	B_INCR		.LONG	C_INCR
10E4                 59	
10E4 000010D8        60	F_DECR		.LONG	F_INCR	; link to previous
10E8 02              61			.BYTE	2	; flags + namelen
10E9 312D            62			.BYTE	"1-"
10EB 00              63			.ALIGN	4
10EC 00000950        64	B_DECR		.LONG	C_DECR
10F0                 65	
10F0 000010E4        66	F_INCR4 	.LONG	F_DECR	; link to previous
10F4 02              67			.BYTE	2	; flags + namelen
10F5 342B            68			.BYTE	"4+"
10F7 00              69			.ALIGN	4
10F8 00000960        70	B_INCR4 	.LONG	C_INCR4
10FC                 71	
10FC 000010F0        72	F_DECR4 	.LONG	F_INCR4 ; link to previous
1100 02              73			.BYTE	2	; flags + namelen
1101 342D            74			.BYTE	"4-"
1103 00              75			.ALIGN	4
1104 00000970        76			.LONG	C_DECR4
1108                 77	
1108 000010FC        78	F_ADD		.LONG	F_DECR4 ; link to previous
110C 01              79			.BYTE	1	; flags + namelen
110D 2B              80			.BYTE	"+"
110E 0000            81			.ALIGN	4
1110 00000980        82	B_ADD		.LONG	C_ADD
1114                 83	
1114 00001108        84	F_SUB		.LONG	F_ADD	; link to previous
1118 01              85			.BYTE	1	; flags + namelen
1119 2D              86			.BYTE	"-"
111A 0000            87			.ALIGN	4
111C 00000996        88	B_SUB		.LONG	C_SUB
1120                 89	
1120 00001114        90	F_CRC32 	.LONG	F_SUB
1124 05              91			.BYTE	5
1125 4352433332      92			.BYTE	"CRC32"
112A 0000            93			.ALIGN	4
112C 000009AC        94			.LONG	C_CRC32
1130                 95	
1130 00001120        96	F_MUL		.LONG	F_CRC32
1134 01              97			.BYTE	1
1135 2A              98			.BYTE	"*"
1136 0000            99			.ALIGN	4
1138 000009C6       100	B_MUL		.LONG	C_MUL
113C                101	
113C 00001130       102	F_EQU		.LONG	F_MUL	; link to previous
1140 01             103			.BYTE	1	; flags + namelen
1141 3D             104			.BYTE	"="
1142 0000           105			.ALIGN	4
1144 000009F6       106			.LONG	C_EQU
1148                107	
1148 0000113C       108	F_NEQU		.LONG	F_EQU	; link to previous
114C 02             109			.BYTE	2	; flags + namelen
114D 3C3E           110			.BYTE	"<>"
114F 00             111			.ALIGN	4
1150 00000A0E       112			.LONG	C_NEQU
1154                113	
1154 00001148       114	F_LT		.LONG	F_NEQU	; link to previous
1158 01             115			.BYTE	1	; flags + namelen
1159 3C             116			.BYTE	"<"
115A 0000           117			.ALIGN	4
115C 00000A26       118	B_LT		.LONG	C_LT
1160                119	
1160 00001154       120	F_GT		.LONG	F_LT	; link to previous
1164 01             121			.BYTE	1	; flags + namelen
1165 3E             122			.BYTE	">"
1166 0000           123			.ALIGN	4
1168 00000A3E       124			.LONG	C_GT
116C                125	
116C 00001160       126	F_LE		.LONG	F_GT	; link to previous
1170 02             127			.BYTE	2	; flags + namelen
1171 3C3D           128			.BYTE	"<="
1173 00             129			.ALIGN	4
1174 00000A56       130			.LONG	C_LE
1178                131	
1178 0000116C       132	F_GE		.LONG	F_LE	; link to previous
117C 02             133			.BYTE	2	; flags + namelen
117D 3E3D           134			.BYTE	">="
117F 00             135			.ALIGN	4
1180 00000A6E       136			.LONG	C_GE
1184                137	
1184 00001178       138	F_ZEQU		.LONG	F_GE	; link to previous
1188 02             139			.BYTE	2	; flags + namelen
1189 303D           140			.BYTE	"0="
118B 00             141			.ALIGN	4
118C 00000A86       142	B_ZEQU		.LONG	C_ZEQU
1190                143	
1190 00001184       144	F_ZNEQU 	.LONG	F_ZEQU	; link to previous
1194 03             145			.BYTE	3	; flags + namelen
1195 303C3E         146			.BYTE	"0<>"
1198                147			.ALIGN	4
1198 00000A94       148			.LONG	C_ZNEQU
119C                149	
119C 00001190       150	F_ZLT		.LONG	F_ZNEQU ; link to previous
11A0 02             151			.BYTE	2	; flags + namelen
11A1 303C           152			.BYTE	"0<"
11A3 00             153			.ALIGN	4
11A4 00000AA2       154	B_ZLT		.LONG	C_ZLT
11A8                155	
11A8 0000119C       156	F_ZGT		.LONG	F_ZLT	; link to previous
11AC 02             157			.BYTE	2	; flags + namelen
11AD 303E           158			.BYTE	"0>"
11AF 00             159			.ALIGN	4
11B0 00000AB0       160	B_ZGT		.LONG	C_ZGT
11B4                161	
11B4 000011A8       162	F_ZLE		.LONG	F_ZGT	; link to previous
11B8 03             163			.BYTE	3	; flags + namelen
11B9 303C3D         164			.BYTE	"0<="
11BC                165			.ALIGN	4
11BC 00000ABE       166			.LONG	C_ZLE
11C0                167	
11C0 000011B4       168	F_ZGE		.LONG	F_ZLE	; link to previous
11C4 03             169			.BYTE	3	; flags + namelen
11C5 303E3D         170			.BYTE	"0>="
11C8                171			.ALIGN	4
11C8 00000ACC       172			.LONG	C_ZGE
11CC                173	
11CC 000011C0       174	F_AND		.LONG	F_ZGE	; link to previous
11D0 03             175			.BYTE	3	; flags + namelen
11D1 414E44         176			.BYTE	"AND"
11D4                177			.ALIGN	4
11D4 00000ADA       178			.LONG	C_AND
11D8                179	
11D8 000011CC       180	F_OR		.LONG	F_AND	; link to previous
11DC 02             181			.BYTE	2	; flags + namelen
11DD 4F52           182			.BYTE	"OR"
11DF 00             183			.ALIGN	4
11E0 00000AF0       184			.LONG	C_OR
11E4                185	
11E4 000011D8       186	F_XOR		.LONG	F_OR	; link to previous
11E8 03             187			.BYTE	3	; flags + namelen
11E9 584F52         188			.BYTE	"XOR"
11EC                189			.ALIGN	4
11EC 00000B06       190			.LONG	C_XOR
11F0                191	
11F0 000011E4       192	F_EXIT		.LONG	F_XOR	; link to previous
11F4 04             193			.BYTE	4	; flags + namelen
11F5 45584954       194			.BYTE	"EXIT"
11F9 000000         195			.ALIGN	4
11FC 00000B1C       196	B_EXIT		.LONG	C_EXIT
1200                197	
1200 000011F0       198	F_LIT		.LONG	F_EXIT	; link to previous
1204 03             199			.BYTE	3	; flags + namelen
1205 4C4954         200			.BYTE	"LIT"
1208                201			.ALIGN	4
1208 00000B28       202	B_LIT		.LONG	C_LIT
120C                203	
120C 00001200       204	F_STORE 	.LONG	F_LIT	; link to previous
1210 01             205			.BYTE	1	; flags + namelen
1211 21             206			.BYTE	"!"
1212 0000           207			.ALIGN	4
1214 00000B3C       208	B_STORE 	.LONG	C_STORE
1218                209	
1218 0000120C       210	F_FETCH 	.LONG	F_STORE ; link to previous
121C 01             211			.BYTE	1	; flags + namelen
121D 40             212			.BYTE	"@"
121E 0000           213			.ALIGN	4
1220 00000B50       214	B_FETCH 	.LONG	C_FETCH
1224                215	
1224 00001218       216	F_ADDSTORE	.LONG	F_FETCH ; link to previous
1228 02             217			.BYTE	2	; flags + namelen
1229 2B21           218			.BYTE	"+!"
122B 00             219			.ALIGN	4
122C 00000B60       220	B_ADDSTORE	.LONG	C_ADDSTORE
1230                221	
1230 00001224       222	F_SUBSTORE	.LONG	F_ADDSTORE
1234 02             223			.BYTE	2	; flags + namelen
1235 2D21           224			.BYTE	"-!"
1237 00             225			.ALIGN	4
1238 00000B7A       226			.LONG	C_SUBSTORE
123C                227	
123C 00001230       228	F_STOREBYTE	.LONG	F_SUBSTORE
1240 02             229			.BYTE	2	; flags + namelen
1241 4321           230			.BYTE	"C!"
1243 00             231			.ALIGN	4
1244 00000B94       232			.LONG	C_STOREBYTE
1248                233	
1248 0000123C       234	F_FETCHBYTE	.LONG	F_STOREBYTE
124C 02             235			.BYTE	2	; flags + namelen
124D 4340           236			.BYTE	"C@"
124F 00             237			.ALIGN	4
1250 00000BA8       238			.LONG	C_FETCHBYTE
1254                239	
1254 00001248       240	F_STATE 	.LONG	F_FETCHBYTE
1258 05             241			.BYTE	5	; flags + namelen
1259 5354415445     242			.BYTE	"STATE"
125E 0000           243			.ALIGN	4
1260 00000BB8       244			.LONG	C_STATE
1264                245	
1264 00001254       246	F_HERE		.LONG	F_STATE
1268 04             247			.BYTE	4	; flags + namelen
1269 48455245       248			.BYTE	"HERE"
126D 000000         249			.ALIGN	4
1270 00000BC8       250	B_HERE		.LONG	C_HERE
1274                251	
1274 00001264       252	F_LATEST	.LONG	F_HERE
1278 06             253			.BYTE	6	; flags + namelen
1279 4C4154455354   254			.BYTE	"LATEST"
127F 00             255			.ALIGN	4
1280 00000BD8       256	B_LATEST	.LONG	C_LATEST
1284                257	
1284 00001274       258	F_S0		.LONG	F_LATEST
1288 02             259			.BYTE	2	; flags + namelen
1289 5330           260			.BYTE	"S0"
128B 00             261			.ALIGN	4
128C 00000BE8       262	B_S0		.LONG	C_S0
1290                263	
1290 00001284       264	F_BASE		.LONG	F_S0
1294 04             265			.BYTE	4	; flags + namelen
1295 42415345       266			.BYTE	"BASE"
1299 000000         267			.ALIGN	4
129C 00000BF8       268	B_BASE		.LONG	C_BASE
12A0                269	
12A0 00001290       270	F_VERSION	.LONG	F_BASE
12A4 07             271			.BYTE	7	; flags + namelen
12A5 56455253494F   272			.BYTE	"VERSION"
12AB 4E          
12AC                273			.ALIGN	4
12AC 00000C08       274			.LONG	C_VERSION
12B0                275	
12B0 000012A0       276	F_R0		.LONG	F_VERSION
12B4 02             277			.BYTE	2	; flags + namelen
12B5 5230           278			.BYTE	"R0"
12B7 00             279			.ALIGN	4
12B8 00000C18       280	B_R0		.LONG	C_R0
12BC                281	
12BC 000012B0       282	F_DOCOL 	.LONG	F_R0
12C0 05             283			.BYTE	5	; flags + namelen
12C1 444F434F4C     284			.BYTE	"DOCOL"
12C6 0000           285			.ALIGN	4
12C8 00000C28       286			.LONG	C_DOCOL
12CC                287	
12CC 000012BC       288	F_F_IMMED	.LONG	F_DOCOL
12D0 07             289			.BYTE	7	; flags + namelen
12D1 465F494D4D45   290			.BYTE	"F_IMMED"
12D7 44          
12D8                291			.ALIGN	4
12D8 00000C38       292			.LONG	C_F_IMMED
12DC                293	
12DC 000012CC       294	F_F_HIDDEN	.LONG	F_F_IMMED
12E0 08             295			.BYTE	8	; flags + namelen
12E1 465F48494444   296			.BYTE	"F_HIDDEN"
12E7 454E        
12E9 000000         297			.ALIGN	4
12EC 00000C48       298			.LONG	C_F_HIDDEN
12F0                299	
12F0 000012DC       300	F_F_LENMASK	.LONG	F_F_HIDDEN
12F4 09             301			.BYTE	9	; flags + namelen
12F5 465F4C454E4D   302			.BYTE	"F_LENMASK"
12FB 41534B      
12FE 0000           303			.ALIGN	4
1300 00000C58       304			.LONG	C_F_LENMASK
1304                305	
1304 000012F0       306	F_TOR		.LONG	F_F_LENMASK
1308 02             307			.BYTE	2	; flags + namelen
1309 3E52           308			.BYTE	">R"
130B 00             309			.ALIGN	4
130C 00000C68       310			.LONG	C_TOR
1310                311	
1310 00001304       312	F_FROMR 	.LONG	F_TOR
1314 02             313			.BYTE	2	; flags + namelen
1315 523E           314			.BYTE	"R>"
1317 00             315			.ALIGN	4
1318 00000C7C       316			.LONG	C_FROMR
131C                317	
131C 00001310       318	F_RSPFETCH	.LONG	F_FROMR
1320 04             319			.BYTE	4	; flags + namelen
1321 52535040       320			.BYTE	"RSP@"
1325 000000         321			.ALIGN	4
1328 00000C90       322			.LONG	C_RSPFETCH
132C                323	
132C 0000131C       324	F_RSPSTORE	.LONG	F_RSPFETCH
1330 04             325			.BYTE	4	; flags + namelen
1331 52535021       326			.BYTE	"RSP!"
1335 000000         327			.ALIGN	4
1338 00000C9C       328	B_RSPSTORE	.LONG	C_RSPSTORE
133C                329	
133C 0000132C       330	F_RDROP 	.LONG	F_RSPSTORE
1340 05             331			.BYTE	5	; flags + namelen
1341 5244524F50     332			.BYTE	"RDROP"
1346 0000           333			.ALIGN	4
1348 00000CA8       334			.LONG	C_RDROP
134C                335	
134C 0000133C       336	F_DSPFETCH	.LONG	F_RDROP
1350 04             337			.BYTE	4	; flags + namelen
1351 44535040       338			.BYTE	"DSP@"
1355 000000         339			.ALIGN	4
1358 00000CB0       340	B_DSPFETCH	.LONG	C_DSPFETCH
135C                341	
135C 0000134C       342	F_DSPSTORE	.LONG	F_DSPFETCH
1360 04             343			.BYTE	4	; flags + namelen
1361 44535021       344			.BYTE	"DSP!"
1365 000000         345			.ALIGN	4
1368 00000CBE       346			.LONG	C_DSPSTORE
136C                347	
136C 0000135C       348	F_KEY		.LONG	F_DSPSTORE
1370 03             349			.BYTE	3	; flags + namelen
1371 4B4559         350			.BYTE	"KEY"
1374                351			.ALIGN	4
1374 00000CC6       352			.LONG	C_KEY
1378                353	
1378 0000136C       354	F_EMIT		.LONG	F_KEY
137C 04             355			.BYTE	4	; flags + namelen
137D 454D4954       356			.BYTE	"EMIT"
1381 000000         357			.ALIGN	4
1384 00000CD8       358	B_EMIT		.LONG	C_EMIT
1388                359	
1388 00001378       360	F_WORD		.LONG	F_EMIT
138C 04             361			.BYTE	4	; flags + namelen
138D 574F5244       362			.BYTE	"WORD"
1391 000000         363			.ALIGN	4
1394 00000CEA       364	B_WORD		.LONG	C_WORD
1398                365	
1398 00001388       366	F_NUMBER	.LONG	F_WORD
139C 06             367			.BYTE	6	; flags + namelen
139D 4E554D424552   368			.BYTE	"NUMBER"
13A3 00             369			.ALIGN	4
13A4 00000D62       370			.LONG	C_NUMBER
13A8                371	
13A8 00001398       372	F_FIND		.LONG	F_NUMBER
13AC 04             373			.BYTE	4	; flags + namelen
13AD 46494E44       374			.BYTE	"FIND"
13B1 000000         375			.ALIGN	4
13B4 00000DF8       376	B_FIND		.LONG	C_FIND
13B8                377	
13B8 000013A8       378	F_TCFA		.LONG	F_FIND
13BC 04             379			.BYTE	4	; flags + namelen
13BD 3E434641       380			.BYTE	">CFA"
13C1 000000         381			.ALIGN	4
13C4 00000E5C       382	B_TCFA		.LONG	C_TCFA
13C8                383	
13C8 000013B8       384	F_TDFA		.LONG	F_TCFA
13CC 04             385			.BYTE	4	; flags + namelen
13CD 3E444641       386			.BYTE	">DFA"
13D1 000000         387			.ALIGN	4
13D4 0000085C       388			.LONG	DOCOL
13D8 000013C4       389			.LONG	B_TCFA
13DC 000010F8       390			.LONG	B_INCR4
13E0 000011FC       391			.LONG	B_EXIT
13E4                392	
13E4 000013C8       393	F_CREATE	.LONG	F_TDFA
13E8 06             394			.BYTE	6	; flags + namelen
13E9 435245415445   395			.BYTE	"CREATE"
13EF 00             396			.ALIGN	4
13F0 00000E86       397	B_CREATE	.LONG	C_CREATE
13F4                398	
13F4 000013E4       399	F_COMMA 	.LONG	F_CREATE
13F8 01             400			.BYTE	1	; flags + namelen
13F9 2C             401			.BYTE	","
13FA 0000           402			.ALIGN	4
13FC 00000ED4       403	B_COMMA 	.LONG	C_COMMA
1400                404	
1400 000013F4       405	F_LBRAC 	.LONG	F_COMMA
1404 81             406			.BYTE	1 | F_IMMED
1405 5B             407			.BYTE	"["
1406 0000           408			.ALIGN	4
1408 00000EFA       409	B_LBRAC 	.LONG	C_LBRAC
140C                410	
140C 00001400       411	F_RBRAC 	.LONG	F_LBRAC
1410 01             412			.BYTE	1
1411 5D             413			.BYTE	"]"
1412 0000           414			.ALIGN	4
1414 00000F04       415	B_RBRAC 	.LONG	C_RBRAC
1418                416	
1418 0000140C       417	F_COLON 	.LONG	F_RBRAC
141C 01             418			.BYTE	1	; flags + namelen
141D 3A             419			.BYTE	":"
141E 0000           420			.ALIGN	4
1420 0000085C       421			.LONG	DOCOL
1424 00001394       422			.LONG	B_WORD
1428 000013F0       423			.LONG	B_CREATE
142C 000012080000   424			.LONG	B_LIT, DOCOL, B_COMMA
1432 085C000013FC
1438 000012800000   425			.LONG	B_LATEST, B_FETCH, B_HIDDEN
143E 122000001498
1444 00001414       426			.LONG	B_RBRAC
1448 000011FC       427			.LONG	B_EXIT
144C                428	
144C 00001418       429	F_SEMICOLON	.LONG	F_COLON
1450 81             430			.BYTE	1 | F_IMMED
1451 3B             431			.BYTE	";"
1452 0000           432			.ALIGN	4
1454 0000085C       433			.LONG	DOCOL
1458 000012080000   434			.LONG	B_LIT, B_EXIT, B_COMMA
145E 11FC000013FC
1464 000012800000   435			.LONG	B_LATEST, B_FETCH, B_HIDDEN
146A 122000001498
1470 00001408       436			.LONG	B_LBRAC
1474 000011FC       437			.LONG	B_EXIT
1478                438	
1478 0000144C       439	F_IMMEDIATE	.LONG	F_SEMICOLON
147C 89             440			.BYTE	9 | F_IMMED
147D 494D4D454449   441			.BYTE	"IMMEDIATE"
1483 415445      
1486 0000           442			.ALIGN	4
1488 00000F10       443			.LONG	C_IMMEDIATE
148C                444	
148C 00001478       445	F_HIDDEN_	.LONG	F_IMMEDIATE
1490 06             446			.BYTE	6
1491 48494444454E   447			.BYTE	"HIDDEN"
1497 00             448			.ALIGN	4
1498 00000F26       449	B_HIDDEN	.LONG	C_HIDDEN
149C                450	
149C 0000148C       451	F_HIDE		.LONG	F_HIDDEN_
14A0 04             452			.BYTE	4
14A1 48494445       453			.BYTE	"HIDE"
14A5 000000         454			.ALIGN	4
14A8 0000085C       455			.LONG	DOCOL
14AC 00001394       456			.LONG	B_WORD
14B0 000013B4       457			.LONG	B_FIND
14B4 00001498       458			.LONG	B_HIDDEN
14B8 000011FC       459			.LONG	B_EXIT
14BC                460	
14BC 0000149C       461	F_TICK		.LONG	F_HIDE
14C0 01             462			.BYTE	1
14C1 27             463			.BYTE	"'"
14C2 0000           464			.ALIGN	4
14C4 00000F3E       465			.LONG	C_TICK
14C8                466	
14C8 000014BC       467	F_BRANCH	.LONG	F_TICK
14CC 06             468			.BYTE	6
14CD 4252414E4348   469			.BYTE	"BRANCH"
14D3 00             470			.ALIGN	4
14D4 00000F52       471	B_BRANCH	.LONG	C_BRANCH
14D8                472	
14D8 000014C8       473	F_ZBRANCH	.LONG	F_BRANCH
14DC 07             474			.BYTE	7
14DD 304252414E43   475			.BYTE	"0BRANCH"
14E3 48          
14E4                476			.ALIGN	4
14E4 00000F5C       477	B_ZBRANCH	.LONG	C_ZBRANCH
14E8                478	
14E8 000014D8       479	F_LITSTRING	.LONG	F_ZBRANCH
14EC 09             480			.BYTE	9
14ED 4C4954535452   481			.BYTE	"LITSTRING"
14F3 494E47      
14F6 0000           482			.ALIGN	4
14F8 00000F70       483			.LONG	C_LITSTRING
14FC                484	
14FC 000014E8       485	F_TELL		.LONG	F_LITSTRING
1500 04             486			.BYTE	4
1501 54454C4C       487			.BYTE	"TELL"
1505 000000         488			.ALIGN	4
1508 00000F92       489			.LONG	C_TELL
150C                490	
150C 000014FC       491	F_CHAR		.LONG	F_TELL
1510 04             492			.BYTE	4
1511 43484152       493			.BYTE	"CHAR"
1515 000000         494			.ALIGN	4
1518 00000FB4       495			.LONG	C_CHAR
151C                496	
151C 0000150C       497	F_EXECUTE	.LONG	F_CHAR
1520 07             498			.BYTE	7
1521 455845435554   499			.BYTE	"EXECUTE"
1527 45          
1528                500			.ALIGN	4
1528 00000FCA       501			.LONG	C_EXECUTE
152C                502	
152C 0000151C       503	F_QUIT		.LONG	F_EXECUTE
1530 04             504			.BYTE	4	; flags + namelen
1531 51554954       505			.BYTE	"QUIT"
1535 000000         506			.ALIGN	4
1538 0000085C       507	B_QUIT		.LONG	DOCOL
153C 000012B80000   508			.LONG	B_R0, B_RSPSTORE
1542 1338        
1544 00001C00       509			.LONG	B_INTERPRET
1548 000014D4FFFF   510			.LONG	B_BRANCH, -8
154E FFF8        
1550                511	
1550 0000152C       512	F_NL		.LONG	F_QUIT
1554 04             513			.BYTE	4
1555 275C6E27       514			.BYTE	"'\n'"
1559 000000         515			.ALIGN	4
155C 0000085C       516	B_NL		.LONG	DOCOL
1560 000012080000   517			.LONG	B_LIT, 10
1566 000A        
1568 000011FC       518			.LONG	B_EXIT
156C                519	
156C 00001550       520	F_CR		.LONG	F_NL
1570 02             521			.BYTE	2
1571 4352           522			.BYTE	"CR"
1573 00             523			.ALIGN	4
1574 0000085C       524			.LONG	DOCOL
1578 0000155C0000   525			.LONG	B_NL, B_EMIT
157E 1384        
1580 000011FC       526			.LONG	B_EXIT
1584                527	
1584 0000156C       528	F_BL		.LONG	F_CR
1588 02             529			.BYTE	2
1589 424C           530			.BYTE	"BL"
158B 00             531			.ALIGN	4
158C 0000085C       532	B_BL		.LONG	DOCOL
1590 000012080000   533			.LONG	B_LIT, 32
1596 0020        
1598 000011FC       534			.LONG	B_EXIT
159C                535	
159C 00001584       536	F_SPACE 	.LONG	F_BL
15A0 05             537			.BYTE	5
15A1 5350414345     538			.BYTE	"SPACE"
15A6 0000           539			.ALIGN	4
15A8 0000085C       540	B_SPACE 	.LONG	DOCOL
15AC 0000158C0000   541			.LONG	B_BL, B_EMIT
15B2 1384        
15B4 000011FC       542			.LONG	B_EXIT
15B8                543	
15B8 0000159C       544	F_SPACES	.LONG	F_SPACE
15BC 06             545			.BYTE	6
15BD 535041434553   546			.BYTE	"SPACES"
15C3 00             547			.ALIGN	4
15C4 0000085C       548	B_SPACES	.LONG	DOCOL
15C8 000010980000   549			.LONG	B_DUP, B_ZGT
15CE 11B0        
15D0 000014E40000   550			.LONG	B_ZBRANCH, 20
15D6 0014        
15D8 000015A80000   551			.LONG	B_SPACE, B_DECR
15DE 10EC        
15E0 000014D4FFFF   552			.LONG	B_BRANCH, -28
15E6 FFE4        
15E8 0000106C       553			.LONG	B_DROP
15EC 000011FC       554			.LONG	B_EXIT
15F0                555	
15F0 000015B8       556	F_TRUE		.LONG	F_SPACES
15F4 04             557			.BYTE	4
15F5 54525545       558			.BYTE	"TRUE"
15F9 000000         559			.ALIGN	4
15FC 0000085C       560			.LONG	DOCOL
1600 000012080000   561			.LONG	B_LIT, 1
1606 0001        
1608 000011FC       562			.LONG	B_EXIT
160C                563	
160C 000015F0       564	F_FALSE 	.LONG	F_TRUE
1610 05             565			.BYTE	5
1611 46414C5345     566			.BYTE	"FALSE"
1616 0000           567			.ALIGN	4
1618 0000085C       568			.LONG	DOCOL
161C 000012080000   569			.LONG	B_LIT, 0
1622 0000        
1624 000011FC       570			.LONG	B_EXIT
1628                571	
1628 0000160C       572	F_NOT		.LONG	F_FALSE
162C 03             573			.BYTE	3
162D 4E4F54         574			.BYTE	"NOT"
1630                575			.ALIGN	4
1630 0000085C       576			.LONG	DOCOL
1634 0000118C       577			.LONG	B_ZEQU
1638 000011FC       578			.LONG	B_EXIT
163C                579	
163C 00001628       580	F_NEGATE	.LONG	F_NOT
1640 06             581			.BYTE	6
1641 4E4547415445   582			.BYTE	"NEGATE"
1647 00             583			.ALIGN	4
1648 0000085C       584	B_NEGATE	.LONG	DOCOL
164C 000012080000   585			.LONG	B_LIT, 0, B_SWAP, B_SUB
1652 00000000108C
1658 0000111C    
165C 000011FC       586			.LONG	B_EXIT
1660                587	
1660 0000163C       588	F_DIVMOD	.LONG	F_NEGATE
1664 04             589			.BYTE	4
1665 2F4D4F44       590			.BYTE	"/MOD"
1669 000000         591			.ALIGN	4
166C 000009DC       592	B_DIVMOD	.LONG	C_DIVMOD
1670                593	
1670 00001660       594	F_DIV		.LONG	F_DIVMOD
1674 01             595			.BYTE	1
1675 2F             596			.BYTE	"/"
1676 0000           597			.ALIGN	4
1678 0000085C       598	B_DIV		.LONG	DOCOL
167C 0000166C0000   599			.LONG	B_DIVMOD, B_SWAP, B_DROP
1682 108C0000106C
1688 000011FC       600			.LONG	B_EXIT
168C                601	
168C 00001670       602	F_MOD		.LONG	F_DIV
1690 03             603			.BYTE	3
1691 4D4F44         604			.BYTE	"MOD"
1694                605			.ALIGN	4
1694 0000085C       606			.LONG	DOCOL
1698 0000166C0000   607			.LONG	B_DIVMOD, B_DROP
169E 106C        
16A0 000011FC       608			.LONG	B_EXIT
16A4                609	
16A4 0000168C       610	F_LITERAL	.LONG	F_MOD
16A8 87             611			.BYTE	7 | F_IMMED
16A9 4C4954455241   612			.BYTE	"LITERAL"
16AF 4C          
16B0                613			.ALIGN	4
16B0 0000085C       614			.LONG	DOCOL
16B4 000012080000   615			.LONG	B_LIT, B_LIT, B_COMMA
16BA 1208000013FC
16C0 000011FC       616			.LONG	B_EXIT
16C4                617	
16C4 000016A4       618	F_COMPILE	.LONG	F_LITERAL
16C8 89             619			.BYTE	9 | F_IMMED
16C9 5B434F4D5049   620			.BYTE	"[COMPILE]"
16CF 4C455D      
16D2 0000           621			.ALIGN	4
16D4 0000085C       622			.LONG	DOCOL
16D8 00001394       623			.LONG	B_WORD		; get next word
16DC 000013B4       624			.LONG	B_FIND		; find in dictionary
16E0 000013C4       625			.LONG	B_TCFA		; get codeword
16E4 000013FC       626			.LONG	B_COMMA 	; compile that
16E8 000011FC       627			.LONG	B_EXIT
16EC                628	
16EC 000016C4       629	F_RECURSE	.LONG	F_COMPILE
16F0 87             630			.BYTE	7 | F_IMMED
16F1 524543555253   631			.BYTE	"RECURSE"
16F7 45          
16F8                632			.ALIGN	4
16F8 0000085C       633			.LONG	DOCOL
16FC 000012800000   634			.LONG	B_LATEST, B_FETCH
1702 1220        
1704 000013C40000   635			.LONG	B_TCFA, B_COMMA
170A 13FC        
170C 000011FC       636			.LONG	B_EXIT
1710                637	
1710 000016EC       638	F_IF		.LONG	F_RECURSE
1714 82             639			.BYTE	2 | F_IMMED
1715 4946           640			.BYTE	"IF"
1717 00             641			.ALIGN	4
1718 0000085C       642			.LONG	DOCOL
171C 000012080000   643			.LONG	B_LIT, B_ZBRANCH, B_COMMA	; compile 0BRANCH
1722 14E4000013FC
1728 000012700000   644			.LONG	B_HERE, B_FETCH 		; save current location on stack
172E 1220        
1730 000012080000   645			.LONG	B_LIT, 0, B_COMMA		; compile dummy offset
1736 0000000013FC
173C 000011FC       646			.LONG	B_EXIT
1740                647	
1740 00001710       648	F_THEN		.LONG	F_IF
1744 84             649			.BYTE	4 | F_IMMED
1745 5448454E       650			.BYTE	"THEN"
1749 000000         651			.ALIGN	4
174C 0000085C       652			.LONG	DOCOL
1750 00001098       653			.LONG	B_DUP
1754 000012700000   654			.LONG	B_HERE, B_FETCH, B_SWAP, B_SUB	; calculate offset
175A 12200000108C
1760 0000111C    
1764 0000108C0000   655			.LONG	B_SWAP, B_STORE 		; store offset
176A 1214        
176C 000011FC       656			.LONG	B_EXIT
1770                657	
1770 00001740       658	F_ELSE		.LONG	F_THEN
1774 84             659			.BYTE	4 | F_IMMED
1775 454C5345       660			.BYTE	"ELSE"
1779 000000         661			.ALIGN	4
177C 0000085C       662			.LONG	DOCOL
1780 000012080000   663			.LONG	B_LIT, B_BRANCH, B_COMMA	; compile BRANCH to skip false part
1786 14D4000013FC
178C 000012700000   664			.LONG	B_HERE, B_FETCH 		; save current location on stack
1792 1220        
1794 000012080000   665			.LONG	B_LIT, 0, B_COMMA		; compile dummy offset
179A 0000000013FC
17A0 0000108C0000   666			.LONG	B_SWAP, B_DUP
17A6 1098        
17A8 000012700000   667			.LONG	B_HERE, B_FETCH, B_SWAP, B_SUB	; calculate offset
17AE 12200000108C
17B4 0000111C    
17B8 0000108C0000   668			.LONG	B_SWAP, B_STORE 		; store offset
17BE 1214        
17C0 000011FC       669			.LONG	B_EXIT
17C4                670	
17C4 00001770       671	F_BEGIN 	.LONG	F_ELSE
17C8 85             672			.BYTE	5 | F_IMMED
17C9 424547494E     673			.BYTE	"BEGIN"
17CE 0000           674			.ALIGN	4
17D0 0000085C       675			.LONG	DOCOL
17D4 000012700000   676			.LONG	B_HERE, B_FETCH
17DA 1220        
17DC 000011FC       677			.LONG	B_EXIT
17E0                678	
17E0 000017C4       679	F_UNTIL 	.LONG	F_BEGIN
17E4 85             680			.BYTE	5 | F_IMMED
17E5 554E54494C     681			.BYTE	"UNTIL"
17EA 0000           682			.ALIGN	4
17EC 0000085C       683			.LONG	DOCOL
17F0 000012080000   684			.LONG	B_LIT, B_ZBRANCH, B_COMMA
17F6 14E4000013FC
17FC 000012700000   685			.LONG	B_HERE, B_FETCH, B_SUB, B_COMMA
1802 12200000111C
1808 000013FC    
180C 000011FC       686			.LONG	B_EXIT
1810                687	
1810 000017E0       688	F_AGAIN 	.LONG	F_UNTIL
1814 85             689			.BYTE	5 | F_IMMED
1815 414741494E     690			.BYTE	"AGAIN"
181A 0000           691			.ALIGN	4
181C 0000085C       692			.LONG	DOCOL
1820 000012080000   693			.LONG	B_LIT, B_BRANCH, B_COMMA
1826 14D4000013FC
182C 000012700000   694			.LONG	B_HERE, B_FETCH, B_SUB, B_COMMA
1832 12200000111C
1838 000013FC    
183C 000011FC       695			.LONG	B_EXIT
1840                696	
1840 00001810       697	F_WHILE 	.LONG	F_AGAIN
1844 85             698			.BYTE	5 | F_IMMED
1845 5748494C45     699			.BYTE	"WHILE"
184A 0000           700			.ALIGN	4
184C 0000085C       701			.LONG	DOCOL
1850 000012080000   702			.LONG	B_LIT, B_ZBRANCH, B_COMMA
1856 14E4000013FC
185C 000012700000   703			.LONG	B_HERE, B_FETCH
1862 1220        
1864 000012080000   704			.LONG	B_LIT, 0, B_COMMA
186A 0000000013FC
1870 000011FC       705			.LONG	B_EXIT
1874                706	
1874 00001840       707	F_REPEAT	.LONG	F_WHILE
1878 86             708			.BYTE	6 | F_IMMED
1879 524550454154   709			.BYTE	"REPEAT"
187F 00             710			.ALIGN	4
1880 0000085C       711			.LONG	DOCOL
1884 000012080000   712			.LONG	B_LIT, B_BRANCH, B_COMMA
188A 14D4000013FC
1890 0000108C       713			.LONG	B_SWAP
1894 000012700000   714			.LONG	B_HERE, B_FETCH, B_SUB, B_COMMA
189A 12200000111C
18A0 000013FC    
18A4 00001098       715			.LONG	B_DUP
18A8 000012700000   716			.LONG	B_HERE, B_FETCH, B_SWAP, B_SUB
18AE 12200000108C
18B4 0000111C    
18B8 0000108C0000   717			.LONG	B_SWAP, B_STORE
18BE 1214        
18C0 000011FC       718			.LONG	B_EXIT
18C4                719	
18C4 00001874       720	F_UPOINT	.LONG	F_REPEAT
18C8 02             721			.BYTE	2
18C9 552E           722			.BYTE	"U."
18CB 00             723			.ALIGN	4
18CC 0000085C       724	B_UPOINT	.LONG	DOCOL
18D0 0000129C0000   725			.LONG	B_BASE, B_FETCH, B_DIVMOD
18D6 12200000166C
18DC 000010D40000   726			.LONG	B_QDUP, B_ZBRANCH, 8
18E2 14E400000008
18E8 000018CC       727			.LONG	B_UPOINT
18EC 000010980000   728			.LONG	B_DUP, B_LIT, 10, B_LT
18F2 12080000000A
18F8 0000115C    
18FC 000014E40000   729			.LONG	B_ZBRANCH, 20
1902 0014        
1904 000012080000   730			.LONG	B_LIT, $30	; '0'
190A 0030        
190C 000014D40000   731			.LONG	B_BRANCH, 24
1912 0018        
1914 000012080000   732			.LONG	B_LIT, 10, B_SUB, B_LIT, $41 ; 'A'
191A 000A0000111C
1920 000012080000
1926 0041        
1928 000011100000   733			.LONG	B_ADD, B_EMIT
192E 1384        
1930 000011FC       734			.LONG	B_EXIT
1934                735	
1934 000018C4       736	F_POINTS	.LONG	F_UPOINT
1938 02             737			.BYTE	2
1939 2E53           738			.BYTE	".S"
193B 00             739			.ALIGN	4
193C 0000085C       740			.LONG	DOCOL
1940 00001358       741			.LONG	B_DSPFETCH
1944 000010980000   742			.LONG	B_DUP, B_S0, B_LT
194A 128C0000115C
1950 000014E40000   743			.LONG	B_ZBRANCH, 36
1956 0024        
1958 000010980000   744			.LONG	B_DUP, B_FETCH, B_UPOINT, B_SPACE
195E 1220000018CC
1964 000015A8    
1968 000010F80000   745			.LONG	B_INCR4, B_INCR4	; stack is 8 byte aligned
196E 10F8        
1970 000014D4FFFF   746			.LONG	B_BRANCH, -48
1976 FFD0        
1978 0000106C       747			.LONG	B_DROP
197C 000011FC       748			.LONG	B_EXIT
1980                749	
1980 00001934       750	F_UWIDTH	.LONG	F_POINTS
1984 06             751			.BYTE	6
1985 555749445448   752			.BYTE	"UWIDTH"
198B 00             753			.ALIGN	4
198C 0000085C       754	B_UWIDTH	.LONG	DOCOL
1990 0000129C0000   755			.LONG	B_BASE, B_FETCH, B_DIV
1996 122000001678
199C 000010D40000   756			.LONG	B_QDUP, B_ZBRANCH, 20
19A2 14E400000014
19A8 0000198C0000   757			.LONG	B_UWIDTH, B_INCR
19AE 10E0        
19B0 000014D40000   758			.LONG	B_BRANCH, 12
19B6 000C        
19B8 000012080000   759			.LONG	B_LIT, 1
19BE 0001        
19C0 000011FC       760			.LONG	B_EXIT
19C4                761	
19C4 00001980       762	F_UPOINTR	.LONG	F_UWIDTH
19C8 03             763			.BYTE	3
19C9 552E52         764			.BYTE	"U.R"
19CC                765			.ALIGN	4
19CC 0000085C       766			.LONG	DOCOL
19D0 0000108C0000   767			.LONG	B_SWAP, B_DUP, B_UWIDTH, B_ROT, B_SWAP, B_SUB
19D6 10980000198C
19DC 000010B40000
19E2 108C0000111C
19E8 000015C4       768			.LONG	B_SPACES
19EC 000018CC       769			.LONG	B_UPOINT
19F0 000011FC       770			.LONG	B_EXIT
19F4                771	
19F4 000019C4       772	F_POINTR	.LONG	F_UPOINTR
19F8 02             773			.BYTE	2
19F9 2E52           774			.BYTE	".R"
19FB 00             775			.ALIGN	4
19FC 0000085C       776	B_POINTR	.LONG	DOCOL
1A00 0000108C0000   777			.LONG	B_SWAP, B_DUP, B_ZLT
1A06 1098000011A4
1A0C 000014E40000   778			.LONG	B_ZBRANCH, 36
1A12 0024        
1A14 000016480000   779			.LONG	B_NEGATE, B_LIT, 1, B_SWAP, B_ROT, B_DECR
1A1A 120800000001
1A20 0000108C0000
1A26 10B4000010EC
1A2C 000014D40000   780			.LONG	B_BRANCH, 20
1A32 0014        
1A34 000012080000   781			.LONG	B_LIT, 0, B_SWAP, B_ROT
1A3A 00000000108C
1A40 000010B4    
1A44 0000108C0000   782			.LONG	B_SWAP, B_DUP, B_UWIDTH, B_ROT, B_SWAP, B_SUB
1A4A 10980000198C
1A50 000010B40000
1A56 108C0000111C
1A5C 000015C40000   783			.LONG	B_SPACES, B_SWAP
1A62 108C        
1A64 000014E40000   784			.LONG	B_ZBRANCH, 16
1A6A 0010        
1A6C 000012080000   785			.LONG	B_LIT, '-', B_EMIT
1A72 002D00001384
1A78 000018CC       786			.LONG	B_UPOINT
1A7C 000011FC       787			.LONG	B_EXIT
1A80                788	
1A80 000019F4       789	F_POINT 	.LONG	F_POINTR
1A84 01             790			.BYTE	1
1A85 2E             791			.BYTE	"."
1A86 0000           792			.ALIGN	4
1A88 0000085C       793	B_POINT 	.LONG	DOCOL
1A8C 000012080000   794			.LONG	B_LIT, 0, B_POINTR, B_SPACE, B_EXIT
1A92 0000000019FC
1A98 000015A80000
1A9E 11FC        
1AA0                795	
1AA0 00001A80       796	F_QUESTION	.LONG	F_POINT
1AA4 01             797			.BYTE	1
1AA5 3F             798			.BYTE	"?"
1AA6 0000           799			.ALIGN	4
1AA8 0000085C       800			.LONG	DOCOL
1AAC 000012200000   801			.LONG	B_FETCH, B_POINT, B_EXIT
1AB2 1A88000011FC
1AB8                802	
1AB8 00001AA0       803	F_HEX		.LONG	F_QUESTION
1ABC 03             804			.BYTE	3
1ABD 484558         805			.BYTE	"HEX"
1AC0                806			.ALIGN	4
1AC0 0000085C       807			.LONG	DOCOL
1AC4 000012080000   808			.LONG	B_LIT, 16, B_BASE, B_STORE, B_EXIT
1ACA 00100000129C
1AD0 000012140000
1AD6 11FC        
1AD8                809	
1AD8 00001AB8       810	F_DECIMAL	.LONG	F_HEX
1ADC 07             811			.BYTE	7
1ADD 444543494D41   812			.BYTE	"DECIMAL"
1AE3 4C          
1AE4                813			.ALIGN	4
1AE4 0000085C       814			.LONG	DOCOL
1AE8 000012080000   815			.LONG	B_LIT, 10, B_BASE, B_STORE, B_EXIT
1AEE 000A0000129C
1AF4 000012140000
1AFA 11FC        
1AFC                816	
1AFC 00001AD8       817	F_CONSTANT	.LONG	F_DECIMAL
1B00 08             818			.BYTE	8
1B01 434F4E535441   819			.BYTE	"CONSTANT"
1B07 4E54        
1B09 000000         820			.ALIGN	4
1B0C 0000085C       821			.LONG	DOCOL
1B10 000013940000   822			.LONG	B_WORD, B_CREATE
1B16 13F0        
1B18 000012080000   823			.LONG	B_LIT, DOCOL, B_COMMA
1B1E 085C000013FC
1B24 000012080000   824			.LONG	B_LIT, B_LIT, B_COMMA
1B2A 1208000013FC
1B30 000013FC       825			.LONG	B_COMMA
1B34 000012080000   826			.LONG	B_LIT, B_EXIT, B_COMMA
1B3A 11FC000013FC
1B40 000011FC       827			.LONG	B_EXIT
1B44                828	
1B44 00001AFC       829	F_ALLOT 	.LONG	F_CONSTANT
1B48 05             830			.BYTE	5
1B49 414C4C4F54     831			.BYTE	"ALLOT"
1B4E 0000           832			.ALIGN	4
1B50 0000085C       833	B_ALLOT 	.LONG	DOCOL
1B54 000012700000   834			.LONG	B_HERE, B_FETCH, B_SWAP, B_HERE, B_ADDSTORE, B_EXIT
1B5A 12200000108C
1B60 000012700000
1B66 122C000011FC
1B6C                835	
1B6C 00001B44       836	F_CELLS 	.LONG	F_ALLOT
1B70 05             837			.BYTE	5
1B71 43454C4C53     838			.BYTE	"CELLS"
1B76 0000           839			.ALIGN	4
1B78 0000085C       840	B_CELLS 	.LONG	DOCOL
1B7C 000012080000   841			.LONG	B_LIT, 4, B_MUL, B_EXIT
1B82 000400001138
1B88 000011FC    
1B8C                842	
1B8C 00001B6C       843	F_VARIABLE	.LONG	F_CELLS
1B90 08             844			.BYTE	8
1B91 564152494142   845			.BYTE	"VARIABLE"
1B97 4C45        
1B99 000000         846			.ALIGN	4
1B9C 0000085C       847			.LONG	DOCOL
1BA0 000012080000   848			.LONG	B_LIT, 1, B_CELLS, B_ALLOT
1BA6 000100001B78
1BAC 00001B50    
1BB0 000013940000   849			.LONG	B_WORD, B_CREATE
1BB6 13F0        
1BB8 000012080000   850			.LONG	B_LIT, DOCOL, B_COMMA
1BBE 085C000013FC
1BC4 000012080000   851			.LONG	B_LIT, B_LIT, B_COMMA
1BCA 1208000013FC
1BD0 000013FC       852			.LONG	B_COMMA
1BD4 000012080000   853			.LONG	B_LIT, B_EXIT, B_COMMA
1BDA 11FC000013FC
1BE0 000011FC       854			.LONG	B_EXIT
1BE4                855	
1BE4 00001B8C       856	F_BYE		.LONG	F_VARIABLE
1BE8 03             857			.BYTE	3
1BE9 425945         858			.BYTE	"BYE"
1BEC                859			.ALIGN	4
1BEC 0000089C       860			.LONG	C_BYE
1BF0                861	
1BF0                862	# last word builtin
1BF0 00001BE4       863	F_INTERPRET	.LONG	F_BYE
1BF4 09             864			.BYTE	9
1BF5 494E54455250   865			.BYTE	"INTERPRET"
1BFB 524554      
1BFE 0000           866			.ALIGN	4
1C00 00000FD8       867	B_INTERPRET	.LONG	C_INTERPRET
1C04                868	
1C04                869	# QUIT word to JUMP
1C04 00001538       870	W_QUIT		.LONG	B_QUIT
####################### string.asm
1C08                  1	#
1C08                  2	# string area
1C08                  3	#
1C08 0A454F4E2052     4	HELLO		.BYTE	LF, "EON ROM 0.1.0", 0
1C0E 4F4D20302E31
1C14 2E3000      
1C17 0A               5	MENU		.BYTE	LF
1C18 312E20474554     6			.BYTE	"1. GET/SET DATE   4. BENCHMARK", LF
1C1E 2F5345542044
1C24 415445202020
1C2A 342E2042454E
1C30 43484D41524B
1C36 0A          
1C37 322E204D454D     7			.BYTE	"2. MEMORY MONITOR 9. ILLEGAL", LF
1C3D 4F5259204D4F
1C43 4E49544F5220
1C49 392E20494C4C
1C4F 4547414C0A  
1C54 332E20464F52     8			.BYTE	"3. FORTH          0. RESET", LF
1C5A 544820202020
1C60 202020202020
1C66 302E20524553
1C6C 45540A      
1C6F 4F5054494F4E     9			.BYTE	"OPTION? ", 0
1C75 3F2000      
1C78 0A4A4F4E4553    10	FORTH_HELLO	.BYTE	LF, "JONES FORTH READY", LF, 0
1C7E 20464F525448
1C84 205245414459
1C8A 0A00        
1C8C 504152534552    11	PARSER_ERROR	.BYTE	"PARSER ERROR", LF, 0
1C92 204552524F52
1C98 0A00        
1C9A 0D202000        12	DATE_HEADER	.BYTE	CR, "  ", 0
1C9E 20285441422F    13	DATE_FOOTER	.BYTE	" (TAB/SPACE=NEXT, ESC/X=EXIT ENTER=UPDATE)", ESC, "[", 0
1CA4 53504143453D
1CAA 4E4558542C20
1CB0 4553432F583D
1CB6 455849542045
1CBC 4E5445523D55
1CC2 504441544529
1CC8 1B5B00      
1CCB 030405060708    14	DATE_COLS	.BYTE	3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 17, 18, 19
1CD1 090A0C0E0F10
1CD7 111213      
1CDA 0A4441544520    15	DATE_WRITTEN	.BYTE	LF, "DATE WRITTEN !", 0
1CE0 575249545445
1CE6 4E202100    
1CEA 303132333435    16	HTAB		.BYTE	"0123456789ABCDEF"
1CF0 363738394142
1CF6 43444546    
1CFA 5B4B00          17	ESCOFF		.BYTE	"[K", 0
1CFD 0A2028455343    18	MMON_HEADER	.BYTE	LF, " (ESC/X=EXIT ENTER=GOTO TAB=NEXT Z=ZERO I=INC LINES P/K=POKE R=RUN)", LF, 0
1D03 2F583D455849
1D09 5420454E5445
1D0F 523D474F544F
1D15 205441423D4E
1D1B 455854205A3D
1D21 5A45524F2049
1D27 3D494E43204C
1D2D 494E45532050
1D33 2F4B3D504F4B
1D39 4520523D5255
1D3F 4E290A00    
1D43 0A4558434550    19	EXC_HEADER	.BYTE	LF, "EXCEPTION ", 0
1D49 54494F4E2000
1D4F 2041542000      20	EXC_MIDDLE	.BYTE	" AT ", 0
1D54 205749544820    21	EXC_FOOTER	.BYTE	" WITH REGS:", 0
1D5A 524547533A00
1D60 0A4352433332    22	BENCH_HEADER	.BYTE	LF, "CRC32 FIRST 64 ROM BYTES 100 TIMES: ", 0
1D66 204649525354
1D6C 20363420524F
1D72 4D2042595445
1D78 532031303020
1D7E 54494D45533A
1D84 2000        
#######################     4 passes. global/local labels (MAX   512):   342 /    83

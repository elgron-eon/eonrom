####################### rom.asm
0000                  1	#
0000                  2	# rom.asm
0000                  3	#
0000                  4	# eon ROM
0000                  5	# (c) JCGV, junio del 2022
0000                  6	#
0000                  7	
0000                  8	#
0000                  9	# CONFIG
0000                 10	#
0000 = 0000.0010     11	KEYBUF_SIZE	.EQU	16
0000                 12	
0000                 13	# constants
0000 = 0000.0008     14	BS		.EQU	$08
0000 = 0000.007F     15	DEL		.EQU	$7f
0000 = 0000.0009     16	TAB		.EQU	$09
0000 = 0000.000A     17	LF		.EQU	$0a
0000 = 0000.000D     18	CR		.EQU	$0d
0000 = 0000.001B     19	ESC		.EQU	$1b
0000 = 0000.0008     20	MLINBYTES	.EQU	8
0000 = 0000.0200     21	SECTOR_BYTES	.EQU	512
0000                 22	
0000                 23	# IRQs
0000 = 0000.0001     24	IRQ_RTC 	.EQU	$01
0000 = 0000.0002     25	IRQ_TIMER	.EQU	$02
0000 = 0000.0004     26	IRQ_CON 	.EQU	$04
0000 = 0000.0008     27	IRQ_DISK	.EQU	$08
0000                 28	
0000                 29	# special registers
0000 = 0000.0000     30	REG_MOD 	.EQU	$00
0000 = 0000.0004     31	REG_IRQ_MASK	.EQU	$04
0000 = 0000.0005     32	REG_IRQ_PC	.EQU	$05
0000 = 0000.0006     33	REG_IRQ_SCRATCH .EQU	$06
0000 = 0000.0007     34	REG_IRQ_SAVE	.EQU	$07
0000 = 0000.000C     35	REG_EXC_CODE	.EQU	$0c
0000 = 0000.000D     36	REG_EXC_PC	.EQU	$0d
0000 = 0000.000E     37	REG_EXC_SCRATCH .EQU	$0e
0000 = 0000.000F     38	REG_EXC_SAVE	.EQU	$0f
0000                 39	
0000                 40	# I/O devices
0000 = 0000.0000     41	CON_CTRL	.EQU	$00
0000 = 0000.0001     42	CON_DATA	.EQU	CON_CTRL + 1
0000 = 0000.0002     43	RTC_CTRL	.EQU	$02
0000 = 0000.0003     44	RTC_DATA	.EQU	RTC_CTRL + 1
0000 = 0000.0004     45	RTC_WRITE	.EQU	RTC_CTRL + 2
0000 = 0000.0008     46	TIMER_CTRL	.EQU	$08
0000 = 0000.0010     47	DISK_CTRL	.EQU	$10
0000 = 0000.0011     48	DISK_CMD	.EQU	DISK_CTRL + 1
0000 = 0000.0012     49	DISK_ADDRHI	.EQU	DISK_CTRL + 2
0000 = 0000.0013     50	DISK_ADDRLO	.EQU	DISK_CTRL + 3
0000 = 0000.00FF     51	DEBUG_IO	.EQU	$FF
0000                 52	
0000                 53	#
0000                 54	# disk commands
0000                 55	#
0000 = 0000.0000     56	DISK_CMD_INFO	.EQU	0
0000 = 0000.0001     57	DISK_CMD_READ	.EQU	1
0000 = 0000.0002     58	DISK_CMD_WRITE	.EQU	2
0000                 59	
0000                 60	#
0000                 61	# memory map: assumes at least 32KB of memory
0000                 62	#	 8KB rom
0000                 63	#	 4KB system data & stacks
0000                 64	#	 4KB forth rstack
0000                 65	#	12KB forth code area
0000                 66	#	 4KB disk I/O area
0000                 67	#
0000 = 0000.0000     68	ROM_START	.EQU	$00000
0000 = 0000.2000     69	RAM_START	.EQU	$02000
0000 = 0000.3000     70	IRQ_STACK	.EQU	$03000
0000 = 0000.2FE0     71	EXC_STACK	.EQU	IRQ_STACK - 32
0000 = 0000.2F60     72	SYS_STACK	.EQU	EXC_STACK - 128
0000 = 0000.4000     73	RSTACK		.EQU	$04000
0000 = 0000.7000     74	IOAREA		.EQU	$07000
0000                 75	
0000                 76	#
0000                 77	# RAM area
0000                 78	#
0000                 79			.ORG	RAM_START
2000                 80	SYSVARS_START
2000 ? 0004     4    81	TICK_M10	.SPACE	4
2004 ? 0004     4    82	MMON_VALUE	.SPACE	4
2008 ? 0004     4    83	DISK_SECTORS	.SPACE	4
200C                 84	
200C                 85	# jforth vars
200C ? 0004     4    86	FORTH_STATE	.SPACE	4
2010 ? 0004     4    87	FORTH_HERE	.SPACE	4
2014 ? 0004     4    88	FORTH_LATEST	.SPACE	4
2018 ? 0004     4    89	FORTH_BASE	.SPACE	4
201C                 90	
201C                 91	# forth word buffer
201C ? 0020    32    92	WORD_BUFFER	.SPACE	32
203C                 93	
203C                 94	# serial buffer
203C ? 0012    18    95	KEYBUF		.SPACE	KEYBUF_SIZE + 2
204E                 96	
204E                 97	# rtc date buffer
204E ? 0008     8    98	DATE_IO 	.SPACE	8
2056 ? 0001     1    99	DATE_READY	.SPACE	1
2057                100	
2057                101	# disk ready
2057 ? 0001     1   102	DISK_READY	.SPACE	1
2058                103	
2058                104	# align end marker
2058 ? 0008     8   105			.SPACE	 8 - ($$ % 8)
2060                106	SYSVARS_END
2060                107	
2060                108	#
2060                109	# BIOS
2060                110	#
2060                111			.ORG	ROM_START
0000                112	
0000                113	# RESET system, power on entry point
0000 80FF           114	RESET		LI	R0, 0
0002 0F090004       115			SET	REG_IRQ_MASK, R0
0006 30F92F60       116			LI	R0, SYS_STACK
000A 9FF0           117			MV	SP, R0
000C 30F90020       118			LI	R0, IRQ_HANDLER
0010 0F090005       119			SET	REG_IRQ_PC, R0
0014 30F902DA       120			LI	R0, EXC_HANDLER
0018 0F09000D       121			SET	REG_EXC_PC, R0
001C 2FF001CB       122			BRA	MONITOR
0020                123	
0020                124	# IRQ handler
0020 0F090006       125	IRQ_HANDLER	SET	REG_IRQ_SCRATCH, R0
0024 0F0D00002FD6   126			LEA	R0, IRQ_STACK
002A 110AFFFF       127			ST4	[R0 - 1], R1
002E 120AFFFE       128			ST4	[R0 - 2], R2
0032 130AFFFD       129			ST4	[R0 - 3], R3
0036 140AFFFC       130			ST4	[R0 - 4], R4
003A 150AFFFB       131			ST4	[R0 - 5], R5
003E 0F14           132			ISTAT	R1
0040 32180004       133			AND	R2, R1, IRQ_CON
0044 22F00015       134			BZ	R2, .NOCON
0048                135	
0048                136			# key pressed
0048 34F9203C       137			LI	R4, KEYBUF
004C 12400000       138			LD1	R2, [R4]	# head offset
0050 13400001       139			LD1	R3, [R4 + 1]	# tail offset
0054 33340001       140			ADD	R3, 1
0058 3338000F       141			AND	R3, KEYBUF_SIZE - 1
005C 23200009       142			BEQ	R3, R2, .NOCON	# buffer is full
0060                143	
0060 12400001       144			LD1	R2, [R4 + 1]	# get tail again
0064 13480001       145			ST1	[R4 + 1], R3	# store new tail
0068 4224           146			ADD	R2, R4
006A 04F8           147			LI	R4, CON_DATA
006C 044E           148			IN	R4, R4		# r4 = char
006E 14280002       149			ST1	[R2 + 2], R4	# store char
0072                150	
0072 32180001       151	.NOCON		AND	R2, R1, IRQ_RTC
0076 22F00015       152			BZ	R2, .NORTC
007A 0F2D00001FCE   153			LEA	R2, DATE_IO
0080 0F3DFFFFFF7D   154			LEA	R3, RTC_DATA
0086 0F4DFFFFFF7C   155			LEA	R4, 8
008C 053E           156	.RTCDUMP	IN	R5, R3
008E 15280000       157			ST1	[R2], R5
0092 32240001       158			ADD	R2, 1
0096 34450001       159			SUB	R4, 1
009A 24F1FFF7       160			BNZ	R4, .RTCDUMP
009E 04F8           161			LI	R4, 1
00A0 14280000       162			ST1	[R2], R4
00A4                163	
00A4 32180008       164	.NORTC		AND	R2, R1, IRQ_DISK
00A8 22F00003       165			BZ	R2, .NODISK
00AC 02F8           166			LI	R2, 1
00AE 12282056       167			ST1	[R2 + DISK_READY - 1], R2
00B2                168	
00B2 32180002       169	.NODISK 	AND	R2, R1, IRQ_TIMER
00B6 22F00008       170			BZ	R2, .DONE
00BA 32F92000       171			LI	R2, TICK_M10
00BE 13240000       172			LD4	R3, [R2]
00C2 33340001       173			ADD	R3, 1
00C6 132A0000       174			ST4	[R2], R3
00CA                175	
00CA 1104FFFF       176	.DONE		LD4	R1, [R0 - 1]
00CE 1204FFFE       177			LD4	R2, [R0 - 2]
00D2 1304FFFD       178			LD4	R3, [R0 - 3]
00D6 1404FFFC       179			LD4	R4, [R0 - 4]
00DA 1504FFFB       180			LD4	R5, [R0 - 5]
00DE 0F080006       181			GET	R0, REG_IRQ_SCRATCH
00E2 0FF4           182			IRET
00E4                183	
00E4                184	# CONOUT: output R0 in serial line
00E4 82FF           185	CONOUT		LI	R2, CON_CTRL
00E6 012E           186			IN	R1, R2
00E8 21F0FFFC       187			BZ	R1, CONOUT     ; ready wait
00EC 02F8           188			LI	R2, CON_DATA
00EE 002F           189			OUT	R0, R2
00F0 0FE0           190			RET
00F2                191	
00F2                192	# CONSTR: output zero terminated string in R0
00F2 93F0           193	CONSTR		MV	R3, R0
00F4 94FE           194			MV	R4, R14
00F6 10300000       195	.AGAIN		LD1	R0, [R3]
00FA 20F00007       196			BZ	R0, .DONE
00FE 0FFDFFFFFFF0   197			JAL	CONOUT
0104 33340001       198			ADD	R3, 1
0108 2FF0FFF5       199			BRA	.AGAIN
010C 9EF4           200	.DONE		MV	R14, R4
010E 0FE0           201			RET
0110                202	
0110                203	# CONREAD: wait for console char
0110 0FF3           204	CONREADWAIT	WAIT
0112 34F9203C       205	CONREAD 	LI	R4, KEYBUF
0116 11400000       206			LD1	R1, [R4]
011A 10400001       207			LD1	R0, [R4 + 1]
011E 2100FFF7       208			BEQ	R1, R0, CONREADWAIT
0122 4014           209			ADD	R0, R1, R4
0124 10000002       210			LD1	R0, [R0 + 2]	# get character
0128 31140001       211			ADD	R1, 1
012C 3118000F       212			AND	R1, KEYBUF_SIZE - 1
0130 11480000       213			ST1	[R4], R1	# store new head
0134 0FE0           214			RET
0136                215	
0136                216	# CONREADECHO: read console with echo
0136 1EFAFFFF       217	CONREADECHO	ST4	[SP - 1], R14
013A 0FFDFFFFFFE9   218			JAL	CONREAD
0140 31F9000D       219			LI	R1, CR
0144 20110002       220			BNE	R0, R1, .NOCR
0148 30F9000A       221			LI	R0, LF
014C 0FFDFFFFFFC9   222	.NOCR		JAL	CONOUT
0152 1EF4FFFF       223			LD4	R14, [SP - 1]
0156 0FE0           224			RET
0158                225	
0158                226	#
0158                227	# utils
0158                228	#
0158                229	
0158                230	# DECNUM2: output decimal number < 100
0158 1EFAFFFF       231	DECNUM2 	ST4	[SP - 1], R14
015C 18FAFFFE       232			ST4	[SP - 2], R8
0160 31F9000A       233			LI	R1, 10
0164 82FF           234			LI	R2, 0
0166 20120005       235			BLT	R0, R1, .DONE
016A 5001           236	.AGAIN		SUB	R0, R1
016C 32240001       237			ADD	R2, 1
0170 2104FFFB       238			BLE	R1, R0, .AGAIN
0174                239	
0174                240	.DONE		# R2 = first digit
0174                241			# R0 = second digit
0174 98F0           242			MV	R8, R0
0176 30240030       243			ADD	R0, R2, '0'
017A 0FFDFFFFFFB2   244			JAL	CONOUT
0180 30840030       245			ADD	R0, R8, '0'
0184 0FFDFFFFFFAD   246			JAL	CONOUT
018A 1EF4FFFF       247			LD4	R14, [SP - 1]
018E 18F4FFFE       248			LD4	R8,  [SP - 2]
0192 0FE0           249			RET
0194                250	
0194                251	# DECNUM4: output decimal number < 10000
0194 0FF8FFFE       252	DECNUM4 	ENTER	-2
0198 1EFA0000       253			ST4	[SP + 0], R14
019C 18FA0001       254			ST4	[SP + 1], R8
01A0 31F90064       255			LI	R1, 100
01A4 82FF           256			LI	R2, 0
01A6 20120005       257			BLT	R0, R1, .DONE
01AA 5001           258	.AGAIN		SUB	R0, R1
01AC 32240001       259			ADD	R2, 1
01B0 2104FFFB       260			BLE	R1, R0, .AGAIN
01B4 98F0           261	.DONE		MV	R8, R0
01B6 90F2           262			MV	R0, R2
01B8 0FFDFFFFFFCD   263			JAL	DECNUM2
01BE 90F8           264			MV	R0, R8
01C0 0FFDFFFFFFC9   265			JAL	DECNUM2
01C6 1EF40000       266			LD4	R14, [SP + 0]
01CA 18F40001       267			LD4	R8,  [SP + 1]
01CE 0FF80002       268			ENTER	2
01D2 0FE0           269			RET
01D4                270	
01D4                271	# MUL10: multiply R0 * 10
01D4 300B0001       272	MUL10		SHL	R0, R0, 1
01D8 91F0           273			MV	R1, R0
01DA 300B0002       274			SHL	R0, R0, 2
01DE 4001           275			ADD	R0, R1
01E0 0FE0           276			RET
01E2                277	
01E2                278	# UPDATE BYTE (decimal < 100)
01E2                279	# R0 = POINTER, R1 = DECIMAL DIGIT, R2 = LOW FLAG
01E2 13000000       280	UPDATE_BYTE:	LD1	R3, [R0]
01E6 34F9000A       281			LI	R4, 10
01EA 85FF           282			LI	R5, 0
01EC 23420005       283			BLT	R3, R4, .READY
01F0 5334           284	.AGAIN		SUB	R3, R4
01F2 35540001       285			ADD	R5, 1
01F6 2434FFFB       286			BLE	R4, R3, .AGAIN
01FA                287			# R5 = HI, R3 = LO
01FA 22F10003       288	.READY		BNZ	R2, .UPDLOW
01FE 95F1           289			MV	R5, R1
0200 2FF00001       290			BRA	.DONE
0204 93F1           291	.UPDLOW 	MV	R3, R1
0206 355B0001       292	.DONE		SHL	R5, R5, 1
020A 91F5           293			MV	R1, R5
020C 311B0002       294			SHL	R1, R1, 2
0210 4115           295			ADD	R1, R5
0212 4113           296			ADD	R1, R3
0214 11080000       297			ST1	[R0], R1
0218 0FE0           298			RET
021A                299	
021A                300	# HEXBYTE: dump byte in r0 in hex
021A 0FF8FFFE       301	HEXBYTE 	ENTER	-2
021E 1EFA0000       302			ST4	[SP], R14
0222 18FA0001       303			ST4	[SP + 1], R8
0226 98F0           304			MV	R8, R0
0228 300C0004       305			SHR	R0, 4
022C 3008000F       306			AND	R0, 15
0230 10001E50       307			LD1	R0, [R0 + HTAB]
0234 0FFDFFFFFF55   308			JAL	CONOUT
023A 90F8           309			MV	R0, R8
023C 3008000F       310			AND	R0, 15
0240 10001E50       311			LD1	R0, [R0 + HTAB]
0244 0FFDFFFFFF4D   312			JAL	CONOUT
024A 1EF40000       313			LD4	R14, [SP]
024E 18F40001       314			LD4	R8,  [SP + 1]
0252 0FF80002       315			ENTER	2
0256 0FE0           316			RET
0258                317	
0258                318	# HEXFULL: dump full word r0 in hex
0258 0FF8FFFE       319	HEXFULL 	ENTER	-2
025C 1EFA0000       320			ST4	[SP], R14
0260 18FA0001       321			ST4	[SP + 1], R8
0264 98F0           322			MV	R8, R0
0266 308C0018       323			SHR	R0, R8, 24
026A 0FFDFFFFFFD5   324			JAL	HEXBYTE
0270 308C0010       325			SHR	R0, R8, 16
0274 0FFDFFFFFFD0   326			JAL	HEXBYTE
027A 308C0008       327			SHR	R0, R8, 8
027E 0FFDFFFFFFCB   328			JAL	HEXBYTE
0284 90F8           329			MV	R0, R8
0286 0FFDFFFFFFC7   330			JAL	HEXBYTE
028C 1EF40000       331			LD4	R14, [SP]
0290 18F40001       332			LD4	R8,  [SP + 1]
0294 0FF80002       333			ENTER	2
0298 0FE0           334			RET
029A                335	
029A                336	# CRC32: R0 = ptr, R1 = bytes
029A 33F9FFFF       337	CRC32		LI	R3, -1
029E 0F6CEDB88320   338			LI	R6, $EDB88320
02A4 21F00016       339			BZ	R1, .DONE
02A8 12000000       340	.AGAIN		LD1	R2, [R0]
02AC 30040001       341			ADD	R0, 1
02B0 31150001       342			SUB	R1, 1
02B4 A332           343			XOR	R3, R2
02B6 34F90008       344			LI	R4, 8
02BA 35380001       345	.LOOP		AND	R5, R3, 1
02BE 55F5           346			SUB	R5, SP, R5
02C0 8556           347			AND	R5, R6
02C2 333C0001       348			SHR	R3, 1
02C6 A335           349			XOR	R3, R5
02C8 34450001       350			SUB	R4, 1
02CC 24F1FFF5       351			BNZ	R4, .LOOP
02D0 21F1FFEA       352			BNZ	R1, .AGAIN
02D4 303AFFFF       353	.DONE		XOR	R0, R3, -1
02D8 0FE0           354			RET
02DA                355	
02DA                356	#
02DA                357	# exception handler
02DA                358	#
02DA                359	EXC_HANDLER	# save frame
02DA 0F09000E       360			SET	REG_EXC_SCRATCH, R0
02DE 30F92FA0       361			LI	R0, EXC_STACK - 16 * 4
02E2 110A0001       362			ST4	[R0 +  1], R1
02E6 120A0002       363			ST4	[R0 +  2], R2
02EA 130A0003       364			ST4	[R0 +  3], R3
02EE 140A0004       365			ST4	[R0 +  4], R4
02F2 150A0005       366			ST4	[R0 +  5], R5
02F6 160A0006       367			ST4	[R0 +  6], R6
02FA 170A0007       368			ST4	[R0 +  7], R7
02FE 180A0008       369			ST4	[R0 +  8], R8
0302 190A0009       370			ST4	[R0 +  9], R9
0306 1A0A000A       371			ST4	[R0 + 10], R10
030A 1B0A000B       372			ST4	[R0 + 11], R11
030E 1C0A000C       373			ST4	[R0 + 12], R12
0312 1D0A000D       374			ST4	[R0 + 13], R13
0316 1E0A000E       375			ST4	[R0 + 14], R14
031A 1F0A000F       376			ST4	[R0 + 15], SP
031E 9FF0           377			MV	SP, R0
0320 0F08000E       378			GET	R0, REG_EXC_SCRATCH
0324 10FA0000       379			ST4	[SP], R0
0328                380	
0328 30F91EA9       381			LI	R0, EXC_HEADER
032C 0FFDFFFFFEE0   382			JAL	CONSTR
0332 0F08000C       383			GET	R0, REG_EXC_CODE
0336 0FFDFFFFFF8E   384			JAL	HEXFULL
033C 30F91EB5       385			LI	R0, EXC_MIDDLE
0340 0FFDFFFFFED6   386			JAL	CONSTR
0346 0F08000F       387			GET	R0, REG_EXC_SAVE
034A 0FFDFFFFFF84   388			JAL	HEXFULL
0350 30F91EBA       389			LI	R0, EXC_FOOTER
0354 0FFDFFFFFECC   390			JAL	CONSTR
035A                391	
035A                392			# dump registers
035A 88FF           393			LI	R8, 0
035C 99FF           394			MV	R9, SP
035E 3AF92FE0       395			LI	R10, EXC_STACK
0362                396	.LOOP		# dump register
0362 30F90020       397			LI	R0, ' '
0366 31880003       398			AND	R1, R8, 3
036A 21F10002       399			BNZ	R1, .NOLF
036E 30F9000A       400			LI	R0, LF
0372 0FFDFFFFFEB6   401	.NOLF		JAL	CONOUT
0378 30F90052       402			LI	R0, 'R'
037C 0FFDFFFFFEB1   403			JAL	CONOUT
0382 90F8           404			MV	R0, R8
0384 0FFDFFFFFF48   405			JAL	HEXBYTE
038A 30F9003D       406			LI	R0, '='
038E 0FFDFFFFFEA8   407			JAL	CONOUT
0394 10940000       408			LD4	R0, [R9]
0398 0FFDFFFFFF5D   409			JAL	HEXFULL
039E                410	
039E                411			# next
039E 38840001       412			ADD	R8, 1
03A2 39940004       413			ADD	R9, 4
03A6 29A2FFDC       414			BLT	R9, R10, .LOOP
03AA                415	
03AA                416			# notify debugger
03AA 30F900FF       417			LI	R0, DEBUG_IO
03AE 000F           418			OUT	R0, R0
03B0                419	
03B0                420			# wait forever
03B0 0FF3           421	.HALT		WAIT
03B2 2FF0FFFD       422			BRA	.HALT
03B6                423	
03B6                424	#
03B6                425	# monitor
03B6                426	#
03B6                427	MONITOR 	# zero sysvars area
03B6 30F92000       428			LI	R0, SYSVARS_START
03BA 31F92060       429			LI	R1, SYSVARS_END
03BE 82FF           430			LI	R2, 0
03C0 120A0000       431	.ZEROVARS	ST4	[R0], R2
03C4 30040004       432			ADD	R0, 4
03C8 2012FFFA       433			BLT	R0, R1, .ZEROVARS
03CC                434	
03CC                435			# setup timer
03CC 30F9000A       436			LI	R0, 10	# tens of miliseconds
03D0 31F90008       437			LI	R1, TIMER_CTRL
03D4 001F           438			OUT	R0, R1
03D6                439	
03D6                440			# init serial console
03D6                441			;LD	 A, :RTS_LOW
03D6                442			;OUT	 (:IODEV_CONSOLE), A
03D6                443	
03D6                444			# enable irqs
03D6 30F9FFFF       445			LI	R0, -1
03DA 0F090004       446			SET	REG_IRQ_MASK, R0
03DE                447	
03DE                448			# say hello
03DE 30F91D5C       449			LI	R0, HELLO
03E2 0FFDFFFFFE85   450			JAL	CONSTR
03E8                451	
03E8                452			# output menu
03E8 30F91D6B       453	MAINMENU	LI	R0, MENU
03EC 0FFDFFFFFE80   454			JAL	CONSTR
03F2                455	
03F2                456			# read option
03F2 0FFDFFFFFE9F   457			JAL	CONREADECHO
03F8                458	
03F8                459			# check option
03F8 31050030       460			SUB	R1, R0, '0'
03FC 21F0FE00       461			BZ	R1, RESET
0400 31050039       462			SUB	R1, R0, '9'
0404 21F0001F       463			BZ	R1, .ILLEGAL
0408 31050031       464			SUB	R1, R0, '1'
040C 21F00042       465			BZ	R1, DATE
0410 31050032       466			SUB	R1, R0, '2'
0414 21F00160       467			BZ	R1, MEMMON
0418 31050033       468			SUB	R1, R0, '3'
041C 21F002B5       469			BZ	R1, JFORTH
0420 31050034       470			SUB	R1, R0, '4'
0424 21F00010       471			BZ	R1, BENCH
0428 31050035       472			SUB	R1, R0, '5'
042C 21F00242       473			BZ	R1, DISKINFO
0430 3105001B       474			SUB	R1, R0, ESC
0434 21F1FFD8       475			BNZ	R1, MAINMENU
0438                476	
0438                477			# ouput space to disable esc
0438 30F91E60       478			LI	R0, ESCOFF
043C 0FFDFFFFFE58   479			JAL	CONSTR
0442 2FF0FFD1       480			BRA	MAINMENU
0446                481	
0446 0FF0           482	.ILLEGAL	ILLEGAL
0448                483	
0448                484	#
0448                485	# BENCH
0448                486	#
0448 30F91EC6       487	BENCH		LI	R0, BENCH_HEADER
044C 0FFDFFFFFE50   488			JAL	CONSTR
0452 89FF           489			LI	R9, 0
0454 19940800       490			LD4	R9, [R9 + TICK_M10 / 4]
0458 38F90064       491			LI	R8, 100
045C 80FF           492	.LOOP		LI	R0, 0
045E 31F90040       493			LI	R1, 64
0462 0FFDFFFFFF19   494			JAL	CRC32
0468 38850001       495			SUB	R8, 1
046C 28F1FFF6       496			BNZ	R8, .LOOP
0470 0FFDFFFFFEF1   497			JAL	HEXFULL
0476 88FF           498			LI	R8, 0
0478 18840800       499			LD4	R8, [R8 + TICK_M10 / 4]
047C 5889           500			SUB	R8, R9
047E 30F91EEC       501			LI	R0, BENCH_FOOTER
0482 0FFDFFFFFE35   502			JAL	CONSTR
0488 90F8           503			MV	R0, R8
048A 0FFDFFFFFEE4   504			JAL	HEXFULL
0490 2FF0FFAA       505			BRA	MAINMENU
0494                506	
0494                507	#
0494                508	# GET/SET DATE
0494                509	#
0494                510	DATE		# request date
0494 80FF           511			LI	R0, 0
0496 10082056       512			ST1	[R0 + DATE_READY], R0
049A 30F90002       513	.POLL		LI	R0, RTC_CTRL
049E 000E           514			IN	R0, R0
04A0 20F0FFFB       515			BZ	R0, .POLL
04A4 31F90003       516			LI	R1, RTC_DATA
04A8 80FF           517			LI	R0, 0
04AA 001F           518			OUT	R0, R1
04AC                519	
04AC                520			# wait response
04AC 80FF           521	.AGAIN		LI	R0, 0
04AE 10002056       522			LD1	R0, [R0 + DATE_READY]
04B2 20F10003       523			BNZ	R0, .READY
04B6 0FF3           524			WAIT
04B8 2FF0FFF8       525			BRA	.AGAIN
04BC                526	
04BC                527			# output date
04BC 89FF           528	.READY		LI	R9, 0		# cursor
04BE 30F9000A       529			LI	R0, LF
04C2 0FFDFFFFFE0E   530			JAL	CONOUT
04C8 30F91E00       531	.REFRESH	LI	R0, DATE_HEADER
04CC 0FFDFFFFFE10   532			JAL	CONSTR
04D2 38F9204E       533			LI	R8, DATE_IO
04D6 10820000       534			LD2	R0, [R8]	# year
04DA 0FFDFFFFFE5A   535			JAL	DECNUM4
04E0 10800002       536			LD1	R0, [R8 + 2]	# month
04E4 0FFDFFFFFE37   537			JAL	DECNUM2
04EA 10800003       538			LD1	R0, [R8 + 3]	# day
04EE 0FFDFFFFFE32   539			JAL	DECNUM2
04F4 30F90020       540			LI	R0, ' '
04F8 0FFDFFFFFDF3   541			JAL	CONOUT
04FE 10800004       542			LD1	R0, [R8 + 4]	# day of week
0502 30040030       543			ADD	R0, '0'
0506 0FFDFFFFFDEC   544			JAL	CONOUT
050C 30F90020       545			LI	R0, ' '
0510 0FFDFFFFFDE7   546			JAL	CONOUT
0516 10800005       547			LD1	R0, [R8 + 5]	# hour
051A 0FFDFFFFFE1C   548			JAL	DECNUM2
0520 10800006       549			LD1	R0, [R8 + 6]	# minute
0524 0FFDFFFFFE17   550			JAL	DECNUM2
052A 10800007       551			LD1	R0, [R8 + 7]	# second
052E 0FFDFFFFFE12   552			JAL	DECNUM2
0534 30F91E04       553			LI	R0, DATE_FOOTER
0538 0FFDFFFFFDDA   554			JAL	CONSTR
053E                555	
053E                556			# set cursor pos
053E 10901E31       557			LD1	R0, [R9 + DATE_COLS]
0542 0FFDFFFFFE08   558			JAL	DECNUM2
0548 30F90047       559			LI	R0, 'G'
054C 0FFDFFFFFDC9   560			JAL CONOUT
0552                561	
0552                562			# readcmd
0552 0FFDFFFFFDDD   563	.READCMD	JAL	CONREAD
0558 31050058       564			SUB	R1, R0, 'X'
055C 21F0FF44       565			BZ	R1, MAINMENU
0560 31050078       566			SUB	R1, R0, 'x'
0564 21F0FF40       567			BZ	R1, MAINMENU
0568 3105001B       568			SUB	R1, R0, ESC
056C 21F0FF3C       569			BZ	R1, MAINMENU
0570 31050009       570			SUB	R1, R0, TAB
0574 21F00088       571			BZ	R1, .NEXT
0578 31050020       572			SUB	R1, R0, ' '
057C 21F00084       573			BZ	R1, .NEXT
0580 3105000A       574			SUB	R1, R0, LF
0584 21F00089       575			BZ	R1, .CHANGE
0588 3105000D       576			SUB	R1, R0, CR
058C 21F00085       577			BZ	R1, .CHANGE
0590 31050039       578			SUB	R1, R0, '9'
0594 2F13FFDD       579			BLTI	SP, R1, .READCMD
0598 31050030       580			SUB	R1, R0, '0'
059C 21F3FFD9       581			BLTI	R1, SP, .READCMD
05A0                582	
05A0                583			# update state with new digit (R1)
05A0 32F9204E       584			LI	R2, DATE_IO
05A4 30F90008       585			LI	R0, 8
05A8 29010004       586			BNE	R9, R0, .NODOW
05AC 11280004       587			ST1	[R2 + 4], R1
05B0 2FF0006A       588			BRA	.NEXT
05B4 29020010       589	.NODOW		BLT	R9, R0, .NOTIME
05B8 30950009       590			SUB	R0, R9, 9
05BC 300C0001       591			SHR	R0, 1
05C0 4002           592			ADD	R0, R2
05C2 30040005       593			ADD	R0, 5
05C6 32980001       594			AND	R2, R9, 1
05CA 322A0001       595			XOR	R2, 1
05CE 0FFDFFFFFE07   596			JAL	UPDATE_BYTE
05D4 2FF00058       597			BRA	.NEXT
05D8 30F90004       598	.NOTIME 	LI	R0, 4
05DC 2902000D       599			BLT	R9, R0, .YEAR
05E0 5090           600			SUB	R0, R9, R0
05E2 300C0001       601			SHR	R0, 1
05E6 4020           602			ADD	R0, R2, R0
05E8 30040002       603			ADD	R0, 2
05EC 32980001       604			AND	R2, R9, 1
05F0 0FFDFFFFFDF6   605			JAL	UPDATE_BYTE
05F6 2FF00047       606			BRA	.NEXT
05FA 10220000       607	.YEAR		LD2	R0, [R2]
05FE 37F903E8       608			LI	R7, 1000
0602 83FF           609			LI	R3, 0
0604 20720005       610			BLT	R0, R7, .P1000
0608 5007           611	.A1000		SUB	R0, R7
060A 33340001       612			ADD	R3, 1
060E 2704FFFB       613			BLE	R7, R0, .A1000
0612 37F90064       614	.P1000		LI	R7, 100
0616 84FF           615			LI	R4, 0
0618 20720005       616			BLT	R0, R7, .P100
061C 5007           617	.A100		SUB	R0, R7
061E 34440001       618			ADD	R4, 1
0622 2704FFFB       619			BLE	R7, R0, .A100
0626 37F9000A       620	.P100		LI	R7, 10
062A 85FF           621			LI	R5, 0
062C 20720005       622			BLT	R0, R7, .UPDY
0630 5007           623	.A10		SUB	R0, R7
0632 35540001       624			ADD	R5, 1
0636 2704FFFB       625			BLE	R7, R0, .A10
063A 96F9           626	.UPDY		MV	R6, R9
063C 26F10003       627			BNZ	R6, .NOUPD0
0640 93F1           628			MV	R3, R1
0642 2FF0000F       629			BRA	.YBUILD
0646 36650001       630	.NOUPD0 	SUB	R6, 1
064A 26F10003       631			BNZ	R6, .NOUPD1
064E 94F1           632			MV	R4, R1
0650 2FF00008       633			BRA	.YBUILD
0654 36650001       634	.NOUPD1 	SUB	R6, 1
0658 26F10003       635			BNZ	R6, .NOUPD2
065C 95F1           636			MV	R5, R1
065E 2FF00001       637			BRA	.YBUILD
0662 90F1           638	.NOUPD2 	MV	R0, R1
0664 96F0           639	.YBUILD 	MV	R6, R0
0666 90F3           640			MV	R0, R3
0668 0FFDFFFFFDB3   641			JAL	MUL10
066E 4004           642			ADD	R0, R4
0670 0FFDFFFFFDAF   643			JAL	MUL10
0676 4005           644			ADD	R0, R5
0678 0FFDFFFFFDAB   645			JAL	MUL10
067E 4006           646			ADD	R0, R6
0680 10290000       647			ST2	[R2], R0
0684 2FF00000       648			BRA	.NEXT
0688                649	
0688                650	.NEXT		# inc cursor
0688 39940001       651			ADD	R9, 1
068C 30F9000F       652			LI	R0, 15
0690 2902FF1A       653			BLT	R9, R0, .REFRESH
0694 89FF           654			LI	R9, 0
0696 2FF0FF17       655			BRA	.REFRESH
069A                656	
069A 30F90002       657	.CHANGE 	LI	R0, RTC_CTRL
069E 000E           658			IN	R0, R0
06A0 20F0FFFB       659			BZ	R0, .CHANGE
06A4 31F90003       660			LI	R1, RTC_DATA
06A8 00F8           661			LI	R0, 1	# write cmd
06AA 001F           662			OUT	R0, R1
06AC 31F90004       663			LI	R1, RTC_WRITE
06B0 32F9204E       664			LI	R2, DATE_IO
06B4 33F90008       665			LI	R3, 8
06B8 10200000       666	.WRITE		LD1	R0, [R2]
06BC 32240001       667			ADD	R2, 1
06C0 33350001       668			SUB	R3, 1
06C4 001F           669			OUT	R0, R1
06C6 23F1FFF7       670			BNZ	R3, .WRITE
06CA 30F91E40       671			LI	R0, DATE_WRITTEN
06CE 0FFDFFFFFD0F   672			JAL	CONSTR
06D4 2FF0FE88       673			BRA	MAINMENU
06D8                674	
06D8                675	#
06D8                676	# Memory monitor
06D8                677	#
06D8 8DFF           678	MEMMON		LI	R13, 0	# base addr
06DA 3CF90004       679			LI	R12, 4	# mem lines
06DE 1DDA2004       680			ST4	[R13 + MMON_VALUE], R13
06E2 30F91E63       681	.REFRESH	LI	R0, MMON_HEADER
06E6 0FFDFFFFFD03   682			JAL	CONSTR
06EC 98FD           683			MV	R8, R13
06EE 99FC           684			MV	R9, R12
06F0                685	.NEXTLINE	# show addr
06F0 90F8           686			MV	R0, R8
06F2 0FFDFFFFFDB0   687			JAL	HEXFULL
06F8                688	
06F8                689			# hex dump
06F8 3AF90008       690			LI	R10, MLINBYTES
06FC 9BF8           691			MV	R11, R8
06FE 30F90020       692	.HEXDUMP	LI	R0, ' '
0702 0FFDFFFFFCEE   693			JAL	CONOUT
0708 10B00000       694			LD1	R0, [R11]
070C 0FFDFFFFFD84   695			JAL	HEXBYTE
0712 3BB40001       696			ADD	R11, 1
0716 3AA50001       697			SUB	R10, 1
071A 2AF1FFF0       698			BNZ	R10, .HEXDUMP
071E                699	
071E                700			# ascii dump
071E 30F90020       701			LI	R0, ' '
0722 0FFDFFFFFCDE   702			JAL	CONOUT
0728 3AF90008       703			LI	R10, MLINBYTES
072C 10800000       704	.ASCIIDUMP	LD1	R0, [R8]
0730 31F90020       705			LI	R1, ' '
0734 20120004       706			BLT	R0, R1, .MKPOINT
0738 31F90080       707			LI	R1, 128
073C 20120002       708			BLT	R0, R1, .READY
0740 30F9002E       709	.MKPOINT	LI	R0, '.'
0744 0FFDFFFFFCCD   710	.READY		JAL	CONOUT
074A 38840001       711			ADD	R8, 1
074E 3AA50001       712			SUB	R10, 1
0752 2AF1FFEB       713			BNZ	R10, .ASCIIDUMP
0756                714	
0756                715			# end of line
0756 30F9000A       716			LI	R0, LF
075A 0FFDFFFFFCC2   717			JAL	CONOUT
0760 39950001       718			SUB	R9, 1
0764 29F1FFC4       719			BNZ	R9, .NEXTLINE
0768                720	
0768                721			# dump value
0768 30F9000D       722	.PARTIAL	LI	R0, CR
076C 0FFDFFFFFCB9   723			JAL	CONOUT
0772 30F92004       724			LI	R0, MMON_VALUE
0776 10040000       725			LD4	R0, [R0]
077A 0FFDFFFFFD6C   726			JAL	HEXFULL
0780                727	
0780                728			# readcmd
0780 0FFDFFFFFCC6   729	.READCMD	JAL	CONREAD
0786 31050058       730			SUB	R1, R0, 'X'
078A 21F0FE2D       731			BZ	R1, MAINMENU
078E 31050078       732			SUB	R1, R0, 'x'
0792 21F0FE29       733			BZ	R1, MAINMENU
0796 3105001B       734			SUB	R1, R0, ESC
079A 21F0FE25       735			BZ	R1, MAINMENU
079E 31050049       736			SUB	R1, R0, 'I'
07A2 21F0005B       737			BZ	R1, .INCLINE
07A6 31050069       738			SUB	R1, R0, 'i'
07AA 21F00057       739			BZ	R1, .INCLINE
07AE 3105007A       740			SUB	R1, R0, 'z'
07B2 21F00057       741			BZ	R1, .ZEROVAL
07B6 3105005A       742			SUB	R1, R0, 'Z'
07BA 21F00053       743			BZ	R1, .ZEROVAL
07BE 3105000A       744			SUB	R1, R0, LF
07C2 21F00056       745			BZ	R1, .GOTO
07C6 3105000D       746			SUB	R1, R0, CR
07CA 21F00052       747			BZ	R1, .GOTO
07CE 31050008       748			SUB	R1, R0, BS
07D2 21F00054       749			BZ	R1, .BACK
07D6 3105007F       750			SUB	R1, R0, DEL
07DA 21F00050       751			BZ	R1, .BACK
07DE 31050052       752			SUB	R1, R0, 'R'
07E2 21F00062       753			BZ	R1, .EXEC
07E6 31050072       754			SUB	R1, R0, 'r'
07EA 21F0005E       755			BZ	R1, .EXEC
07EE 31050050       756			SUB	R1, R0, 'P'
07F2 21F0004E       757			BZ	R1, .POKE
07F6 31050070       758			SUB	R1, R0, 'p'
07FA 21F0004A       759			BZ	R1, .POKE
07FE 3105004B       760			SUB	R1, R0, 'K'
0802 21F00046       761			BZ	R1, .POKE
0806 3105006B       762			SUB	R1, R0, 'k'
080A 21F00042       763			BZ	R1, .POKE
080E 31050009       764			SUB	R1, R0, TAB
0812 21F00046       765			BZ	R1, .NEXT
0816                766	
0816                767			# hex digit ?
0816 31F90030       768			LI	R1, '0'
081A 2012FFB1       769			BLT	R0, R1, .READCMD
081E 32F90039       770			LI	R2, '9'
0822 22020003       771			BLT	R2, R0, .NODEC
0826 5001           772			SUB	R0, R1
0828 2FF0000D       773			BRA	.ADDVAL
082C 30090020       774	.NODEC		OR	R0, $20 # lowercase
0830 31F90061       775			LI	R1, 'a'
0834 2012FFA4       776			BLT	R0, R1, .READCMD
0838 32F90066       777			LI	R2, 'f'
083C 2202FFA0       778			BLT	R2, R0, .READCMD
0840 5001           779			SUB	R0, R1
0842 3004000A       780			ADD	R0, 10
0846 31F92004       781	.ADDVAL 	LI	R1, MMON_VALUE
084A 12140000       782			LD4	R2, [R1]
084E 322B0004       783			SHL	R2, 4
0852 9220           784			OR	R2, R0
0854 121A0000       785			ST4	[R1], R2
0858 2FF0FF86       786			BRA	.PARTIAL
085C                787	
085C 3CC40001       788	.INCLINE	ADD	R12, 1
0860 2FF0FF3F       789			BRA	.REFRESH
0864 31F92004       790	.ZEROVAL	LI	R1, MMON_VALUE
0868 80FF           791			LI	R0, 0
086A 101A0000       792			ST4	[R1], R0
086E 2FF0FF7B       793			BRA	.PARTIAL
0872 31F92004       794	.GOTO		LI	R1, MMON_VALUE
0876 1D140000       795			LD4	R13, [R1]
087A 2FF0FF32       796			BRA	.REFRESH
087E 31F92004       797	.BACK		LI	R1, MMON_VALUE
0882 10140000       798			LD4	R0, [R1]
0886 300C0004       799			SHR	R0, 4
088A 101A0000       800			ST4	[R1], R0
088E 2FF0FF6B       801			BRA	.PARTIAL
0892 31F92004       802	.POKE		LI	R1, MMON_VALUE
0896 10140000       803			LD4	R0, [R1]
089A 10D80000       804			ST1	[R13], R0
089E 2FF0FF20       805			BRA	.REFRESH
08A2 3DD40001       806	.NEXT		ADD	R13, 1
08A6 2FF0FF1C       807			BRA	.REFRESH
08AA 31F92004       808	.EXEC		LI	R1, MMON_VALUE
08AE 11140000       809			LD4	R1, [R1]
08B2 0F10           810			JMP	R1
08B4                811	
08B4                812	#
08B4                813	# get disk info
08B4                814	#
08B4                815	DISKINFO	# output header
08B4 30F91F01       816			LI	R0, DISK_HEADER
08B8 0FFDFFFFFC1A   817			JAL	CONSTR
08BE                818	
08BE                819			# wait ready
08BE 80FF           820			LI	R0, 0
08C0 10082057       821			ST1	[R0 + DISK_READY], R0
08C4 30F90010       822	.POLL		LI	R0, DISK_CTRL
08C8 000E           823			IN	R0, R0
08CA 20F0FFFB       824			BZ	R0, .POLL
08CE                825	
08CE                826			# send request
08CE 31F90011       827			LI	R1, DISK_CMD
08D2 80FF           828			LI	R0, DISK_CMD_INFO
08D4 001F           829			OUT	R0, R1
08D6 31F90012       830			LI	R1, DISK_ADDRHI
08DA 30F90070       831			LI	R0, IOAREA / 256
08DE 001F           832			OUT	R0, R1
08E0 31F90013       833			LI	R1, DISK_ADDRLO
08E4 80FF           834			LI	R0, IOAREA & $ff
08E6 001F           835			OUT	R0, R1
08E8                836	
08E8                837			# wait response
08E8 88FF           838			LI	R8, 0
08EA 18840800       839			LD4	R8, [R8 + TICK_M10 / 4]
08EE 38840064       840			ADD	R8, 100 # tenths of second = 10 seconds
08F2 80FF           841	.AGAIN		LI	R0, 0
08F4 10002057       842			LD1	R0, [R0 + DISK_READY]
08F8 20F1000D       843			BNZ	R0, .READY
08FC 0FF3           844			WAIT
08FE 80FF           845			LI	R0, 0
0900 10040800       846			LD4	R0, [R0 + TICK_M10 / 4]
0904 2082FFF5       847			BLT	R0, R8, .AGAIN
0908                848	
0908                849			# timeout
0908 30F91F20       850			LI	R0, DISK_TIMEOUT
090C 0FFDFFFFFBF0   851			JAL	CONSTR
0912 2FF0FD69       852			BRA	MAINMENU
0916                853	
0916                854			# DMA need cache invalidation
0916 31F97000       855	.READY		LI	R1, IOAREA
091A 0F1B0020       856			INV	R1, 32
091E                857	
091E                858			# show info
091E 81FF           859			LI	R1, 0
0920 10141C00       860			LD4	R0, [R1 + IOAREA / 4]
0924 101A0802       861			ST4	[R1 + DISK_SECTORS / 4], R0
0928 0FFDFFFFFC95   862			JAL	HEXFULL
092E 30F91F16       863			LI	R0, DISK_FOOTER
0932 0FFDFFFFFBDD   864			JAL	CONSTR
0938                865	
0938                866			# done
0938 2FF0FD56       867			BRA	MAINMENU
093C                868	
093C                869	#
093C                870	# disk io, R0 = block, R1 = CMD
093C                871	#
093C 82FF           872	DISK_IO 	LI	R2, 0
093E 12282057       873			ST1	[R2 + DISK_READY], R2
0942 32F90010       874	.POLL		LI	R2, DISK_CTRL
0946 022E           875			IN	R2, R2
0948 22F0FFFB       876			BZ	R2, .POLL
094C                877	
094C                878			# build request
094C 32F97000       879			LI	R2, IOAREA
0950 33240200       880			ADD	R3, R2, SECTOR_BYTES
0954 102A0000       881			ST4	[R2 + 0], R0	# block no
0958 132A0001       882			ST4	[R2 + 1], R3	# buffer
095C 0F2B0020       883			INV	R2, 32
0960                884	
0960                885			# send request
0960 30F90011       886			LI	R0, DISK_CMD
0964 010F           887			OUT	R1, R0
0966                888	
0966                889			# wait response
0966 80FF           890	.AGAIN		LI	R0, 0
0968 10002057       891			LD1	R0, [R0 + DISK_READY]
096C 20F10003       892			BNZ	R0, .READY
0970 0FF3           893			WAIT
0972 2FF0FFF8       894			BRA	.AGAIN
0976                895	
0976                896			# done
0976 90F3           897	.READY		MV	R0, R3
0978 0FE0           898			RET
####################### jforth.asm
097A                  1	#
097A                  2	# jonesforth.S translated to eon cpu
097A                  3	# (c) JCGV, agosto del 2022
097A                  4	#
097A                  5	
097A                  6	#
097A                  7	#	A sometimes minimal FORTH compiler and tutorial for Linux / i386 systems. -*- asm -*-
097A                  8	#	By Richard W.M. Jones <rich@annexia.org> http://annexia.org/forth
097A                  9	#	This is PUBLIC DOMAIN (see public domain release statement below).
097A                 10	#	$Id: jonesforth.S,v 1.47 2009-09-11 08:33:13 rich Exp $
097A                 11	#
097A                 12	#	gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
097A                 13	#
097A = 0000.002F     14	JONES_VERSION	.EQU	47
097A                 15	
097A                 16	#	INTRODUCTION ----------------------------------------------------------------------
097A                 17	#
097A                 18	#	FORTH is one of those alien languages which most working programmers regard in the same
097A                 19	#	way as Haskell, LISP, and so on.  Something so strange that they'd rather any thoughts
097A                 20	#	of it just go away so they can get on with writing this paying code.  But that's wrong
097A                 21	#	and if you care at all about programming then you should at least understand all these
097A                 22	#	languages, even if you will never use them.
097A                 23	
097A                 24	#	LISP is the ultimate high-level language, and features from LISP are being added every
097A                 25	#	decade to the more common languages.  But FORTH is in some ways the ultimate in low level
097A                 26	#	programming.  Out of the box it lacks features like dynamic memory management and even
097A                 27	#	strings.  In fact, at its primitive level it lacks even basic concepts like IF-statements
097A                 28	#	and loops.
097A                 29	
097A                 30	#	Why then would you want to learn FORTH?  There are several very good reasons.  First
097A                 31	#	and foremost, FORTH is minimal.  You really can write a complete FORTH in, say, 2000
097A                 32	#	lines of code.	I don't just mean a FORTH program, I mean a complete FORTH operating
097A                 33	#	system, environment and language.  You could boot such a FORTH on a bare PC and it would
097A                 34	#	come up with a prompt where you could start doing useful work.	The FORTH you have here
097A                 35	#	isn't minimal and uses a Linux process as its 'base PC' (both for the purposes of making
097A                 36	#	it a good tutorial). It's possible to completely understand the system.  Who can say they
097A                 37	#	completely understand how Linux works, or gcc?
097A                 38	
097A                 39	#	Secondly FORTH has a peculiar bootstrapping property.  By that I mean that after writing
097A                 40	#	a little bit of assembly to talk to the hardware and implement a few primitives, all the
097A                 41	#	rest of the language and compiler is written in FORTH itself.  Remember I said before
097A                 42	#	that FORTH lacked IF-statements and loops?  Well of course it doesn't really because
097A                 43	#	such a lanuage would be useless, but my point was rather that IF-statements and loops are
097A                 44	#	written in FORTH itself.
097A                 45	
097A                 46	#	Now of course this is common in other languages as well, and in those languages we call
097A                 47	#	them 'libraries'.  For example in C, 'printf' is a library function written in C.  But
097A                 48	#	in FORTH this goes way beyond mere libraries.  Can you imagine writing C's 'if' in C?
097A                 49	#	And that brings me to my third reason: If you can write 'if' in FORTH, then why restrict
097A                 50	#	yourself to the usual if/while/for/switch constructs?  You want a construct that iterates
097A                 51	#	over every other element in a list of numbers?	You can add it to the language.  What
097A                 52	#	about an operator which pulls in variables directly from a configuration file and makes
097A                 53	#	them available as FORTH variables?  Or how about adding Makefile-like dependencies to
097A                 54	#	the language?  No problem in FORTH.  How about modifying the FORTH compiler to allow
097A                 55	#	complex inlining strategies -- simple.	This concept isn't common in programming languages,
097A                 56	#	but it has a name (in fact two names): "macros" (by which I mean LISP-style macros, not
097A                 57	#	the lame C preprocessor) and "domain specific languages" (DSLs).
097A                 58	
097A                 59	#	This tutorial isn't about learning FORTH as the language.  I'll point you to some references
097A                 60	#	you should read if you're not familiar with using FORTH.  This tutorial is about how to
097A                 61	#	write FORTH.  In fact, until you understand how FORTH is written, you'll have only a very
097A                 62	#	superficial understanding of how to use it.
097A                 63	
097A                 64	#	So if you're not familiar with FORTH or want to refresh your memory here are some online
097A                 65	#	references to read:
097A                 66	
097A                 67	#	http://en.wikipedia.org/wiki/Forth_%28programming_language%29
097A                 68	#	http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm
097A                 69	#	http://wiki.laptop.org/go/Forth_Lessons
097A                 70	#	http://www.albany.net/~hello/simple.htm
097A                 71	#	Here is another "Why FORTH?" essay: http://www.jwdt.com/~paysan/why-forth.html
097A                 72	#	Discussion and criticism of this FORTH here: http://lambda-the-ultimate.org/node/2452
097A                 73	
097A                 74	#	ACKNOWLEDGEMENTS ----------------------------------------------------------------------
097A                 75	
097A                 76	#	This code draws heavily on the design of LINA FORTH (http://home.hccnet.nl/a.w.m.van.der.horst/lina.html)
097A                 77	#	by Albert van der Horst.  Any similarities in the code are probably not accidental.
097A                 78	
097A                 79	#	Some parts of this FORTH are also based on this IOCCC entry from 1992:
097A                 80	#	http://ftp.funet.fi/pub/doc/IOCCC/1992/buzzard.2.design.
097A                 81	#	I was very proud when Sean Barrett, the original author of the IOCCC entry, commented in the LtU thread
097A                 82	#	http://lambda-the-ultimate.org/node/2452#comment-36818 about this FORTH.
097A                 83	
097A                 84	#	And finally I'd like to acknowledge the (possibly forgotten?) authors of ARTIC FORTH because their
097A                 85	#	original program which I still have on original cassette tape kept nagging away at me all these years.
097A                 86	#	http://en.wikipedia.org/wiki/Artic_Software
097A                 87	
097A                 88	#	PUBLIC DOMAIN ----------------------------------------------------------------------
097A                 89	
097A                 90	#	I, the copyright holder of this work, hereby release it into the public domain. This applies worldwide.
097A                 91	
097A                 92	#	In case this is not legally possible, I grant any entity the right to use this work for any purpose,
097A                 93	#	without any conditions, unless such conditions are required by law.
097A                 94	
097A                 95	#	SETTING UP ----------------------------------------------------------------------
097A                 96	
097A                 97	#	Let's get a few housekeeping things out of the way.  Firstly because I need to draw lots of
097A                 98	#	ASCII-art diagrams to explain concepts, the best way to look at this is using a window which
097A                 99	#	uses a fixed width font and is at least this wide:
097A                100	
097A                101	#<------------------------------------------------------------------------------------------------------------------------>
097A                102	
097A                103	#	Secondly make sure TABS are set to 8 characters.  The following should be a vertical
097A                104	#	line.  If not, sort out your tabs.
097A                105	
097A                106	#		|
097A                107	#		|
097A                108	#		|
097A                109	
097A                110	#	Thirdly I assume that your screen is at least 50 characters high.
097A                111	
097A                112	#	ASSEMBLING ----------------------------------------------------------------------
097A                113	
097A                114	#	If you want to actually run this FORTH, rather than just read it, you will need Linux on an
097A                115	#	i386.  Linux because instead of programming directly to the hardware on a bare PC which I
097A                116	#	could have done, I went for a simpler tutorial by assuming that the 'hardware' is a Linux
097A                117	#	process with a few basic system calls (read, write and exit and that's about all).  i386
097A                118	#	is needed because I had to write the assembly for a processor, and i386 is by far the most
097A                119	#	common.  (Of course when I say 'i386', any 32- or 64-bit x86 processor will do.  I'm compiling
097A                120	#	this on a 64 bit AMD Opteron).
097A                121	
097A                122	#	Again, to assemble this you will need gcc and gas (the GNU assembler).	The commands to
097A                123	#	assemble and run the code (save this file as 'jonesforth.S') are:
097A                124	
097A                125	#	gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
097A                126	#	cat jonesforth.f - | ./jonesforth
097A                127	
097A                128	#	If you want to run your own FORTH programs you can do:
097A                129	
097A                130	#	cat jonesforth.f myprog.f | ./jonesforth
097A                131	
097A                132	#	If you want to load your own FORTH code and then continue reading user commands, you can do:
097A                133	
097A                134	#	cat jonesforth.f myfunctions.f - | ./jonesforth
097A                135	
097A                136	#	ASSEMBLER ----------------------------------------------------------------------
097A                137	
097A                138	#	(You can just skip to the next section -- you don't need to be able to read assembler to
097A                139	#	follow this tutorial).
097A                140	
097A                141	#	However if you do want to read the assembly code here are a few notes about gas (the GNU assembler):
097A                142	
097A                143	#	(1) Register names are prefixed with '%', so %eax is the 32 bit i386 accumulator.  The registers
097A                144	#	    available on i386 are: %eax, %ebx, %ecx, %edx, %esi, %edi, %ebp and %esp, and most of them
097A                145	#	    have special purposes.
097A                146	
097A                147	#	(2) Add, mov, etc. take arguments in the form SRC,DEST.  So mov %eax,%ecx moves %eax -> %ecx
097A                148	
097A                149	#	(3) Constants are prefixed with '$', and you mustn't forget it!  If you forget it then it
097A                150	#	    causes a read from memory instead, so:
097A                151	#	    mov $2,%eax 	moves number 2 into %eax
097A                152	#	    mov 2,%eax		reads the 32 bit word from address 2 into %eax (ie. most likely a mistake)
097A                153	
097A                154	#	(4) gas has a funky syntax for local labels, where '1f' (etc.) means label '1:' "forwards"
097A                155	#	    and '1b' (etc.) means label '1:' "backwards".  Notice that these labels might be mistaken
097A                156	#	    for hex numbers (eg. you might confuse 1b with $0x1b).
097A                157	
097A                158	#	(5) 'ja' is "jump if above", 'jb' for "jump if below", 'je' "jump if equal" etc.
097A                159	
097A                160	#	(6) gas has a reasonably nice .macro syntax, and I use them a lot to make the code shorter and
097A                161	#	    less repetitive.
097A                162	
097A                163	#	For more help reading the assembler, do "info gas" at the Linux prompt.
097A                164	
097A                165	#	Now the tutorial starts in earnest.
097A                166	
097A                167	#	THE DICTIONARY ----------------------------------------------------------------------
097A                168	
097A                169	#	In FORTH as you will know, functions are called "words", and just as in other languages they
097A                170	#	have a name and a definition.  Here are two FORTH words:
097A                171	
097A                172	#	: DOUBLE DUP + ;		\ name is "DOUBLE", definition is "DUP +"
097A                173	#	: QUADRUPLE DOUBLE DOUBLE ;	\ name is "QUADRUPLE", definition is "DOUBLE DOUBLE"
097A                174	
097A                175	#	Words, both built-in ones and ones which the programmer defines later, are stored in a dictionary
097A                176	#	which is just a linked list of dictionary entries.
097A                177	
097A                178	#	<--- DICTIONARY ENTRY (HEADER) ----------------------->
097A                179	#	+------------------------+--------+---------- - - - - +----------- - - - -
097A                180	#	| LINK POINTER		 | LENGTH/| NAME	      | DEFINITION
097A                181	#	|			 | FLAGS  |		      |
097A                182	#	+--- (4 bytes) ----------+- byte -+- n bytes  - - - - +----------- - - - -
097A                183	
097A                184	#	I'll come to the definition of the word later.	For now just look at the header.  The first
097A                185	#	4 bytes are the link pointer.  This points back to the previous word in the dictionary, or, for
097A                186	#	the first word in the dictionary it is just a NULL pointer.  Then comes a length/flags byte.
097A                187	#	The length of the word can be up to 31 characters (5 bits used) and the top three bits are used
097A                188	#	for various flags which I'll come to later.  This is followed by the name itself, and in this
097A                189	#	implementation the name is rounded up to a multiple of 4 bytes by padding it with zero bytes.
097A                190	#	That's just to ensure that the definition starts on a 32 bit boundary.
097A                191	
097A                192	#	A FORTH variable called LATEST contains a pointer to the most recently defined word, in
097A                193	#	other words, the head of this linked list.
097A                194	
097A                195	#	DOUBLE and QUADRUPLE might look like this:
097A                196	
097A                197	#	  pointer to previous word
097A                198	#	   ^
097A                199	#	   |
097A                200	#	+--|------+---+---+---+---+---+---+---+---+------------- - - - -
097A                201	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | (definition ...)
097A                202	#	+---------+---+---+---+---+---+---+---+---+------------- - - - -
097A                203	#	   ^	   len			       padding
097A                204	#	   |
097A                205	#	+--|------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
097A                206	#	| LINK	  | 9 | Q | U | A | D | R | U | P | L | E | 0 | 0 | (definition ...)
097A                207	#	+---------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
097A                208	#	   ^	   len					   padding
097A                209	#	   |
097A                210	#	   |
097A                211	#	  LATEST
097A                212	
097A                213	#	You should be able to see from this how you might implement functions to find a word in
097A                214	#	the dictionary (just walk along the dictionary entries starting at LATEST and matching
097A                215	#	the names until you either find a match or hit the NULL pointer at the end of the dictionary);
097A                216	#	and add a word to the dictionary (create a new definition, set its LINK to LATEST, and set
097A                217	#	LATEST to point to the new word).  We'll see precisely these functions implemented in
097A                218	#	assembly code later on.
097A                219	
097A                220	#	One interesting consequence of using a linked list is that you can redefine words, and
097A                221	#	a newer definition of a word overrides an older one.  This is an important concept in
097A                222	#	FORTH because it means that any word (even "built-in" or "standard" words) can be
097A                223	#	overridden with a new definition, either to enhance it, to make it faster or even to
097A                224	#	disable it.  However because of the way that FORTH words get compiled, which you'll
097A                225	#	understand below, words defined using the old definition of a word continue to use
097A                226	#	the old definition.  Only words defined after the new definition use the new definition.
097A                227	
097A                228	#	DIRECT THREADED CODE ----------------------------------------------------------------------
097A                229	
097A                230	#	Now we'll get to the really crucial bit in understanding FORTH, so go and get a cup of tea
097A                231	#	or coffee and settle down.  It's fair to say that if you don't understand this section, then you
097A                232	#	won't "get" how FORTH works, and that would be a failure on my part for not explaining it well.
097A                233	#	So if after reading this section a few times you don't understand it, please email me
097A                234	#	(rich@annexia.org).
097A                235	
097A                236	#	Let's talk first about what "threaded code" means.  Imagine a peculiar version of C where
097A                237	#	you are only allowed to call functions without arguments.  (Don't worry for now that such a
097A                238	#	language would be completely useless!)	So in our peculiar C, code would look like this:
097A                239	
097A                240	#	f ()
097A                241	#	{
097A                242	#	  a ();
097A                243	#	  b ();
097A                244	#	  c ();
097A                245	#	}
097A                246	
097A                247	#	and so on.  How would a function, say 'f' above, be compiled by a standard C compiler?
097A                248	#	Probably into assembly code like this.	On the right hand side I've written the actual
097A                249	#	i386 machine code.
097A                250	
097A                251	#	f:
097A                252	#	  CALL a			E8 08 00 00 00
097A                253	#	  CALL b			E8 1C 00 00 00
097A                254	#	  CALL c			E8 2C 00 00 00
097A                255	#	  ; ignore the return from the function for now
097A                256	
097A                257	#	"E8" is the x86 machine code to "CALL" a function.  In the first 20 years of computing
097A                258	#	memory was hideously expensive and we might have worried about the wasted space being used
097A                259	#	by the repeated "E8" bytes.  We can save 20% in code size (and therefore, in expensive memory)
097A                260	#	by compressing this into just:
097A                261	
097A                262	#	08 00 00 00		Just the function addresses, without
097A                263	#	1C 00 00 00		the CALL prefix.
097A                264	#	2C 00 00 00
097A                265	
097A                266	#	On a 16-bit machine like the ones which originally ran FORTH the savings are even greater - 33%.
097A                267	
097A                268	#	[Historical note: If the execution model that FORTH uses looks strange from the following
097A                269	#	paragraphs, then it was motivated entirely by the need to save memory on early computers.
097A                270	#	This code compression isn't so important now when our machines have more memory in their L1
097A                271	#	caches than those early computers had in total, but the execution model still has some
097A                272	#	useful properties].
097A                273	
097A                274	#	Of course this code won't run directly on the CPU any more.  Instead we need to write an
097A                275	#	interpreter which takes each set of bytes and calls it.
097A                276	
097A                277	#	On an i386 machine it turns out that we can write this interpreter rather easily, in just
097A                278	#	two assembly instructions which turn into just 3 bytes of machine code.  Let's store the
097A                279	#	pointer to the next word to execute in the %esi register:
097A                280	
097A                281	#		08 00 00 00	<- We're executing this one now.  %esi is the _next_ one to execute.
097A                282	#	%esi -> 1C 00 00 00
097A                283	#		2C 00 00 00
097A                284	
097A                285	#	The all-important i386 instruction is called LODSL (or in Intel manuals, LODSW).  It does
097A                286	#	two things.  Firstly it reads the memory at %esi into the accumulator (%eax).  Secondly it
097A                287	#	increments %esi by 4 bytes.  So after LODSL, the situation now looks like this:
097A                288	
097A                289	#		08 00 00 00	<- We're still executing this one
097A                290	#		1C 00 00 00	<- %eax now contains this address (0x0000001C)
097A                291	#	%esi -> 2C 00 00 00
097A                292	
097A                293	#	Now we just need to jump to the address in %eax.  This is again just a single x86 instruction
097A                294	#	written JMP *(%eax).  And after doing the jump, the situation looks like:
097A                295	
097A                296	#		08 00 00 00
097A                297	#		1C 00 00 00	<- Now we're executing this subroutine.
097A                298	#	%esi -> 2C 00 00 00
097A                299	
097A                300	#	To make this work, each subroutine is followed by the two instructions 'LODSL; JMP *(%eax)'
097A                301	#	which literally make the jump to the next subroutine.
097A                302	
097A                303	#	And that brings us to our first piece of actual code!  Well, it's a macro.
097A                304	#
097A                305	
097A                306	#	.macro NEXT
097A                307	#	lodsl
097A                308	#	jmp *(%eax)
097A                309	#	.endm
097A                310	#EON#	R12 = ESI, R0 = EAX
097A                311	#EON#	ld4	r0, [r12]
097A                312	#EON#	add	4, r12
097A                313	#EON#	ld4	r1, [r0]
097A                314	#EON#	jmp	r1
097A                315	
097A                316	#	The macro is called NEXT.  That's a FORTH-ism.	It expands to those two instructions.
097A                317	
097A                318	#	Every FORTH primitive that we write has to be ended by NEXT.  Think of it kind of like
097A                319	#	a return.
097A                320	
097A                321	#	The above describes what is known as direct threaded code.
097A                322	
097A                323	#	To sum up: We compress our function calls down to a list of addresses and use a somewhat
097A                324	#	magical macro to act as a "jump to next function in the list".	We also use one register (%esi)
097A                325	#	to act as a kind of instruction pointer, pointing to the next function in the list.
097A                326	
097A                327	#	I'll just give you a hint of what is to come by saying that a FORTH definition such as:
097A                328	
097A                329	#	: QUADRUPLE DOUBLE DOUBLE ;
097A                330	
097A                331	#	actually compiles (almost, not precisely but we'll see why in a moment) to a list of
097A                332	#	function addresses for DOUBLE, DOUBLE and a special function called EXIT to finish off.
097A                333	
097A                334	#	At this point, REALLY EAGLE-EYED ASSEMBLY EXPERTS are saying "JONES, YOU'VE MADE A MISTAKE!".
097A                335	
097A                336	#	I lied about JMP *(%eax).
097A                337	
097A                338	#	INDIRECT THREADED CODE ----------------------------------------------------------------------
097A                339	
097A                340	#	It turns out that direct threaded code is interesting but only if you want to just execute
097A                341	#	a list of functions written in assembly language.  So QUADRUPLE would work only if DOUBLE
097A                342	#	was an assembly language function.  In the direct threaded code, QUADRUPLE would look like:
097A                343	
097A                344	#		+------------------+
097A                345	#		| addr of DOUBLE  --------------------> (assembly code to do the double)
097A                346	#		+------------------+			NEXT
097A                347	#	%esi -> | addr of DOUBLE   |
097A                348	#		+------------------+
097A                349	
097A                350	#	We can add an extra indirection to allow us to run both words written in assembly language
097A                351	#	(primitives written for speed) and words written in FORTH themselves as lists of addresses.
097A                352	
097A                353	#	The extra indirection is the reason for the brackets in JMP *(%eax).
097A                354	
097A                355	#	Let's have a look at how QUADRUPLE and DOUBLE really look in FORTH:
097A                356	
097A                357	#		: QUADRUPLE DOUBLE DOUBLE ;
097A                358	
097A                359	#		+------------------+
097A                360	#		| codeword	   |		   : DOUBLE DUP + ;
097A                361	#		+------------------+
097A                362	#		| addr of DOUBLE  ---------------> +------------------+
097A                363	#		+------------------+		   | codeword	      |
097A                364	#		| addr of DOUBLE   |		   +------------------+
097A                365	#		+------------------+		   | addr of DUP   --------------> +------------------+
097A                366	#		| addr of EXIT	   |		   +------------------+ 	   | codeword	   -------+
097A                367	#		+------------------+	   %esi -> | addr of +	   --------+	   +------------------+   |
097A                368	#						   +------------------+    |	   | assembly to    <-----+
097A                369	#						   | addr of EXIT     |    |	   | implement DUP    |
097A                370	#						   +------------------+    |	   |	..	      |
097A                371	#									   |	   |	..	      |
097A                372	#									   |	   | NEXT	      |
097A                373	#									   |	   +------------------+
097A                374	#									   |
097A                375	#									   +-----> +------------------+
097A                376	#										   | codeword	   -------+
097A                377	#										   +------------------+   |
097A                378	#										   | assembly to   <------+
097A                379	#										   | implement +      |
097A                380	#										   |	..	      |
097A                381	#										   |	..	      |
097A                382	#										   | NEXT	      |
097A                383	#										   +------------------+
097A                384	
097A                385	#	This is the part where you may need an extra cup of tea/coffee/favourite caffeinated
097A                386	#	beverage.  What has changed is that I've added an extra pointer to the beginning of
097A                387	#	the definitions.  In FORTH this is sometimes called the "codeword".  The codeword is
097A                388	#	a pointer to the interpreter to run the function.  For primitives written in
097A                389	#	assembly language, the "interpreter" just points to the actual assembly code itself.
097A                390	#	They don't need interpreting, they just run.
097A                391	
097A                392	#	In words written in FORTH (like QUADRUPLE and DOUBLE), the codeword points to an interpreter
097A                393	#	function.
097A                394	
097A                395	#	I'll show you the interpreter function shortly, but let's recall our indirect
097A                396	#	JMP *(%eax) with the "extra" brackets.	Take the case where we're executing DOUBLE
097A                397	#	as shown, and DUP has been called.  Note that %esi is pointing to the address of +
097A                398	
097A                399	#	The assembly code for DUP eventually does a NEXT.  That:
097A                400	
097A                401	#	(1) reads the address of + into %eax		%eax points to the codeword of +
097A                402	#	(2) increments %esi by 4
097A                403	#	(3) jumps to the indirect %eax			jumps to the address in the codeword of +,
097A                404	#							ie. the assembly code to implement +
097A                405	
097A                406	#		+------------------+
097A                407	#		| codeword	   |
097A                408	#		+------------------+
097A                409	#		| addr of DOUBLE  ---------------> +------------------+
097A                410	#		+------------------+		   | codeword	      |
097A                411	#		| addr of DOUBLE   |		   +------------------+
097A                412	#		+------------------+		   | addr of DUP   --------------> +------------------+
097A                413	#		| addr of EXIT	   |		   +------------------+ 	   | codeword	   -------+
097A                414	#		+------------------+		   | addr of +	   --------+	   +------------------+   |
097A                415	#						   +------------------+    |	   | assembly to    <-----+
097A                416	#					   %esi -> | addr of EXIT     |    |	   | implement DUP    |
097A                417	#						   +------------------+    |	   |	..	      |
097A                418	#									   |	   |	..	      |
097A                419	#									   |	   | NEXT	      |
097A                420	#									   |	   +------------------+
097A                421	#									   |
097A                422	#									   +-----> +------------------+
097A                423	#										   | codeword	   -------+
097A                424	#										   +------------------+   |
097A                425	#									now we're  | assembly to    <-----+
097A                426	#									executing  | implement +      |
097A                427	#									this	   |	..	      |
097A                428	#									function   |	..	      |
097A                429	#										   | NEXT	      |
097A                430	#										   +------------------+
097A                431	
097A                432	#	So I hope that I've convinced you that NEXT does roughly what you'd expect.  This is
097A                433	#	indirect threaded code.
097A                434	
097A                435	#	I've glossed over four things.	I wonder if you can guess without reading on what they are?
097A                436	
097A                437	#	.
097A                438	#	.
097A                439	#	.
097A                440	
097A                441	#	My list of four things are: (1) What does "EXIT" do?  (2) which is related to (1) is how do
097A                442	#	you call into a function, ie. how does %esi start off pointing at part of QUADRUPLE, but
097A                443	#	then point at part of DOUBLE.  (3) What goes in the codeword for the words which are written
097A                444	#	in FORTH?  (4) How do you compile a function which does anything except call other functions
097A                445	#	ie. a function which contains a number like : DOUBLE 2 * ; ?
097A                446	
097A                447	#	THE INTERPRETER AND RETURN STACK ------------------------------------------------------------
097A                448	
097A                449	#	Going at these in no particular order, let's talk about issues (3) and (2), the interpreter
097A                450	#	and the return stack.
097A                451	
097A                452	#	Words which are defined in FORTH need a codeword which points to a little bit of code to
097A                453	#	give them a "helping hand" in life.  They don't need much, but they do need what is known
097A                454	#	as an "interpreter", although it doesn't really "interpret" in the same way that, say,
097A                455	#	Java bytecode used to be interpreted (ie. slowly).  This interpreter just sets up a few
097A                456	#	machine registers so that the word can then execute at full speed using the indirect
097A                457	#	threaded model above.
097A                458	
097A                459	#	One of the things that needs to happen when QUADRUPLE calls DOUBLE is that we save the old
097A                460	#	%esi ("instruction pointer") and create a new one pointing to the first word in DOUBLE.
097A                461	#	Because we will need to restore the old %esi at the end of DOUBLE (this is, after all, like
097A                462	#	a function call), we will need a stack to store these "return addresses" (old values of %esi).
097A                463	
097A                464	#	As you will have seen in the background documentation, FORTH has two stacks, an ordinary
097A                465	#	stack for parameters, and a return stack which is a bit more mysterious.  But our return
097A                466	#	stack is just the stack I talked about in the previous paragraph, used to save %esi when
097A                467	#	calling from a FORTH word into another FORTH word.
097A                468	
097A                469	#	In this FORTH, we are using the normal stack pointer (%esp) for the parameter stack.
097A                470	#	We will use the i386's "other" stack pointer (%ebp, usually called the "frame pointer")
097A                471	#	for our return stack.
097A                472	#EON#	SP = parameter stack, R13 = return stack, R12 = ESI, R0 = EAX
097A                473	
097A                474	#	I've got two macros which just wrap up the details of using %ebp for the return stack.
097A                475	#	You use them as for example "PUSHRSP %eax" (push %eax on the return stack) or "POPRSP %ebx"
097A                476	#	(pop top of return stack into %ebx).
097A                477	
097A                478	
097A                479	# Macros to deal with the return stack.
097A                480	#	.macro PUSHRSP reg
097A                481	#	lea -4(%ebp),%ebp	// push reg on to return stack
097A                482	#	movl \reg,(%ebp)
097A                483	#	.endm
097A                484	#EON#	sub	r13, 4
097A                485	#EON#	st4	[r13], r0
097A                486	
097A                487	#	.macro POPRSP reg
097A                488	#	mov (%ebp),\reg 	// pop top of return stack to reg
097A                489	#	lea 4(%ebp),%ebp
097A                490	#	.endm
097A                491	#EON#	ld4	reg, [r13]
097A                492	#EON#	add	r13, 4
097A                493	
097A                494	#	And with that we can now talk about the interpreter.
097A                495	
097A                496	#	In FORTH the interpreter function is often called DOCOL (I think it means "DO COLON" because
097A                497	#	all FORTH definitions start with a colon, as in : DOUBLE DUP + ;
097A                498	
097A                499	#	The "interpreter" (it's not really "interpreting") just needs to push the old %esi on the
097A                500	#	stack and set %esi to the first word in the definition.  Remember that we jumped to the
097A                501	#	function using JMP *(%eax)?  Well a consequence of that is that conveniently %eax contains
097A                502	#	the address of this codeword, so just by adding 4 to it we get the address of the first
097A                503	#	data word.  Finally after setting up %esi, it just does NEXT which causes that first word
097A                504	#	to run.
097A                505	
097A                506	# DOCOL - the interpreter!
097A 3DD50004       507	DOCOL		SUB	R13, 4
097E 1CDA0000       508			ST4	[R13], R12	; push %esi on to the return stack
0982 3C040004       509			ADD	R12, R0, 4	; %eax points to codeword, make %esi point to first data word
0986 2FF0001E       510			BRA	NEXT
098A                511	
098A                512	#	Just to make this absolutely clear, let's see how DOCOL works when jumping from QUADRUPLE
098A                513	#	into DOUBLE:
098A                514	
098A                515	#		QUADRUPLE:
098A                516	#		+------------------+
098A                517	#		| codeword	   |
098A                518	#		+------------------+		   DOUBLE:
098A                519	#		| addr of DOUBLE  ---------------> +------------------+
098A                520	#		+------------------+	   %eax -> | addr of DOCOL    |
098A                521	#	%esi -> | addr of DOUBLE   |		   +------------------+
098A                522	#		+------------------+		   | addr of DUP      |
098A                523	#		| addr of EXIT	   |		   +------------------+
098A                524	#		+------------------+		   | etc.	      |
098A                525	
098A                526	#	First, the call to DOUBLE calls DOCOL (the codeword of DOUBLE).  DOCOL does this:  It
098A                527	#	pushes the old %esi on the return stack.  %eax points to the codeword of DOUBLE, so we
098A                528	#	just add 4 on to it to get our new %esi:
098A                529	
098A                530	#		 QUADRUPLE:
098A                531	#		 +------------------+
098A                532	#		 | codeword	    |
098A                533	#		 +------------------+		    DOUBLE:
098A                534	#		 | addr of DOUBLE  ---------------> +------------------+
098A                535	#top of return	 +------------------+	    %eax -> | addr of DOCOL    |
098A                536	#stack points -> | addr of DOUBLE   |	    + 4 =   +------------------+
098A                537	#		 +------------------+	    %esi -> | addr of DUP      |
098A                538	#		 | addr of EXIT     |		    +------------------+
098A                539	#		 +------------------+		    | etc.	       |
098A                540	
098A                541	#	Then we do NEXT, and because of the magic of threaded code that increments %esi again
098A                542	#	and calls DUP.
098A                543	
098A                544	#	Well, it seems to work.
098A                545	
098A                546	#	One minor point here.  Because DOCOL is the first bit of assembly actually to be defined
098A                547	#	in this file (the others were just macros), and because I usually compile this code with the
098A                548	#	text segment starting at address 0, DOCOL has address 0.  So if you are disassembling the
098A                549	#	code and see a word with a codeword of 0, you will immediately know that the word is
098A                550	#	written in FORTH (it's not an assembler primitive) and so uses DOCOL as the interpreter.
098A                551	#EON#	not true DOCOL has address 0 ! (it resides in ROM)
098A                552	
098A                553	#	STARTING UP ----------------------------------------------------------------------
098A                554	
098A                555	#	Now let's get down to nuts and bolts.  When we start the program we need to set up
098A                556	#	a few things like the return stack.  But as soon as we can, we want to jump into FORTH
098A                557	#	code (albeit much of the "early" FORTH code will still need to be written as
098A                558	#	assembly language primitives).
098A                559	
098A                560	#	This is what the set up code does.  Does a tiny bit of house-keeping, sets up the
098A                561	#	separate return stack (NB: Linux gives us the ordinary parameter stack already), then
098A                562	#	immediately jumps to a FORTH word called QUIT.	Despite its name, QUIT doesn't quit
098A                563	#	anything.  It resets some internal state and starts reading and interpreting commands.
098A                564	#	(The reason it is called QUIT is because you can call QUIT from your own FORTH code
098A                565	#	to "quit" your program and go back to interpreting).
098A                566	
098A 80FF           567	JFORTH		LI	R0, 0		; setup forth vars
098C 100A0803       568			ST4	[R0 + FORTH_STATE / 4], R0
0990 31F9000A       569			LI	R1, 10
0994 110A0806       570			ST4	[R0 + FORTH_BASE / 4], R1
0998 31F91D44       571			LI	R1, F_INTERPRET
099C 110A0805       572			ST4	[R0 + FORTH_LATEST / 4], R1
09A0 3DF94000       573			LI	R13, RSTACK
09A4 1D0A0804       574			ST4	[R0 + FORTH_HERE / 4], R13
09A8 30F91DDE       575			LI	R0, FORTH_HELLO ; say hello
09AC 0FFDFFFFFBA0   576			JAL	CONSTR
09B2 3CF91D58       577			LI	R12, W_QUIT	; jump interpreter
09B6 2FF00006       578			BRA	NEXT
09BA                579	
09BA 30F92F60       580	C_BYE		LI	R0, SYS_STACK
09BE 9FF0           581			MV	SP, R0
09C0 0FFCFFFFFD11   582			JMP	MAINMENU
09C6                583	
09C6                584	
09C6                585	#	BUILT-IN WORDS ----------------------------------------------------------------------
09C6                586	
09C6                587	#	Remember our dictionary entries (headers)?  Let's bring those together with the codeword
09C6                588	#	and data words to see how : DOUBLE DUP + ; really looks in memory.
09C6                589	
09C6                590	#	  pointer to previous word
09C6                591	#	   ^
09C6                592	#	   |
09C6                593	#	+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
09C6                594	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
09C6                595	#	+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
09C6                596	#	   ^	   len			       pad  codeword	  |
09C6                597	#	   |							  V
09C6                598	#	  LINK in next word				points to codeword of DUP
09C6                599	
09C6                600	#	Initially we can't just write ": DOUBLE DUP + ;" (ie. that literal string) here because we
09C6                601	#	don't yet have anything to read the string, break it up at spaces, parse each word, etc. etc.
09C6                602	#	So instead we will have to define built-in words using the GNU assembler data constructors
09C6                603	#	(like .int, .byte, .string, .ascii and so on -- look them up in the gas info page if you are
09C6                604	#	unsure of them).
09C6                605	
09C6                606	#	The long way would be:
09C6                607	
09C6                608	#	.int <link to previous word>
09C6                609	#	.byte 6 		// len
09C6                610	#	.ascii "DOUBLE" 	// string
09C6                611	#	.byte 0 		// padding
09C6                612	#DOUBLE:.int DOCOL		// codeword
09C6                613	#	.int DUP		// pointer to codeword of DUP
09C6                614	#	.int PLUS		// pointer to codeword of +
09C6                615	#	.int EXIT		// pointer to codeword of EXIT
09C6                616	
09C6                617	#	That's going to get quite tedious rather quickly, so here I define an assembler macro
09C6                618	#	so that I can just write:
09C6                619	
09C6                620	#	defword "DOUBLE",6,,DOUBLE
09C6                621	#	.int DUP,PLUS,EXIT
09C6                622	
09C6                623	#	and I'll get exactly the same effect.
09C6                624	
09C6                625	#	Don't worry too much about the exact implementation details of this macro - it's complicated!
09C6                626	
09C6                627	# Flags - these are discussed later.
09C6                628	#	.set F_IMMED,0x80
09C6                629	#	.set F_HIDDEN,0x20
09C6                630	#	.set F_LENMASK,0x1f	// length mask
09C6 = 0000.0080    631	F_IMMED 	.EQU	$80
09C6 = 0000.0020    632	F_HIDDEN	.EQU	$20
09C6 = 0000.001F    633	F_LENMASK	.EQU	$1F
09C6                634	
09C6                635	#	// Store the chain of links.
09C6                636	#	.set link,0
09C6                637	
09C6                638	#	.macro defword name, namelen, flags=0, label
09C6                639	#	.section .rodata
09C6                640	#	.align 4
09C6                641	#	.globl name_\label
09C6                642	#name_\label :
09C6                643	#	.int link		// link
09C6                644	#	.set link,name_\label
09C6                645	#	.byte \flags+\namelen	// flags + length byte
09C6                646	#	.ascii "\name"		// the name
09C6                647	#	.align 4		// padding to next 4 byte boundary
09C6                648	#	.globl \label
09C6                649	#\label :
09C6                650	#	.int DOCOL		// codeword - the interpreter
09C6                651	#	// list of word pointers follow
09C6                652	#	.endm
09C6                653	
09C6                654	#	Similarly I want a way to write words written in assembly language.  There will quite a few
09C6                655	#	of these to start with because, well, everything has to start in assembly before there's
09C6                656	#	enough "infrastructure" to be able to start writing FORTH words, but also I want to define
09C6                657	#	some common FORTH words in assembly language for speed, even though I could write them in FORTH.
09C6                658	
09C6                659	#	This is what DUP looks like in memory:
09C6                660	
09C6                661	#	  pointer to previous word
09C6                662	#	   ^
09C6                663	#	   |
09C6                664	#	+--|------+---+---+---+---+------------+
09C6                665	#	| LINK	  | 3 | D | U | P | code_DUP ---------------------> points to the assembly
09C6                666	#	+---------+---+---+---+---+------------+		    code used to write DUP,
09C6                667	#	   ^	   len		    codeword			    which ends with NEXT.
09C6                668	#	   |
09C6                669	#	  LINK in next word
09C6                670	
09C6                671	#	Again, for brevity in writing the header I'm going to write an assembler macro called defcode.
09C6                672	#	As with defword above, don't worry about the complicated details of the macro.
09C6                673	
09C6                674	#	.macro defcode name, namelen, flags=0, label
09C6                675	#	.section .rodata
09C6                676	#	.align 4
09C6                677	#	.globl name_\label
09C6                678	#name_\label :
09C6                679	#	.int link		// link
09C6                680	#	.set link,name_\label
09C6                681	#	.byte \flags+\namelen	// flags + length byte
09C6                682	#	.ascii "\name"		// the name
09C6                683	#	.align 4		// padding to next 4 byte boundary
09C6                684	#	.globl \label
09C6                685	#\label :
09C6                686	#	.int code_\label	// codeword
09C6                687	#	.text
09C6                688	#	//.align 4
09C6                689	#	.globl code_\label
09C6                690	#code_\label :			 // assembler code follows
09C6                691	#	.endm
09C6                692	
09C6                693	# next code
09C6 10C40000       694	NEXT		LD4	R0, [R12]	; R12 = ESI
09CA 3CC40004       695			ADD	R12, 4		; INC4 ESI
09CE 11040000       696			LD4	R1, [R0]	; GET CODEWORD
09D2 0F10           697			JMP	R1		; JUMP CODEWORD
09D4                698	
09D4                699	# drop top of stack
09D4 0FF80001       700	C_DROP		ENTER	1		; drop top of stack
09D8 2FF0FFF5       701			BRA	NEXT
09DC                702	
09DC                703	# read disk block, put addr to top
09DC 10F40000       704	C_BLOCK 	LD4	R0, [SP]
09E0 01F8           705			LI	R1, DISK_CMD_READ
09E2 0FFDFFFFFFAA   706			JAL	DISK_IO
09E8 10FA0000       707			ST4	[SP], R0
09EC 2FF0FFEB       708			BRA	NEXT
09F0                709	
09F0                710	# write disk block, put addr to top
09F0 10F40000       711	C_WRITE 	LD4	R0, [SP]
09F4 31F90002       712			LI	R1, DISK_CMD_WRITE
09F8 0FFDFFFFFF9F   713			JAL	DISK_IO
09FE 10FA0000       714			ST4	[SP], R0
0A02 2FF0FFE0       715			BRA	NEXT
0A06                716	
0A06                717	# swap top two elements on stack
0A06 10F40000       718	C_SWAP		LD4	R0, [SP]
0A0A 11F40002       719			LD4	R1, [SP + 2]
0A0E 10FA0002       720			ST4	[SP + 2], R0
0A12 11FA0000       721			ST4	[SP], R1
0A16 2FF0FFD6       722			BRA	NEXT
0A1A                723	
0A1A                724	# duplicate top of stack
0A1A 10F40000       725	C_DUP		LD4	R0, [SP]
0A1E 0FF8FFFF       726			ENTER	-1
0A22 10FA0000       727			ST4	[SP], R0
0A26 2FF0FFCE       728			BRA	NEXT
0A2A                729	
0A2A                730	# get the second element of stack and push it on top
0A2A 10F40002       731	C_OVER		LD4	R0, [SP + 2]
0A2E 0FF8FFFF       732			ENTER	-1
0A32 10FA0000       733			ST4	[SP], R0
0A36 2FF0FFC6       734			BRA	NEXT
0A3A                735	
0A3A                736	# rotate elements on stack
0A3A 10F40000       737	C_ROT		LD4	R0, [SP]
0A3E 11F40002       738			LD4	R1, [SP + 2]
0A42 12F40004       739			LD4	R2, [SP + 4]
0A46 11FA0004       740			ST4	[SP + 4], R1
0A4A 10FA0002       741			ST4	[SP + 2], R0
0A4E 12FA0000       742			ST4	[SP], R2
0A52 2FF0FFB8       743			BRA	NEXT
0A56                744	
0A56 10F40000       745	C_NROT		LD4	R0, [SP]
0A5A 11F40002       746			LD4	R1, [SP + 2]
0A5E 12F40004       747			LD4	R2, [SP + 4]
0A62 10FA0004       748			ST4	[SP + 4], R0
0A66 12FA0002       749			ST4	[SP + 2], R2
0A6A 11FA0000       750			ST4	[SP], R1
0A6E 2FF0FFAA       751			BRA	NEXT
0A72                752	
0A72                753	#	 defcode "2DROP",5,,TWODROP // drop top two elements of stack
0A72                754	#	 pop %eax
0A72                755	#	 pop %eax
0A72                756	#	 NEXT
0A72                757	
0A72                758	#	 defcode "2DUP",4,,TWODUP // duplicate top two elements of stack
0A72                759	#	 mov (%esp),%eax
0A72                760	#	 mov 4(%esp),%ebx
0A72                761	#	 push %ebx
0A72                762	#	 push %eax
0A72                763	#	 NEXT
0A72                764	
0A72                765	#	 defcode "2SWAP",5,,TWOSWAP // swap top two pairs of elements of stack
0A72                766	#	 pop %eax
0A72                767	#	 pop %ebx
0A72                768	#	 pop %ecx
0A72                769	#	 pop %edx
0A72                770	#	 push %ebx
0A72                771	#	 push %eax
0A72                772	#	 push %edx
0A72                773	#	 push %ecx
0A72                774	#	 NEXT
0A72                775	
0A72                776	# duplicate top of stack if non-zero
0A72 10F40000       777	C_QDUP		LD4	R0, [SP]
0A76 20F00004       778			BZ	R0, .DONE
0A7A 0FF8FFFF       779			ENTER	-1
0A7E 10FA0000       780			ST4	[SP], R0
0A82 2FF0FFA0       781	.DONE		BRA	NEXT
0A86                782	
0A86                783	# aritmethic
0A86 10F40000       784	C_INCR		LD4	R0, [SP]
0A8A 30040001       785			ADD	R0, 1
0A8E 10FA0000       786			ST4	[SP], R0
0A92 2FF0FF98       787			BRA	NEXT
0A96                788	
0A96 10F40000       789	C_DECR		LD4	R0, [SP]
0A9A 30050001       790			SUB	R0, 1
0A9E 10FA0000       791			ST4	[SP], R0
0AA2 2FF0FF90       792			BRA	NEXT
0AA6                793	
0AA6 10F40000       794	C_INCR4 	LD4	R0, [SP]
0AAA 30040004       795			ADD	R0, 4
0AAE 10FA0000       796			ST4	[SP], R0
0AB2 2FF0FF88       797			BRA	NEXT
0AB6                798	
0AB6 10F40000       799	C_DECR4 	LD4	R0, [SP]
0ABA 30050004       800			SUB	R0, 4
0ABE 10FA0000       801			ST4	[SP], R0
0AC2 2FF0FF80       802			BRA	NEXT
0AC6                803	
0AC6 10F40000       804	C_ADD		LD4	R0, [SP]
0ACA 0FF80001       805			ENTER	1
0ACE 11F40000       806			LD4	R1, [SP]
0AD2 4001           807			ADD	R0, R1
0AD4 10FA0000       808			ST4	[SP], R0
0AD8 2FF0FF75       809			BRA	NEXT
0ADC                810	
0ADC 11F40000       811	C_SUB		LD4	R1, [SP]
0AE0 0FF80001       812			ENTER	1
0AE4 10F40000       813			LD4	R0, [SP]
0AE8 5001           814			SUB	R0, R1
0AEA 10FA0000       815			ST4	[SP], R0
0AEE 2FF0FF6A       816			BRA	NEXT
0AF2                817	
0AF2 11F40000       818	C_CRC32 	LD4	R1, [SP]
0AF6 0FF80001       819			ENTER	1
0AFA 10F40000       820			LD4	R0, [SP]
0AFE 0FFDFFFFFBCB   821			JAL	CRC32
0B04 10FA0000       822			ST4	[SP], R0
0B08 2FF0FF5D       823			BRA	NEXT
0B0C                824	
0B0C 10F40000       825	C_MUL		LD4	R0, [SP]
0B10 0FF80001       826			ENTER	1
0B14 11F40000       827			LD4	R1, [SP]
0B18 6001           828			MUL	R0, R1
0B1A 10FA0000       829			ST4	[SP], R0
0B1E 2FF0FF52       830			BRA	NEXT
0B22                831	
0B22                832	#	 defcode "*",1,,MUL
0B22                833	#	 pop %eax
0B22                834	#	 pop %ebx
0B22                835	#	 imull %ebx,%eax
0B22                836	#	 push %eax		 // ignore overflow
0B22                837	#	 NEXT
0B22                838	
0B22                839	#	In this FORTH, only /MOD is primitive.	Later we will define the / and MOD words in
0B22                840	#	terms of the primitive /MOD.  The design of the i386 assembly instruction idiv which
0B22                841	#	leaves both quotient and remainder makes this the obvious choice.
0B22                842	
0B22 11F40000       843	C_DIVMOD	LD4	R1, [SP]
0B26 10F40002       844			LD4	R0, [SP + 2]
0B2A 7001           845			DIV	R0, R1
0B2C 0F180000       846			GET	R1, REG_MOD
0B30 11FA0002       847			ST4	[SP + 2], R1	; remainder
0B34 10FA0000       848			ST4	[SP], R0	; quotient
0B38 2FF0FF45       849			BRA	NEXT
0B3C                850	
0B3C                851	#	Lots of comparison operations like =, <, >, etc..
0B3C                852	#	ANS FORTH says that the comparison words should return all (binary) 1's for
0B3C                853	#	TRUE and all 0's for FALSE.  However this is a bit of a strange convention
0B3C                854	#	so this FORTH breaks it and returns the more normal (for C programmers ...)
0B3C                855	#	1 meaning TRUE and 0 meaning FALSE.
0B3C                856	
0B3C 10F40000       857	C_EQU		LD4	R0, [SP]
0B40 0FF80001       858			ENTER	1
0B44 11F40000       859			LD4	R1, [SP]
0B48 5110           860			SUB	R1, R0
0B4A 0018           861			CSETZ	R0, R1
0B4C 10FA0000       862			ST4	[SP], R0
0B50 2FF0FF39       863			BRA	NEXT
0B54                864	
0B54 10F40000       865	C_NEQU		LD4	R0, [SP]
0B58 0FF80001       866			ENTER	1
0B5C 11F40000       867			LD4	R1, [SP]
0B60 5110           868			SUB	R1, R0
0B62 0019           869			CSETNZ	R0, R1
0B64 10FA0000       870			ST4	[SP], R0
0B68 2FF0FF2D       871			BRA	NEXT
0B6C                872	
0B6C 10F40000       873	C_LT		LD4	R0, [SP]
0B70 0FF80001       874			ENTER	1
0B74 11F40000       875			LD4	R1, [SP]
0B78 5110           876			SUB	R1, R0
0B7A 001A           877			CSETN	R0, R1
0B7C 10FA0000       878			ST4	[SP], R0
0B80 2FF0FF21       879			BRA	NEXT
0B84                880	
0B84 10F40000       881	C_GT		LD4	R0, [SP]
0B88 0FF80001       882			ENTER	1
0B8C 11F40000       883			LD4	R1, [SP]
0B90 5110           884			SUB	R1, R0
0B92 001C           885			CSETP	R0, R1
0B94 10FA0000       886			ST4	[SP], R0
0B98 2FF0FF15       887			BRA	NEXT
0B9C                888	
0B9C 10F40000       889	C_LE		LD4	R0, [SP]
0BA0 0FF80001       890			ENTER	1
0BA4 11F40000       891			LD4	R1, [SP]
0BA8 5110           892			SUB	R1, R0
0BAA 001D           893			CSETNP	R0, R1
0BAC 10FA0000       894			ST4	[SP], R0
0BB0 2FF0FF09       895			BRA	NEXT
0BB4                896	
0BB4 10F40000       897	C_GE		LD4	R0, [SP]
0BB8 0FF80001       898			ENTER	1
0BBC 11F40000       899			LD4	R1, [SP]
0BC0 5110           900			SUB	R1, R0
0BC2 001B           901			CSETNN	R0, R1
0BC4 10FA0000       902			ST4	[SP], R0
0BC8 2FF0FEFD       903			BRA	NEXT
0BCC                904	
0BCC 10F40000       905	C_ZEQU		LD4	R0, [SP]
0BD0 0008           906			CSETZ	R0, R0
0BD2 10FA0000       907			ST4	[SP], R0
0BD6 2FF0FEF6       908			BRA	NEXT
0BDA                909	
0BDA 10F40000       910	C_ZNEQU 	LD4	R0, [SP]
0BDE 0009           911			CSETNZ	R0, R0
0BE0 10FA0000       912			ST4	[SP], R0
0BE4 2FF0FEEF       913			BRA	NEXT
0BE8                914	
0BE8 10F40000       915	C_ZLT		LD4	R0, [SP]
0BEC 000A           916			CSETN	R0, R0
0BEE 10FA0000       917			ST4	[SP], R0
0BF2 2FF0FEE8       918			BRA	NEXT
0BF6                919	
0BF6 10F40000       920	C_ZGT		LD4	R0, [SP]
0BFA 000C           921			CSETP	R0, R0
0BFC 10FA0000       922			ST4	[SP], R0
0C00 2FF0FEE1       923			BRA	NEXT
0C04                924	
0C04 10F40000       925	C_ZLE		LD4	R0, [SP]
0C08 000D           926			CSETNP	R0, R0
0C0A 10FA0000       927			ST4	[SP], R0
0C0E 2FF0FEDA       928			BRA	NEXT
0C12                929	
0C12 10F40000       930	C_ZGE		LD4	R0, [SP]
0C16 000B           931			CSETNN	R0, R0
0C18 10FA0000       932			ST4	[SP], R0
0C1C 2FF0FED3       933			BRA	NEXT
0C20                934	
0C20 10F40000       935	C_AND		LD4	R0, [SP]
0C24 0FF80001       936			ENTER	1
0C28 11F40000       937			LD4	R1, [SP]
0C2C 8001           938			AND	R0, R1
0C2E 10FA0000       939			ST4	[SP], R0
0C32 2FF0FEC8       940			BRA	NEXT
0C36                941	
0C36 10F40000       942	C_OR		LD4	R0, [SP]
0C3A 0FF80001       943			ENTER	1
0C3E 11F40000       944			LD4	R1, [SP]
0C42 9001           945			OR	R0, R1
0C44 10FA0000       946			ST4	[SP], R0
0C48 2FF0FEBD       947			BRA	NEXT
0C4C                948	
0C4C 10F40000       949	C_XOR		LD4	R0, [SP]
0C50 0FF80001       950			ENTER	1
0C54 11F40000       951			LD4	R1, [SP]
0C58 A001           952			XOR	R0, R1
0C5A 10FA0000       953			ST4	[SP], R0
0C5E 2FF0FEB2       954			BRA	NEXT
0C62                955	
0C62                956	#	 defcode "INVERT",6,,INVERT // this is the FORTH bitwise "NOT" function (cf. NEGATE and NOT)
0C62                957	#	 notl (%esp)
0C62                958	#	 NEXT
0C62                959	
0C62                960	#	RETURNING FROM FORTH WORDS ----------------------------------------------------------------------
0C62                961	
0C62                962	#	Time to talk about what happens when we EXIT a function.  In this diagram QUADRUPLE has called
0C62                963	#	DOUBLE, and DOUBLE is about to exit (look at where %esi is pointing):
0C62                964	
0C62                965	#		QUADRUPLE
0C62                966	#		+------------------+
0C62                967	#		| codeword	   |
0C62                968	#		+------------------+		   DOUBLE
0C62                969	#		| addr of DOUBLE  ---------------> +------------------+
0C62                970	#		+------------------+		   | codeword	      |
0C62                971	#		| addr of DOUBLE   |		   +------------------+
0C62                972	#		+------------------+		   | addr of DUP      |
0C62                973	#		| addr of EXIT	   |		   +------------------+
0C62                974	#		+------------------+		   | addr of +	      |
0C62                975	#						   +------------------+
0C62                976	#					   %esi -> | addr of EXIT     |
0C62                977	#						   +------------------+
0C62                978	
0C62                979	#	What happens when the + function does NEXT?  Well, the following code is executed.
0C62 1CD40000       980	C_EXIT		LD4	R12, [R13]	; R12 = ESI, R13 = RSP
0C66 3DD40004       981			ADD	R13, 4
0C6A 2FF0FEAC       982			BRA	NEXT
0C6E                983	
0C6E                984	#	EXIT gets the old %esi which we saved from before on the return stack, and puts it in %esi.
0C6E                985	#	So after this (but just before NEXT) we get:
0C6E                986	
0C6E                987	#		QUADRUPLE
0C6E                988	#		+------------------+
0C6E                989	#		| codeword	   |
0C6E                990	#		+------------------+		   DOUBLE
0C6E                991	#		| addr of DOUBLE  ---------------> +------------------+
0C6E                992	#		+------------------+		   | codeword	      |
0C6E                993	#	%esi -> | addr of DOUBLE   |		   +------------------+
0C6E                994	#		+------------------+		   | addr of DUP      |
0C6E                995	#		| addr of EXIT	   |		   +------------------+
0C6E                996	#		+------------------+		   | addr of +	      |
0C6E                997	#						   +------------------+
0C6E                998	#						   | addr of EXIT     |
0C6E                999	#						   +------------------+
0C6E               1000	
0C6E               1001	#	And NEXT just completes the job by, well, in this case just by calling DOUBLE again :-)
0C6E               1002	
0C6E               1003	#	LITERALS ----------------------------------------------------------------------
0C6E               1004	
0C6E               1005	#	The final point I "glossed over" before was how to deal with functions that do anything
0C6E               1006	#	apart from calling other functions.  For example, suppose that DOUBLE was defined like this:
0C6E               1007	
0C6E               1008	#	: DOUBLE 2 * ;
0C6E               1009	
0C6E               1010	#	It does the same thing, but how do we compile it since it contains the literal 2?  One way
0C6E               1011	#	would be to have a function called "2" (which you'd have to write in assembler), but you'd need
0C6E               1012	#	a function for every single literal that you wanted to use.
0C6E               1013	
0C6E               1014	#	FORTH solves this by compiling the function using a special word called LIT:
0C6E               1015	
0C6E               1016	#	+---------------------------+-------+-------+-------+-------+-------+
0C6E               1017	#	| (usual header of DOUBLE)  | DOCOL | LIT   | 2     | *     | EXIT  |
0C6E               1018	#	+---------------------------+-------+-------+-------+-------+-------+
0C6E               1019	
0C6E               1020	#	LIT is executed in the normal way, but what it does next is definitely not normal.  It
0C6E               1021	#	looks at %esi (which now points to the number 2), grabs it, pushes it on the stack, then
0C6E               1022	#	manipulates %esi in order to skip the number as if it had never been there.
0C6E               1023	
0C6E               1024	#	What's neat is that the whole grab/manipulate can be done using a single byte single
0C6E               1025	#	i386 instruction, our old friend LODSL.  Rather than me drawing more ASCII-art diagrams,
0C6E               1026	#	see if you can find out how LIT works:
0C6E 0FF8FFFF      1027	C_LIT		ENTER	-1
0C72 10C50000      1028			LD4I	R0, [R12]
0C76 3CC40004      1029			ADD	R12, 4
0C7A 10FA0000      1030			ST4	[SP], R0
0C7E 2FF0FEA2      1031			BRA	NEXT
0C82               1032	
0C82               1033	#	MEMORY ----------------------------------------------------------------------
0C82               1034	
0C82               1035	#	As important point about FORTH is that it gives you direct access to the lowest levels
0C82               1036	#	of the machine.  Manipulating memory directly is done frequently in FORTH, and these are
0C82               1037	#	the primitive words for doing it.
0C82 10F50000      1038	C_STORE 	LD4I	R0, [SP]
0C86 11F40002      1039			LD4	R1, [SP + 2]
0C8A 0FF80002      1040			ENTER	2
0C8E 110A0000      1041			ST4	[R0], R1
0C92 2FF0FE98      1042			BRA	NEXT
0C96               1043	
0C96 10F50000      1044	C_FETCH 	LD4I	R0, [SP]
0C9A 11050000      1045			LD4I	R1, [R0]
0C9E 11FA0000      1046			ST4	[SP], R1
0CA2 2FF0FE90      1047			BRA	NEXT
0CA6               1048	
0CA6 10F50000      1049	C_ADDSTORE	LD4I	R0, [SP]
0CAA 11F40002      1050			LD4	R1, [SP + 2]
0CAE 0FF80002      1051			ENTER	2
0CB2 12040000      1052			LD4	R2, [R0]
0CB6 4221          1053			ADD	R2, R1
0CB8 120A0000      1054			ST4	[R0], R2
0CBC 2FF0FE83      1055			BRA	NEXT
0CC0               1056	
0CC0 10F50000      1057	C_SUBSTORE	LD4I	R0, [SP]
0CC4 11F40002      1058			LD4	R1, [SP + 2]
0CC8 0FF80002      1059			ENTER	2
0CCC 12040000      1060			LD4	R2, [R0]
0CD0 5221          1061			SUB	R2, R1
0CD2 120A0000      1062			ST4	[R0], R2
0CD6 2FF0FE76      1063			BRA	NEXT
0CDA               1064	
0CDA               1065	#	! and @ (STORE and FETCH) store 32-bit words.  It's also useful to be able to read and write bytes
0CDA               1066	#	so we also define standard words C@ and C!.
0CDA               1067	#	Byte-oriented operations only work on architectures which permit them (i386 is one of those).
0CDA 10F50000      1068	C_STOREBYTE	LD4I	R0, [SP]
0CDE 11F00002      1069			LD1	R1, [SP + 2]
0CE2 0FF80002      1070			ENTER	2
0CE6 11080000      1071			ST1	[R0], R1
0CEA 2FF0FE6C      1072			BRA	NEXT
0CEE               1073	
0CEE 10F50000      1074	C_FETCHBYTE	LD4I	R0, [SP]
0CF2 11000000      1075			LD1	R1, [R0]
0CF6 11FA0000      1076			ST4	[SP], R1
0CFA 2FF0FE64      1077			BRA	NEXT
0CFE               1078	
0CFE               1079	# C@C! is a useful byte copy primitive
0CFE               1080	#	 defcode "C@C!",4,,CCOPY
0CFE               1081	#	 movl 4(%esp),%ebx	 // source address
0CFE               1082	#	 movb (%ebx),%al	 // get source character
0CFE               1083	#	 pop %edi		 // destination address
0CFE               1084	#	 stosb			 // copy to destination
0CFE               1085	#	 push %edi		 // increment destination address
0CFE               1086	#	 incl 4(%esp)		 // increment source address
0CFE               1087	#	 NEXT
0CFE               1088	
0CFE               1089	# and CMOVE is a block copy operation.
0CFE               1090	#	 defcode "CMOVE",5,,CMOVE
0CFE               1091	#	 mov %esi,%edx		 // preserve %esi
0CFE               1092	#	 pop %ecx		 // length
0CFE               1093	#	 pop %edi		 // destination address
0CFE               1094	#	 pop %esi		 // source address
0CFE               1095	#	 rep movsb		 // copy source to destination
0CFE               1096	#	 mov %edx,%esi		 // restore %esi
0CFE               1097	#	 NEXT
0CFE               1098	
0CFE               1099	#	BUILT-IN VARIABLES ----------------------------------------------------------------------
0CFE               1100	
0CFE               1101	#	These are some built-in variables and related standard FORTH words.  Of these, the only one that we
0CFE               1102	#	have discussed so far was LATEST, which points to the last (most recently defined) word in the
0CFE               1103	#	FORTH dictionary.  LATEST is also a FORTH word which pushes the address of LATEST (the variable)
0CFE               1104	#	on to the stack, so you can read or write it using @ and ! operators.  For example, to print
0CFE               1105	#	the current value of LATEST (and this can apply to any FORTH variable) you would do:
0CFE               1106	
0CFE               1107	#	LATEST @ . CR
0CFE               1108	
0CFE               1109	#	To make defining variables shorter, I'm using a macro called defvar, similar to defword and
0CFE               1110	#	defcode above.	(In fact the defvar macro uses defcode to do the dictionary header).
0CFE               1111	
0CFE               1112	#	.macro defvar name, namelen, flags=0, label, initial=0
0CFE               1113	#	defcode \name,\namelen,\flags,\label
0CFE               1114	#	push $var_\name
0CFE               1115	#	NEXT
0CFE               1116	#	.data
0CFE               1117	#	.align 4
0CFE               1118	#v ar_\name :
0CFE               1119	#	.int \initial
0CFE               1120	#	.endm
0CFE               1121	
0CFE               1122	#	The built-in variables are:
0CFE               1123	#	STATE		Is the interpreter executing code (0) or compiling a word (non-zero)?
0CFE               1124	#	LATEST		Points to the latest (most recently defined) word in the dictionary.
0CFE               1125	#	HERE		Points to the next free byte of memory.  When compiling, compiled words go here.
0CFE               1126	#	S0		Stores the address of the top of the parameter stack.
0CFE               1127	#	BASE		The current base for printing and reading numbers.
0CFE               1128	
0CFE 30F9200C      1129	C_STATE 	LI	R0, FORTH_STATE
0D02 0FF8FFFF      1130			ENTER	-1
0D06 10FA0000      1131			ST4	[SP], R0
0D0A 2FF0FE5C      1132			BRA	NEXT
0D0E               1133	
0D0E 30F92010      1134	C_HERE		LI	R0, FORTH_HERE
0D12 0FF8FFFF      1135			ENTER	-1
0D16 10FA0000      1136			ST4	[SP], R0
0D1A 2FF0FE54      1137			BRA	NEXT
0D1E               1138	
0D1E 30F92014      1139	C_LATEST	LI	R0, FORTH_LATEST
0D22 0FF8FFFF      1140			ENTER	-1
0D26 10FA0000      1141			ST4	[SP], R0
0D2A 2FF0FE4C      1142			BRA	NEXT
0D2E               1143	
0D2E 30F92F60      1144	C_S0		LI	R0, SYS_STACK
0D32 0FF8FFFF      1145			ENTER	-1
0D36 10FA0000      1146			ST4	[SP], R0
0D3A 2FF0FE44      1147			BRA	NEXT
0D3E               1148	
0D3E 30F92018      1149	C_BASE		LI	R0, FORTH_BASE
0D42 0FF8FFFF      1150			ENTER	-1
0D46 10FA0000      1151			ST4	[SP], R0
0D4A 2FF0FE3C      1152			BRA	NEXT
0D4E               1153	
0D4E               1154	#	BUILT-IN CONSTANTS ----------------------------------------------------------------------
0D4E               1155	
0D4E               1156	#	It's also useful to expose a few constants to FORTH.  When the word is executed it pushes a
0D4E               1157	#	constant value on the stack.
0D4E               1158	
0D4E               1159	#	The built-in constants are:
0D4E               1160	
0D4E               1161	#	VERSION 	Is the current version of this FORTH.
0D4E               1162	#	R0		The address of the top of the return stack.
0D4E               1163	#	DOCOL		Pointer to DOCOL.
0D4E               1164	#	F_IMMED 	The IMMEDIATE flag's actual value.
0D4E               1165	#	F_HIDDEN	The HIDDEN flag's actual value.
0D4E               1166	#	F_LENMASK	The length mask in the flags/len byte.
0D4E               1167	
0D4E               1168	#	SYS_*		and the numeric codes of various Linux syscalls (from <asm/unistd.h>)
0D4E               1169	
0D4E               1170	##include <asm-i386/unistd.h>  // you might need this instead
0D4E               1171	##include <asm/unistd.h>
0D4E               1172	
0D4E               1173	#	 .macro defconst name, namelen, flags=0, label, value
0D4E               1174	#	 defcode \name,\namelen,\flags,\label
0D4E               1175	#	 push $\value
0D4E               1176	#	 NEXT
0D4E               1177	#	 .endm
0D4E               1178	
0D4E 30F9002F      1179	C_VERSION	LI	R0, JONES_VERSION
0D52 0FF8FFFF      1180			ENTER	-1
0D56 10FA0000      1181			ST4	[SP], R0
0D5A 2FF0FE34      1182			BRA	NEXT
0D5E               1183	
0D5E 30F94000      1184	C_R0		LI	R0, RSTACK
0D62 0FF8FFFF      1185			ENTER	-1
0D66 10FA0000      1186			ST4	[SP], R0
0D6A 2FF0FE2C      1187			BRA	NEXT
0D6E               1188	
0D6E 30F9097A      1189	C_DOCOL 	LI	R0, DOCOL
0D72 0FF8FFFF      1190			ENTER	-1
0D76 10FA0000      1191			ST4	[SP], R0
0D7A 2FF0FE24      1192			BRA	NEXT
0D7E               1193	
0D7E 30F90080      1194	C_F_IMMED	LI	R0, F_IMMED
0D82 0FF8FFFF      1195			ENTER	-1
0D86 10FA0000      1196			ST4	[SP], R0
0D8A 2FF0FE1C      1197			BRA	NEXT
0D8E               1198	
0D8E 30F90020      1199	C_F_HIDDEN	LI	R0, F_HIDDEN
0D92 0FF8FFFF      1200			ENTER	-1
0D96 10FA0000      1201			ST4	[SP], R0
0D9A 2FF0FE14      1202			BRA	NEXT
0D9E               1203	
0D9E 30F9001F      1204	C_F_LENMASK	LI	R0, F_LENMASK
0DA2 0FF8FFFF      1205			ENTER	-1
0DA6 10FA0000      1206			ST4	[SP], R0
0DAA 2FF0FE0C      1207			BRA	NEXT
0DAE               1208	
0DAE               1209	#	RETURN STACK ----------------------------------------------------------------------
0DAE               1210	#	These words allow you to access the return stack.  Recall that the register %ebp always points to
0DAE               1211	#	the top of the return stack.
0DAE 10F40000      1212	C_TOR		LD4	R0, [SP]
0DB2 0FF80001      1213			ENTER	1
0DB6 3DD50004      1214			SUB	R13, 4
0DBA 10DA0000      1215			ST4	[R13], R0
0DBE 2FF0FE02      1216			BRA	NEXT
0DC2               1217	
0DC2 10D40000      1218	C_FROMR 	LD4	R0, [R13]
0DC6 0FF8FFFF      1219			ENTER	-1
0DCA 3DD40004      1220			ADD	R13, 4
0DCE 10FA0000      1221			ST4	[SP], R0
0DD2 2FF0FDF8      1222			BRA	NEXT
0DD6               1223	
0DD6 0FF8FFFF      1224	C_RSPFETCH	ENTER	-1
0DDA 1DFA0000      1225			ST4	[SP], R13
0DDE 2FF0FDF2      1226			BRA	NEXT
0DE2               1227	
0DE2 1DF40000      1228	C_RSPSTORE	LD4	R13, [SP]
0DE6 0FF80001      1229			ENTER	1
0DEA 2FF0FDEC      1230			BRA	NEXT
0DEE               1231	
0DEE 3DD40004      1232	C_RDROP 	ADD	R13, 4
0DF2 2FF0FDE8      1233			BRA	NEXT
0DF6               1234	
0DF6               1235	
0DF6               1236	#	PARAMETER (DATA) STACK ----------------------------------------------------------------------
0DF6               1237	#	These functions allow you to manipulate the parameter stack.  Recall that Linux sets up the parameter
0DF6               1238	#	stack for us, and it is accessed through %esp.
0DF6               1239	
0DF6 90FF          1240	C_DSPFETCH	MV	R0, SP
0DF8 0FF8FFFF      1241			ENTER	-1
0DFC 10FA0000      1242			ST4	[SP], R0
0E00 2FF0FDE1      1243			BRA	NEXT
0E04               1244	
0E04 1FF40000      1245	C_DSPSTORE	LD4	SP, [SP]
0E08 2FF0FDDD      1246			BRA	NEXT
0E0C               1247	
0E0C               1248	#	INPUT AND OUTPUT ----------------------------------------------------------------------
0E0C               1249	
0E0C               1250	#	These are our first really meaty/complicated FORTH primitives.	I have chosen to write them in
0E0C               1251	#	assembler, but surprisingly in "real" FORTH implementations these are often written in terms
0E0C               1252	#	of more fundamental FORTH primitives.  I chose to avoid that because I think that just obscures
0E0C               1253	#	the implementation.  After all, you may not understand assembler but you can just think of it
0E0C               1254	#	as an opaque block of code that does what it says.
0E0C               1255	
0E0C               1256	#	Let's discuss input first.
0E0C               1257	
0E0C               1258	#	The FORTH word KEY reads the next byte from stdin (and pushes it on the parameter stack).
0E0C               1259	#	So if KEY is called and someone hits the space key, then the number 32 (ASCII code of space)
0E0C               1260	#	is pushed on the stack.
0E0C               1261	
0E0C               1262	#	In FORTH there is no distinction between reading code and reading input.  We might be reading
0E0C               1263	#	and compiling code, we might be reading words to execute, we might be asking for the user
0E0C               1264	#	to type their name -- ultimately it all comes in through KEY.
0E0C               1265	
0E0C               1266	#	The implementation of KEY uses an input buffer of a certain size (defined at the end of this
0E0C               1267	#	file).	It calls the Linux read(2) system call to fill this buffer and tracks its position
0E0C               1268	#	in the buffer using a couple of variables, and if it runs out of input buffer then it refills
0E0C               1269	#	it automatically.  The other thing that KEY does is if it detects that stdin has closed, it
0E0C               1270	#	exits the program, which is why when you hit ^D the FORTH system cleanly exits.
0E0C               1271	
0E0C               1272	#    buffer			      bufftop
0E0C               1273	#	|				 |
0E0C               1274	#	V				 V
0E0C               1275	#	+-------------------------------+--------------------------------------+
0E0C               1276	#	| INPUT READ FROM STDIN ....... | unused part of the buffer	       |
0E0C               1277	#	+-------------------------------+--------------------------------------+
0E0C               1278	#			  ^
0E0C               1279	#			  |
0E0C               1280	#		       currkey (next character to read)
0E0C               1281	
0E0C               1282	#	<---------------------- BUFFER_SIZE (4096 bytes) ---------------------->
0E0C               1283	
0E0C 0FFDFFFFF992  1284	C_KEY		JAL	CONREADECHO
0E12 0FF8FFFF      1285			ENTER	-1
0E16 10FA0000      1286			ST4	[SP], R0
0E1A 2FF0FDD4      1287			BRA	NEXT
0E1E               1288	
0E1E               1289	#	By contrast, output is much simpler.  The FORTH word EMIT writes out a single byte to stdout.
0E1E               1290	#	This implementation just uses the write system call.  No attempt is made to buffer output, but
0E1E               1291	#	it would be a good exercise to add it.
0E1E               1292	
0E1E 10F40000      1293	C_EMIT		LD4	R0, [SP]
0E22 0FF80001      1294			ENTER	1
0E26 0FFDFFFFF95C  1295			JAL	CONOUT
0E2C 2FF0FDCB      1296			BRA	NEXT
0E30               1297	
0E30               1298	#	Back to input, WORD is a FORTH word which reads the next full word of input.
0E30               1299	
0E30               1300	#	What it does in detail is that it first skips any blanks (spaces, tabs, newlines and so on).
0E30               1301	#	Then it calls KEY to read characters into an internal buffer until it hits a blank.  Then it
0E30               1302	#	calculates the length of the word it read and returns the address and the length as
0E30               1303	#	two words on the stack (with the length at the top of stack).
0E30               1304	
0E30               1305	#	Notice that WORD has a single internal buffer which it overwrites each time (rather like
0E30               1306	#	a static C string).  Also notice that WORD's internal buffer is just 32 bytes long and
0E30               1307	#	there is NO checking for overflow.  31 bytes happens to be the maximum length of a
0E30               1308	#	FORTH word that we support, and that is what WORD is used for: to read FORTH words when
0E30               1309	#	we are compiling and executing code.  The returned strings are not NUL-terminated.
0E30               1310	
0E30               1311	#	Start address+length is the normal way to represent strings in FORTH (not ending in an
0E30               1312	#	ASCII NUL character as in C), and so FORTH strings can contain any character including NULs
0E30               1313	#	and can be any length.
0E30               1314	
0E30               1315	#	WORD is not suitable for just reading strings (eg. user input) because of all the above
0E30               1316	#	peculiarities and limitations.
0E30               1317	
0E30               1318	#	Note that when executing, you'll see:
0E30               1319	#	WORD FOO
0E30               1320	#	which puts "FOO" and length 3 on the stack, but when compiling:
0E30               1321	#	: BAR WORD FOO ;
0E30               1322	#	is an error (or at least it doesn't do what you might expect).	Later we'll talk about compiling
0E30               1323	#	and immediate mode, and you'll understand why.
0E30 0FFD00000008  1324	C_WORD		JAL	WORD
0E36 0FF8FFFE      1325			ENTER	-2
0E3A 10FA0002      1326			ST4	[SP + 2], R0	; base address
0E3E 11FA0000      1327			ST4	[SP], R1	; length
0E42 2FF0FDC0      1328			BRA	NEXT
0E46               1329	
0E46 0FF8FFFF      1330	WORD		ENTER	-1
0E4A 1EFA0000      1331			ST4	[SP], R14
0E4E 1AFA0001      1332			ST4	[SP + 1], R10
0E52               1333	
0E52               1334	.READ		; search for first non-blank character.  Also skip \ comments
0E52 0FFDFFFFF96F  1335			JAL	CONREADECHO	; get next key, returned in R0
0E58 3105005C      1336			SUB	R1, R0, '\'
0E5C 21F0001B      1337			BZ	R1, .COMMENT
0E60 31F90020      1338			LI	R1, ' '
0E64 2014FFF5      1339			BLE	R0, R1, .READ
0E68               1340	
0E68               1341			; search for the end of the word, storing chars as we go
0E68 3AF9201C      1342			LI	R10, WORD_BUFFER
0E6C 10A80000      1343	.STORE		ST1	[R10], R0
0E70 3AA40001      1344			ADD	R10, 1
0E74 0FFDFFFFF95E  1345			JAL	CONREADECHO
0E7A 31F90020      1346			LI	R1, ' '
0E7E 2102FFF5      1347			BLT	R1, R0, .STORE
0E82               1348	
0E82               1349			; return result
0E82 30F9201C      1350			LI	R0, WORD_BUFFER
0E86 51A0          1351			SUB	R1, R10, R0
0E88 1AF40001      1352			LD4	R10, [SP + 1]
0E8C 1EF40000      1353			LD4	R14, [SP]
0E90 0FF80001      1354			ENTER	1
0E94 0FE0          1355			RET
0E96               1356	
0E96               1357	.COMMENT	; skip comments to end of the current line
0E96 0FFDFFFFF94D  1358			JAL	CONREADECHO
0E9C 31F9000D      1359			LI	R1, CR
0EA0 2011FFF9      1360			BNE	R0, R1, .COMMENT
0EA4 2FF0FFD5      1361			BRA	.READ
0EA8               1362	
0EA8               1363	#	As well as reading in words we'll need to read in numbers and for that we are using a function
0EA8               1364	#	called NUMBER.	This parses a numeric string such as one returned by WORD and pushes the
0EA8               1365	#	number on the parameter stack.
0EA8               1366	
0EA8               1367	#	The function uses the variable BASE as the base (radix) for conversion, so for example if
0EA8               1368	#	BASE is 2 then we expect a binary number.  Normally BASE is 10.
0EA8               1369	
0EA8               1370	#	If the word starts with a '-' character then the returned value is negative.
0EA8               1371	
0EA8               1372	#	If the string can't be parsed as a number (or contains characters outside the current BASE)
0EA8               1373	#	then we need to return an error indication.  So NUMBER actually returns two items on the stack.
0EA8               1374	#	At the top of stack we return the number of unconverted characters (ie. if 0 then all characters
0EA8               1375	#	were converted, so there is no error).	Second from top of stack is the parsed number or a
0EA8               1376	#	partial value if there was an error.
0EA8               1377	
0EA8 10F40002      1378	C_NUMBER	LD4	R0,[SP + 2]	; begin
0EAC 11F40000      1379			LD4	R1,[SP] 	; len
0EB0 0FFD00000006  1380			JAL	NUMBER
0EB6 10FA0002      1381			ST4	[SP + 2], R0	; parsed number
0EBA 11FA0000      1382			ST4	[SP], R1	; number of unparsed characters (0 = no error)
0EBE 2FF0FD82      1383			BRA	NEXT
0EC2               1384	
0EC2 83FF          1385	NUMBER: 	LI	R3, 0
0EC4 21F00039      1386			BZ	R1, .DONE
0EC8               1387	
0EC8 35F92018      1388			LI	R5, FORTH_BASE
0ECC 15540000      1389			LD4	R5, [R5]
0ED0               1390	
0ED0 14000000      1391			LD1	R4, [R0]	; fetch first char
0ED4 36450024      1392			SUB	R6, R4, '$'	; hex prefix ?
0ED8 26F10005      1393			BNZ	R6, .NOHEX
0EDC 35F90010      1394			LI	R5, 16
0EE0 06F8          1395			LI	R6, 1
0EE2 2FF00004      1396			BRA	.CONSUME
0EE6 3645002D      1397	.NOHEX		SUB	R6, R4, '-'
0EEA 26F10009      1398			BNZ	R6, .CONTINUE	; non negative
0EEE 30040001      1399	.CONSUME	ADD	R0, 1
0EF2 31150001      1400			SUB	R1, 1
0EF6 21F10003      1401			BNZ	R1, .CONTINUE
0EFA 01F8          1402			LI	R1, 1		; only -
0EFC 2FF0001D      1403			BRA	.DONE
0F00               1404	
0F00               1405	.CONTINUE	; loop reading digits
0F00 6335          1406			MUL	R3, R5		; R3 *= BASE
0F02 14000000      1407			LD1	R4, [R0]
0F06 30040001      1408			ADD	R0, 1
0F0A               1409	
0F0A               1410			; have a digit ?
0F0A 34450030      1411			SUB	R4, '0'
0F0E 24F30011      1412			BLTI	R4, SP, .DONEG
0F12 32F9000A      1413			LI	R2, 10
0F16 24220006      1414			BLT	R4, R2, .CHECK
0F1A 34450011      1415			SUB	R4, 17	; 17 == 'A' - '0'
0F1E 24F30009      1416			BLTI	R4, SP, .DONEG
0F22 3444000A      1417			ADD	R4, 10
0F26               1418	
0F26               1419	.CHECK		; digit fits ?
0F26 25440005      1420			BLE	R5, R4, .DONEG
0F2A               1421	
0F2A               1422			; add digit and loop
0F2A 4334          1423			ADD	R3, R4
0F2C 31150001      1424			SUB	R1, 1
0F30 21F1FFE6      1425			BNZ	R1, .CONTINUE
0F34               1426	
0F34 26F10001      1427	.DONEG		BNZ	R6, .DONE
0F38 53F3          1428			SUB	R3, SP, R3	; negate if '-'
0F3A               1429	
0F3A 90F3          1430	.DONE		MV	R0, R3
0F3C 0FE0          1431			RET
0F3E               1432	
0F3E               1433	#	DICTIONARY LOOK UPS ----------------------------------------------------------------------
0F3E               1434	#	We're building up to our prelude on how FORTH code is compiled, but first we need yet more infrastructure.
0F3E               1435	#	The FORTH word FIND takes a string (a word as parsed by WORD -- see above) and looks it up in the
0F3E               1436	#	dictionary.  What it actually returns is the address of the dictionary header, if it finds it,
0F3E               1437	#	or 0 if it didn't.
0F3E               1438	#	So if DOUBLE is defined in the dictionary, then WORD DOUBLE FIND returns the following pointer:
0F3E               1439	#   pointer to this
0F3E               1440	#	|
0F3E               1441	#	|
0F3E               1442	#	V
0F3E               1443	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0F3E               1444	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0F3E               1445	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0F3E               1446	
0F3E               1447	#	See also >CFA and >DFA.
0F3E               1448	#	FIND doesn't find dictionary entries which are flagged as HIDDEN.  See below for why.
0F3E               1449	
0F3E 10F40002      1450	C_FIND		LD4	R0,[SP + 2]	; begin
0F42 11F40000      1451			LD4	R1,[SP] 	; len
0F46 0FF80001      1452			ENTER	1
0F4A 0FFD00000004  1453			JAL	FIND
0F50 10FA0000      1454			ST4	[SP], R0
0F54 2FF0FD37      1455			BRA	NEXT
0F58               1456	
0F58 32F92014      1457	FIND		LI	R2, FORTH_LATEST
0F5C 12240000      1458			LD4	R2, [R2]
0F60 22F0001D      1459	.LOOP		BZ	R2, .DONE
0F64 13200004      1460			LD1	R3, [R2 + 4]	; load len + flags
0F68 3338003F      1461			AND	R3, F_LENMASK | F_HIDDEN
0F6C 21310013      1462			BNE	R1, R3, .NEXT
0F70               1463	
0F70               1464			# compare strings in detail
0F70 34240005      1465			ADD	R4, R2, 5
0F74 95F0          1466			MV	R5, R0
0F76 16400000      1467	.CMP		LD1	R6, [R4]
0F7A 17500000      1468			LD1	R7, [R5]
0F7E 2671000A      1469			BNE	R6, R7, .NEXT
0F82 34440001      1470			ADD	R4, 1
0F86 35540001      1471			ADD	R5, 1
0F8A 33350001      1472			SUB	R3, 1
0F8E 23F1FFF2      1473			BNZ	R3, .CMP
0F92               1474	
0F92               1475			# found
0F92 90F2          1476			MV	R0, R2
0F94 0FE0          1477			RET
0F96               1478	
0F96 12240000      1479	.NEXT		LD4	R2, [R2]	; load previous
0F9A 2FF0FFE1      1480			BRA	.LOOP
0F9E               1481	
0F9E 80FF          1482	.DONE		LI	R0, 0		; not found
0FA0 0FE0          1483			RET
0FA2               1484	
0FA2               1485	#	FIND returns the dictionary pointer, but when compiling we need the codeword pointer (recall
0FA2               1486	#	that FORTH definitions are compiled into lists of codeword pointers).  The standard FORTH
0FA2               1487	#	word >CFA turns a dictionary pointer into a codeword pointer.
0FA2               1488	#	The example below shows the result of:
0FA2               1489	#		WORD DOUBLE FIND >CFA
0FA2               1490	
0FA2               1491	#	FIND returns a pointer to this
0FA2               1492	#	|				>CFA converts it to a pointer to this
0FA2               1493	#	|					   |
0FA2               1494	#	V					   V
0FA2               1495	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0FA2               1496	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0FA2               1497	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0FA2               1498	#						   codeword
0FA2               1499	
0FA2               1500	#	Notes:
0FA2               1501	
0FA2               1502	#	Because names vary in length, this isn't just a simple increment.
0FA2               1503	
0FA2               1504	#	In this FORTH you cannot easily turn a codeword pointer back into a dictionary entry pointer, but
0FA2               1505	#	that is not true in most FORTH implementations where they store a back pointer in the definition
0FA2               1506	#	(with an obvious memory/complexity cost).  The reason they do this is that it is useful to be
0FA2               1507	#	able to go backwards (codeword -> dictionary entry) in order to decompile FORTH definitions
0FA2               1508	#	quickly.
0FA2               1509	
0FA2               1510	#	What does CFA stand for?  My best guess is "Code Field Address".
0FA2               1511	
0FA2 10F40000      1512	C_TCFA		LD4	R0, [SP]
0FA6 0FFD00000004  1513			JAL	TCFA
0FAC 10FA0000      1514			ST4	[SP], R0
0FB0 2FF0FD09      1515			BRA	NEXT
0FB4               1516	
0FB4 30040004      1517	TCFA		ADD	R0, 4		; skip link pointer
0FB8 11000000      1518			LD1	R1, [R0]	; load flags + len
0FBC 3118001F      1519			AND	R1, F_LENMASK	; drop flags
0FC0 31140004      1520			ADD	R1, 4		; align to 4
0FC4 311800FC      1521			AND	R1, $fc
0FC8 4001          1522			ADD	R0, R1
0FCA 0FE0          1523			RET
0FCC               1524	
0FCC               1525	#	Related to >CFA is >DFA which takes a dictionary entry address as returned by FIND and
0FCC               1526	#	returns a pointer to the first data field.
0FCC               1527	#	FIND returns a pointer to this
0FCC               1528	#	|				>CFA converts it to a pointer to this
0FCC               1529	#	|					   |
0FCC               1530	#	|					   |	>DFA converts it to a pointer to this
0FCC               1531	#	|					   |		 |
0FCC               1532	#	V					   V		 V
0FCC               1533	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0FCC               1534	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0FCC               1535	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0FCC               1536	#						   codeword
0FCC               1537	#	(Note to those following the source of FIG-FORTH / ciforth: My >DFA definition is
0FCC               1538	#	different from theirs, because they have an extra indirection).
0FCC               1539	#	You can see that >DFA is easily defined in FORTH just by adding 4 to the result of >CFA.
0FCC               1540	
0FCC               1541	#	defword ">DFA",4,,TDFA
0FCC               1542	#	.int TCFA		// >CFA 	(get code field address)
0FCC               1543	#	.int INCR4		// 4+		(add 4 to it to get to next word)
0FCC               1544	#	.int EXIT		// EXIT 	(return from FORTH word)
0FCC               1545	
0FCC               1546	#	COMPILING ----------------------------------------------------------------------
0FCC               1547	#	Now we'll talk about how FORTH compiles words.	Recall that a word definition looks like this:
0FCC               1548	#		: DOUBLE DUP + ;
0FCC               1549	#	and we have to turn this into:
0FCC               1550	#	  pointer to previous word
0FCC               1551	#	   ^
0FCC               1552	#	   |
0FCC               1553	#	+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0FCC               1554	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0FCC               1555	#	+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
0FCC               1556	#	   ^	   len			       pad  codeword	  |
0FCC               1557	#	   |							  V
0FCC               1558	#	  LATEST points here				points to codeword of DUP
0FCC               1559	
0FCC               1560	#	There are several problems to solve.  Where to put the new word?  How do we read words?  How
0FCC               1561	#	do we define the words : (COLON) and ; (SEMICOLON)?
0FCC               1562	
0FCC               1563	#	FORTH solves this rather elegantly and as you might expect in a very low-level way which
0FCC               1564	#	allows you to change how the compiler works on your own code.
0FCC               1565	
0FCC               1566	#	FORTH has an INTERPRET function (a true interpreter this time, not DOCOL) which runs in a
0FCC               1567	#	loop, reading words (using WORD), looking them up (using FIND), turning them into codeword
0FCC               1568	#	pointers (using >CFA) and deciding what to do with them.
0FCC               1569	
0FCC               1570	#	What it does depends on the mode of the interpreter (in variable STATE).
0FCC               1571	
0FCC               1572	#	When STATE is zero, the interpreter just runs each word as it looks them up.  This is known as
0FCC               1573	#	immediate mode.
0FCC               1574	
0FCC               1575	#	The interesting stuff happens when STATE is non-zero -- compiling mode.  In this mode the
0FCC               1576	#	interpreter appends the codeword pointer to user memory (the HERE variable points to the next
0FCC               1577	#	free byte of user memory -- see DATA SEGMENT section below).
0FCC               1578	
0FCC               1579	#	So you may be able to see how we could define : (COLON).  The general plan is:
0FCC               1580	
0FCC               1581	#	(1) Use WORD to read the name of the function being defined.
0FCC               1582	#	(2) Construct the dictionary entry -- just the header part -- in user memory:
0FCC               1583	
0FCC               1584	#   pointer to previous word (from LATEST)			+-- Afterwards, HERE points here, where
0FCC               1585	#	   ^							|   the interpreter will start appending
0FCC               1586	#	   |							V   codewords.
0FCC               1587	#	+--|------+---+---+---+---+---+---+---+---+------------+
0FCC               1588	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      |
0FCC               1589	#	+---------+---+---+---+---+---+---+---+---+------------+
0FCC               1590	#		   len			       pad  codeword
0FCC               1591	
0FCC               1592	#	(3) Set LATEST to point to the newly defined word, ...
0FCC               1593	#	(4) .. and most importantly leave HERE pointing just after the new codeword.  This is where
0FCC               1594	#	    the interpreter will append codewords.
0FCC               1595	#	(5) Set STATE to 1.  This goes into compile mode so the interpreter starts appending codewords to
0FCC               1596	#	    our partially-formed header.
0FCC               1597	
0FCC               1598	#	After : has run, our input is here:
0FCC               1599	
0FCC               1600	#	: DOUBLE DUP + ;
0FCC               1601	#		 ^
0FCC               1602	#		 |
0FCC               1603	#		Next byte returned by KEY will be the 'D' character of DUP
0FCC               1604	
0FCC               1605	#	so the interpreter (now it's in compile mode, so I guess it's really the compiler) reads "DUP",
0FCC               1606	#	looks it up in the dictionary, gets its codeword pointer, and appends it:
0FCC               1607	
0FCC               1608	#									     +-- HERE updated to point here.
0FCC               1609	#									     |
0FCC               1610	#									     V
0FCC               1611	#	+---------+---+---+---+---+---+---+---+---+------------+------------+
0FCC               1612	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    |
0FCC               1613	#	+---------+---+---+---+---+---+---+---+---+------------+------------+
0FCC               1614	#		   len			       pad  codeword
0FCC               1615	
0FCC               1616	#	Next we read +, get the codeword pointer, and append it:
0FCC               1617	
0FCC               1618	#											  +-- HERE updated to point here.
0FCC               1619	#											  |
0FCC               1620	#											  V
0FCC               1621	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
0FCC               1622	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 |
0FCC               1623	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
0FCC               1624	#		   len			       pad  codeword
0FCC               1625	
0FCC               1626	#	The issue is what happens next.  Obviously what we _don't_ want to happen is that we
0FCC               1627	#	read ";" and compile it and go on compiling everything afterwards.
0FCC               1628	
0FCC               1629	#	At this point, FORTH uses a trick.  Remember the length byte in the dictionary definition
0FCC               1630	#	isn't just a plain length byte, but can also contain flags.  One flag is called the
0FCC               1631	#	IMMEDIATE flag (F_IMMED in this code).	If a word in the dictionary is flagged as
0FCC               1632	#	IMMEDIATE then the interpreter runs it immediately _even if it's in compile mode_.
0FCC               1633	
0FCC               1634	#	This is how the word ; (SEMICOLON) works -- as a word flagged in the dictionary as IMMEDIATE.
0FCC               1635	
0FCC               1636	#	And all it does is append the codeword for EXIT on to the current definition and switch
0FCC               1637	#	back to immediate mode (set STATE back to 0).  Shortly we'll see the actual definition
0FCC               1638	#	of ; and we'll see that it's really a very simple definition, declared IMMEDIATE.
0FCC               1639	
0FCC               1640	#	After the interpreter reads ; and executes it 'immediately', we get this:
0FCC               1641	
0FCC               1642	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0FCC               1643	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP	    | + 	 | EXIT       |
0FCC               1644	#	+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
0FCC               1645	#		   len			       pad  codeword					       ^
0FCC               1646	#												       |
0FCC               1647	#												      HERE
0FCC               1648	#	STATE is set to 0.
0FCC               1649	
0FCC               1650	#	And that's it, job done, our new definition is compiled, and we're back in immediate mode
0FCC               1651	#	just reading and executing words, perhaps including a call to test our new word DOUBLE.
0FCC               1652	
0FCC               1653	#	The only last wrinkle in this is that while our word was being compiled, it was in a
0FCC               1654	#	half-finished state.  We certainly wouldn't want DOUBLE to be called somehow during
0FCC               1655	#	this time.  There are several ways to stop this from happening, but in FORTH what we
0FCC               1656	#	do is flag the word with the HIDDEN flag (F_HIDDEN in this code) just while it is
0FCC               1657	#	being compiled.  This prevents FIND from finding it, and thus in theory stops any
0FCC               1658	#	chance of it being called.
0FCC               1659	
0FCC               1660	#	The above explains how compiling, : (COLON) and ; (SEMICOLON) works and in a moment I'm
0FCC               1661	#	going to define them.  The : (COLON) function can be made a little bit more general by writing
0FCC               1662	#	it in two parts.  The first part, called CREATE, makes just the header:
0FCC               1663	
0FCC               1664	#						   +-- Afterwards, HERE points here.
0FCC               1665	#						   |
0FCC               1666	#						   V
0FCC               1667	#	+---------+---+---+---+---+---+---+---+---+
0FCC               1668	#	| LINK	  | 6 | D | O | U | B | L | E | 0 |
0FCC               1669	#	+---------+---+---+---+---+---+---+---+---+
0FCC               1670	#		   len			       pad
0FCC               1671	
0FCC               1672	#	and the second part, the actual definition of : (COLON), calls CREATE and appends the
0FCC               1673	#	DOCOL codeword, so leaving:
0FCC               1674	
0FCC               1675	#								+-- Afterwards, HERE points here.
0FCC               1676	#								|
0FCC               1677	#								V
0FCC               1678	#	+---------+---+---+---+---+---+---+---+---+------------+
0FCC               1679	#	| LINK	  | 6 | D | O | U | B | L | E | 0 | DOCOL      |
0FCC               1680	#	+---------+---+---+---+---+---+---+---+---+------------+
0FCC               1681	#		   len			       pad  codeword
0FCC               1682	
0FCC               1683	#	CREATE is a standard FORTH word and the advantage of this split is that we can reuse it to
0FCC               1684	#	create other types of words (not just ones which contain code, but words which contain variables,
0FCC               1685	#	constants and other data).
0FCC               1686	
0FCC 10F40002      1687	C_CREATE	LD4	R0, [SP + 2]
0FD0 11F40000      1688			LD4	R1, [SP]
0FD4 0FF80002      1689			ENTER	2
0FD8 82FF          1690			LI	R2, 0
0FDA 13240804      1691			LD4	R3, [R2 + FORTH_HERE / 4]
0FDE 14240805      1692			LD4	R4, [R2 + FORTH_LATEST / 4]
0FE2 143A0000      1693			ST4	[R3], R4	; store link pointer
0FE6               1694	
0FE6               1695			# update LATEST
0FE6 132A0805      1696			ST4	[R2 + FORTH_LATEST / 4], R3
0FEA 33340004      1697			ADD	R3, 4
0FEE               1698	
0FEE               1699			# store length & flags
0FEE 11380000      1700			ST1	[R3], R1
0FF2               1701	
0FF2               1702			# store name
0FF2 14000000      1703	.COPY		LD1	R4, [R0]
0FF6 33340001      1704			ADD	R3, 1
0FFA 30040001      1705			ADD	R0, 1
0FFE 31150001      1706			SUB	R1, 1
1002 14380000      1707			ST1	[R3], R4
1006 21F1FFF4      1708			BNZ	R1, .COPY
100A               1709	
100A               1710			# align to 4
100A 33340004      1711			ADD	R3, 4
100E 3338FFFC      1712			AND	R3, -4	; #~3
1012               1713	
1012               1714			# update HERE
1012 132A0804      1715			ST4	[R2 + FORTH_HERE / 4], R3
1016 2FF0FCD6      1716			BRA	NEXT
101A               1717	
101A               1718	#	Because I want to define : (COLON) in FORTH, not assembler, we need a few more FORTH words
101A               1719	#	to use.
101A               1720	
101A               1721	#	The first is , (COMMA) which is a standard FORTH word which appends a 32 bit integer to the user
101A               1722	#	memory pointed to by HERE, and adds 4 to HERE.	So the action of , (COMMA) is:
101A               1723	
101A               1724	#							previous value of HERE
101A               1725	#								 |
101A               1726	#								 V
101A               1727	#	+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
101A               1728	#	| LINK	  | 6 | D | O | U | B | L | E | 0 |		|  <data>    |
101A               1729	#	+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
101A               1730	#		   len			       pad			      ^
101A               1731	#									      |
101A               1732	#									new value of HERE
101A               1733	
101A               1734	#	and <data> is whatever 32 bit integer was at the top of the stack.
101A               1735	
101A               1736	#	, (COMMA) is quite a fundamental operation when compiling.  It is used to append codewords
101A               1737	#	to the current word that is being compiled.
101A               1738	
101A 10F40000      1739	C_COMMA 	LD4	R0, [SP]
101E 0FF80001      1740			ENTER	1
1022 0FFD00000002  1741			JAL	COMMA
1028 2FF0FCCD      1742			BRA	NEXT
102C               1743	
102C 81FF          1744	COMMA:		LI	R1, 0
102E 12140804      1745			LD4	R2, [R1 + FORTH_HERE / 4]
1032 102A0000      1746			ST4	[R2], R0
1036 32240004      1747			ADD	R2, 4
103A 121A0804      1748			ST4	[R1 + FORTH_HERE / 4], R2
103E 0FE0          1749			RET
1040               1750	
1040               1751	#	Our definitions of : (COLON) and ; (SEMICOLON) will need to switch to and from compile mode.
1040               1752	#	Immediate mode vs. compile mode is stored in the global variable STATE, and by updating this
1040               1753	#	variable we can switch between the two modes.
1040               1754	
1040               1755	#	For various reasons which may become apparent later, FORTH defines two standard words called
1040               1756	#	[ and ] (LBRAC and RBRAC) which switch between modes:
1040               1757	
1040               1758	#	Word	Assembler	Action		Effect
1040               1759	#	[	LBRAC		STATE := 0	Switch to immediate mode.
1040               1760	#	]	RBRAC		STATE := 1	Switch to compile mode.
1040               1761	
1040               1762	#	[ (LBRAC) is an IMMEDIATE word.  The reason is as follows: If we are in compile mode and the
1040               1763	#	interpreter saw [ then it would compile it rather than running it.  We would never be able to
1040               1764	#	switch back to immediate mode!	So we flag the word as IMMEDIATE so that even in compile mode
1040               1765	#	the word runs immediately, switching us back to immediate mode.
1040               1766	
1040 80FF          1767	C_LBRAC 	LI	R0, 0
1042 100A0803      1768			ST4	[R0 + FORTH_STATE / 4], R0
1046 2FF0FCBE      1769			BRA	NEXT
104A               1770	
104A 80FF          1771	C_RBRAC 	LI	R0, 0
104C 01F8          1772			LI	R1, 1
104E 110A0803      1773			ST4	[R0 + FORTH_STATE / 4], R1
1052 2FF0FCB8      1774			BRA	NEXT
1056               1775	
1056               1776	#	Now we can define : (COLON) using CREATE.  It just calls CREATE, appends DOCOL (the codeword), sets
1056               1777	#	the word HIDDEN and goes into compile mode.
1056               1778	
1056               1779	#	defword ":",1,,COLON
1056               1780	#	.int WORD		// Get the name of the new word
1056               1781	#	.int CREATE		// CREATE the dictionary entry / header
1056               1782	#	.int LIT, DOCOL, COMMA	// Append DOCOL  (the codeword).
1056               1783	#	.int LATEST, FETCH, HIDDEN // Make the word hidden (see below for definition).
1056               1784	#	.int RBRAC		// Go into compile mode.
1056               1785	#	.int EXIT		// Return from the function.
1056               1786	
1056               1787	# (SEMICOLON) is also elegantly simple.  Notice the F_IMMED flag.
1056               1788	
1056               1789	#	defword ";",1,F_IMMED,SEMICOLON
1056               1790	#	.int LIT, EXIT, COMMA	// Append EXIT (so the word will return).
1056               1791	#	.int LATEST, FETCH, HIDDEN // Toggle hidden flag -- unhide the word (see below for definition).
1056               1792	#	.int LBRAC		// Go back to IMMEDIATE mode.
1056               1793	#	.int EXIT		// Return from the function.
1056               1794	
1056               1795	#	EXTENDING THE COMPILER ----------------------------------------------------------------------
1056               1796	
1056               1797	#	Words flagged with IMMEDIATE (F_IMMED) aren't just for the FORTH compiler to use.  You can define
1056               1798	#	your own IMMEDIATE words too, and this is a crucial aspect when extending basic FORTH, because
1056               1799	#	it allows you in effect to extend the compiler itself.	Does gcc let you do that?
1056               1800	
1056               1801	#	Standard FORTH words like IF, WHILE, ." and so on are all written as extensions to the basic
1056               1802	#	compiler, and are all IMMEDIATE words.
1056               1803	
1056               1804	#	The IMMEDIATE word toggles the F_IMMED (IMMEDIATE flag) on the most recently defined word,
1056               1805	#	or on the current word if you call it in the middle of a definition.
1056               1806	
1056               1807	#	Typical usage is:
1056               1808	#	: MYIMMEDWORD IMMEDIATE
1056               1809	#		...definition...
1056               1810	#	;
1056               1811	
1056               1812	#	but some FORTH programmers write this instead:
1056               1813	#	: MYIMMEDWORD
1056               1814	#		...definition...
1056               1815	#	; IMMEDIATE
1056               1816	
1056               1817	#	The two usages are equivalent, to a first approximation.
1056               1818	
1056 80FF          1819	C_IMMEDIATE	LI	R0, 0
1058 11042014      1820			LD4	R1, [R0 + FORTH_LATEST]
105C 12100004      1821			LD1	R2, [R1 + 4]
1060 322A0080      1822			XOR	R2, F_IMMED
1064 12180004      1823			ST1	[R1 + 4], R2
1068 2FF0FCAD      1824			BRA	NEXT
106C               1825	
106C               1826	#	'addr HIDDEN' toggles the hidden flag (F_HIDDEN) of the word defined at addr.  To hide the
106C               1827	#	most recently defined word (used above in : and ; definitions) you would do:
106C               1828	#		LATEST @ HIDDEN
106C               1829	
106C               1830	#	'HIDE word' toggles the flag on a named 'word'.
106C               1831	
106C               1832	#	Setting this flag stops the word from being found by FIND, and so can be used to make 'private'
106C               1833	#	words.	For example, to break up a large word into smaller parts you might do:
106C               1834	#		: SUB1 ... subword ... ;
106C               1835	#		: SUB2 ... subword ... ;
106C               1836	#		: SUB3 ... subword ... ;
106C               1837	#		: MAIN ... defined in terms of SUB1, SUB2, SUB3 ... ;
106C               1838	#		HIDE SUB1
106C               1839	#		HIDE SUB2
106C               1840	#		HIDE SUB3
106C               1841	
106C               1842	#	After this, only MAIN is 'exported' or seen by the rest of the program.
106C               1843	
106C 10F40000      1844	C_HIDDEN	LD4	R0, [SP]
1070 0FF80001      1845			ENTER	1
1074 11000004      1846			LD1	R1, [R0 + 4]
1078 311A0020      1847			XOR	R1, F_HIDDEN
107C 11080004      1848			ST1	[R0 + 4], R1
1080 2FF0FCA1      1849			BRA	NEXT
1084               1850	
1084               1851	#	defword "HIDE",4,,HIDE
1084               1852	#	.int WORD		// Get the word (after HIDE).
1084               1853	#	.int FIND		// Look up in the dictionary.
1084               1854	#	.int HIDDEN		// Set F_HIDDEN flag.
1084               1855	#	.int EXIT		// Return.
1084               1856	
1084               1857	#	' (TICK) is a standard FORTH word which returns the codeword pointer of the next word.
1084               1858	#	The common usage is:
1084               1859	#	' FOO ,
1084               1860	
1084               1861	#	which appends the codeword of FOO to the current word we are defining (this only works in compiled code).
1084               1862	#	You tend to use ' in IMMEDIATE words.  For example an alternate (and rather useless) way to define
1084               1863	#	a literal 2 might be:
1084               1864	
1084               1865	#	: LIT2 IMMEDIATE
1084               1866	#		' LIT , 	\ Appends LIT to the currently-being-defined word
1084               1867	#		2 ,		\ Appends the number 2 to the currently-being-defined word
1084               1868	#	;
1084               1869	
1084               1870	#	So you could do:
1084               1871	
1084               1872	#	: DOUBLE LIT2 * ;
1084               1873	
1084               1874	#	(If you don't understand how LIT2 works, then you should review the material about compiling words
1084               1875	#	and immediate mode).
1084               1876	
1084               1877	#	This definition of ' uses a cheat which I copied from buzzard92.  As a result it only works in
1084               1878	#	compiled code.	It is possible to write a version of ' based on WORD, FIND, >CFA which works in
1084               1879	#	immediate mode too.
1084 10C40000      1880	C_TICK		LD4	R0, [R12]
1088 0FF8FFFF      1881			ENTER	-1
108C 3CC40004      1882			ADD	R12, 4
1090 10FA0000      1883			ST4	[SP], R0
1094 2FF0FC97      1884			BRA	NEXT
1098               1885	
1098               1886	#	BRANCHING ----------------------------------------------------------------------
1098               1887	
1098               1888	#	It turns out that all you need in order to define looping constructs, IF-statements, etc.
1098               1889	#	are two primitives.
1098               1890	
1098               1891	#	BRANCH is an unconditional branch. 0BRANCH is a conditional branch (it only branches if the
1098               1892	#	top of stack is zero).
1098               1893	
1098               1894	#	The diagram below shows how BRANCH works in some imaginary compiled word.  When BRANCH executes,
1098               1895	#	%esi starts by pointing to the offset field (compare to LIT above):
1098               1896	
1098               1897	#	+---------------------+-------+---- - - ---+------------+------------+---- - - - ----+------------+
1098               1898	#	| (Dictionary header) | DOCOL | 	   | BRANCH	| offset     | (skipped)     | word	  |
1098               1899	#	+---------------------+-------+---- - - ---+------------+-----|------+---- - - - ----+------------+
1098               1900	#								   ^  | 		      ^
1098               1901	#								   |  | 		      |
1098               1902	#								   |  +-----------------------+
1098               1903	#								  %esi added to offset
1098               1904	
1098               1905	#	The offset is added to %esi to make the new %esi, and the result is that when NEXT runs, execution
1098               1906	#	continues at the branch target.  Negative offsets work as expected.
1098               1907	
1098               1908	#	0BRANCH is the same except the branch happens conditionally.
1098               1909	
1098               1910	#	Now standard FORTH words such as IF, THEN, ELSE, WHILE, REPEAT, etc. can be implemented entirely
1098               1911	#	in FORTH.  They are IMMEDIATE words which append various combinations of BRANCH or 0BRANCH
1098               1912	#	into the word currently being compiled.
1098               1913	
1098               1914	#	As an example, code written like this:
1098               1915	
1098               1916	#		condition-code IF true-part THEN rest-code
1098               1917	
1098               1918	#	compiles to:
1098               1919	
1098               1920	#		condition-code 0BRANCH OFFSET true-part rest-code
1098               1921	#					  |		^
1098               1922	#					  |		|
1098               1923	#					  +-------------+
1098 10C40000      1924	C_BRANCH	LD4	R0, [R12]
109C 4CC0          1925			ADD	R12, R0
109E 2FF0FC92      1926			BRA	NEXT
10A2               1927	
10A2 10F40000      1928	C_ZBRANCH	LD4	R0, [SP]
10A6 0FF80001      1929			ENTER	1
10AA 20F0FFF5      1930			BZ	R0, C_BRANCH	; branch if zero
10AE 3CC40004      1931			ADD	R12, 4		; skip offset
10B2 2FF0FC88      1932			BRA	NEXT
10B6               1933	
10B6               1934	#	LITERAL STRINGS ----------------------------------------------------------------------
10B6               1935	
10B6               1936	#	LITSTRING is a primitive used to implement the ." and S" operators (which are written in
10B6               1937	#	FORTH).  See the definition of those operators later.
10B6               1938	
10B6               1939	#	TELL just prints a string.  It's more efficient to define this in assembly because we
10B6               1940	#	can make it a single Linux syscall.
10B6               1941	
10B6 10C40000      1942	C_LITSTRING	LD4	R0, [R12]
10BA 0FF8FFFE      1943			ENTER	-2
10BE 3CC40004      1944			ADD	R12, 4
10C2 1CFAFFFE      1945			ST4	[SP - 2], R12	; push string start addr
10C6 10FA0000      1946			ST4	[SP], R0	; push len
10CA 4CC0          1947			ADD	R12, R0 	; skip past the string
10CC 3CC40003      1948			ADD	R12, 3
10D0 3CC8FFFC      1949			AND	R12, -4 	; align to 4
10D4 2FF0FC77      1950			BRA	NEXT
10D8               1951	
10D8 13F40002      1952	C_TELL		LD4	R3, [SP + 2]	; string addr
10DC 14F40000      1953			LD4	R4, [SP]	; len
10E0 24F0FC71      1954	.LOOP		BZ	R4, NEXT
10E4 10300000      1955			LD1	R0, [R3]
10E8 33340001      1956			ADD	R3, 1
10EC 0FFDFFFFF7F9  1957			JAL	CONOUT
10F2 34450001      1958			SUB	R4, 1
10F6 2FF0FFF3      1959			BRA	.LOOP
10FA               1960	
10FA               1961	
10FA               1962	#	CHAR puts the ASCII code of the first character of the following word on the stack.  For example
10FA               1963	#	CHAR A puts 65 on the stack.
10FA               1964	
10FA               1965	#	EXECUTE is used to run execution tokens.  See the discussion of execution tokens in the
10FA               1966	#	FORTH code for more details.
10FA 0FFDFFFFFEA3  1967	C_CHAR		JAL	WORD	; R0 = word addr, R1 = len
1100 0FF8FFFF      1968			ENTER	-1
1104 10000000      1969			LD1	R0, [R0]
1108 10FA0000      1970			ST4	[SP], R0
110C 2FF0FC5B      1971			BRA	NEXT
1110               1972	
1110 10F40000      1973	C_EXECUTE	LD4	R0, [SP]
1114 0FF80001      1974			ENTER	1
1118 10040000      1975			LD4	R0, [R0]
111C 0F00          1976			JMP	R0
111E               1977	
111E               1978	#	QUIT AND INTERPRET ----------------------------------------------------------------------
111E               1979	
111E               1980	#	QUIT is the first FORTH function called, almost immediately after the FORTH system "boots".
111E               1981	#	As explained before, QUIT doesn't "quit" anything.  It does some initialisation (in particular
111E               1982	#	it clears the return stack) and it calls INTERPRET in a loop to interpret commands.  The
111E               1983	#	reason it is called QUIT is because you can call it from your own FORTH words in order to
111E               1984	#	"quit" your program and start again at the user prompt.
111E               1985	
111E               1986	#	INTERPRET is the FORTH interpreter ("toploop", "toplevel" or "REPL" might be a more accurate
111E               1987	#	description -- see: http://en.wikipedia.org/wiki/REPL).
111E               1988	
111E               1989	#	defword "QUIT",4,,QUIT
111E               1990	#	.int RZ,RSPSTORE	// R0 RSP!, clear the return stack
111E               1991	#	.int INTERPRET		// interpret the next word
111E               1992	#	.int BRANCH,-8		// and loop (indefinitely)
111E               1993	
111E               1994	#	This interpreter is pretty simple, but remember that in FORTH you can always override
111E               1995	#	it later with a more powerful one!
111E 0FFDFFFFFE91  1996	C_INTERPRET	JAL	WORD		; R0 = addr, R1 = len
1124 8AFF          1997			LI	R10, 0		; literal flag
1126 9BF0          1998			MV	R11, R0 	; save R0
1128 0FFDFFFFFF15  1999			JAL	FIND
112E 20F0000C      2000			BZ	R0, .NOTFOUND
1132 92F0          2001			MV	R2, R0
1134 13200004      2002			LD1	R3, [R2 + 4]	; get len + flags
1138 0FFDFFFFFF3B  2003			JAL	TCFA		; get codeword
113E 33380080      2004			AND	R3, F_IMMED
1142 23F1001D      2005			BNZ	R3, .DOEXEC
1146 2FF0000A      2006			BRA	.CHOICE
114A               2007	
114A               2008	.NOTFOUND	; not a word, assume a literal
114A 0AF8          2009			LI	R10, 1
114C 90FB          2010			MV	R0, R11
114E 0FFDFFFFFEB7  2011			JAL	NUMBER
1154 21F1001F      2012			BNZ	R1, .ERROR
1158 93F0          2013			MV	R3, R0
115A 30F9135C      2014			LI	R0, B_LIT
115E               2015	
115E               2016	.CHOICE 	; codeword in R0: compiling or executing ?
115E 31F9200C      2017			LI	R1, FORTH_STATE
1162 11140000      2018			LD4	R1, [R1]
1166 21F0000B      2019			BZ	R1, .DOEXEC
116A               2020	
116A               2021			; compiling: just append the word
116A 0FFDFFFFFF5E  2022			JAL	COMMA
1170 2AF00004      2023			BZ	R10, .NOLIT
1174 90F3          2024			MV	R0, R3
1176 0FFDFFFFFF58  2025			JAL	COMMA
117C 2FF0FC23      2026	.NOLIT		BRA	NEXT
1180               2027	
1180               2028	.DOEXEC 	; executing: run it
1180 2AF10003      2029			BNZ	R10, .ISLIT
1184 11040000      2030			LD4	R1, [R0]
1188 0F10          2031			JMP	R1
118A 0FF8FFFF      2032	.ISLIT		ENTER	-1
118E 13FA0000      2033			ST4	[SP], R3
1192 2FF0FC18      2034			BRA	NEXT
1196               2035	
1196               2036	.ERROR		; parser error
1196 30F91DF2      2037			LI	R0, PARSER_ERROR
119A 0FFDFFFFF7A9  2038			JAL	CONSTR
11A0 2FF0FC11      2039			BRA	NEXT
####################### dict.asm
11A4                  1	#
11A4                  2	# jforth builtin dictionary
11A4                  3	#
11A4                  4			.ALIGN	4
11A4                  5	
11A4 00000000         6	F_DROP		.LONG	0	; link to previous
11A8 04               7			.BYTE	4	; flags + namelen
11A9 44524F50         8			.BYTE	"DROP"
11AD 000000           9			.ALIGN	4
11B0 000009D4        10	B_DROP		.LONG	C_DROP
11B4                 11	
11B4 000011A4        12	F_BLOCK 	.LONG	F_DROP
11B8 05              13			.BYTE	5
11B9 424C4F434B      14			.BYTE	"BLOCK"
11BE 0000            15			.ALIGN	4
11C0 000009DC        16			.LONG	C_BLOCK
11C4                 17	
11C4 000011B4        18	F_WRITE 	.LONG	F_BLOCK
11C8 05              19			.BYTE	5
11C9 5752495445      20			.BYTE	"WRITE"
11CE 0000            21			.ALIGN	4
11D0 000009F0        22			.LONG	C_WRITE
11D4                 23	
11D4 000011C4        24	F_SWAP		.LONG	F_WRITE
11D8 04              25			.BYTE	4	; flags + namelen
11D9 53574150        26			.BYTE	"SWAP"
11DD 000000          27			.ALIGN	4
11E0 00000A06        28	B_SWAP		.LONG	C_SWAP
11E4                 29	
11E4 000011D4        30	F_DUP		.LONG	F_SWAP	; link to previous
11E8 03              31			.BYTE	3	; flags + namelen
11E9 445550          32			.BYTE	"DUP"
11EC                 33			.ALIGN	4
11EC 00000A1A        34	B_DUP		.LONG	C_DUP
11F0                 35	
11F0 000011E4        36	F_OVER		.LONG	F_DUP	; link to previous
11F4 04              37			.BYTE	4	; flags + namelen
11F5 4F564552        38			.BYTE	"OVER"
11F9 000000          39			.ALIGN	4
11FC 00000A2A        40			.LONG	C_OVER
1200                 41	
1200 000011F0        42	F_ROT		.LONG	F_OVER	; link to previous
1204 03              43			.BYTE	3	; flags + namelen
1205 524F54          44			.BYTE	"ROT"
1208                 45			.ALIGN	4
1208 00000A3A        46	B_ROT		.LONG	C_ROT
120C                 47	
120C 00001200        48	F_NROT		.LONG	F_ROT	; link to previous
1210 04              49			.BYTE	4	; flags + namelen
1211 2D524F54        50			.BYTE	"-ROT"
1215 000000          51			.ALIGN	4
1218 00000A56        52			.LONG	C_NROT
121C                 53	
121C 0000120C        54	F_QDUP		.LONG	F_NROT	; link to previous
1220 04              55			.BYTE	4	; flags + namelen
1221 3F445550        56			.BYTE	"?DUP"
1225 000000          57			.ALIGN	4
1228 00000A72        58	B_QDUP		.LONG	C_QDUP
122C                 59	
122C 0000121C        60	F_INCR		.LONG	F_QDUP	; link to previous
1230 02              61			.BYTE	2	; flags + namelen
1231 312B            62			.BYTE	"1+"
1233 00              63			.ALIGN	4
1234 00000A86        64	B_INCR		.LONG	C_INCR
1238                 65	
1238 0000122C        66	F_DECR		.LONG	F_INCR	; link to previous
123C 02              67			.BYTE	2	; flags + namelen
123D 312D            68			.BYTE	"1-"
123F 00              69			.ALIGN	4
1240 00000A96        70	B_DECR		.LONG	C_DECR
1244                 71	
1244 00001238        72	F_INCR4 	.LONG	F_DECR	; link to previous
1248 02              73			.BYTE	2	; flags + namelen
1249 342B            74			.BYTE	"4+"
124B 00              75			.ALIGN	4
124C 00000AA6        76	B_INCR4 	.LONG	C_INCR4
1250                 77	
1250 00001244        78	F_DECR4 	.LONG	F_INCR4 ; link to previous
1254 02              79			.BYTE	2	; flags + namelen
1255 342D            80			.BYTE	"4-"
1257 00              81			.ALIGN	4
1258 00000AB6        82			.LONG	C_DECR4
125C                 83	
125C 00001250        84	F_ADD		.LONG	F_DECR4 ; link to previous
1260 01              85			.BYTE	1	; flags + namelen
1261 2B              86			.BYTE	"+"
1262 0000            87			.ALIGN	4
1264 00000AC6        88	B_ADD		.LONG	C_ADD
1268                 89	
1268 0000125C        90	F_SUB		.LONG	F_ADD	; link to previous
126C 01              91			.BYTE	1	; flags + namelen
126D 2D              92			.BYTE	"-"
126E 0000            93			.ALIGN	4
1270 00000ADC        94	B_SUB		.LONG	C_SUB
1274                 95	
1274 00001268        96	F_CRC32 	.LONG	F_SUB
1278 05              97			.BYTE	5
1279 4352433332      98			.BYTE	"CRC32"
127E 0000            99			.ALIGN	4
1280 00000AF2       100			.LONG	C_CRC32
1284                101	
1284 00001274       102	F_MUL		.LONG	F_CRC32
1288 01             103			.BYTE	1
1289 2A             104			.BYTE	"*"
128A 0000           105			.ALIGN	4
128C 00000B0C       106	B_MUL		.LONG	C_MUL
1290                107	
1290 00001284       108	F_EQU		.LONG	F_MUL	; link to previous
1294 01             109			.BYTE	1	; flags + namelen
1295 3D             110			.BYTE	"="
1296 0000           111			.ALIGN	4
1298 00000B3C       112			.LONG	C_EQU
129C                113	
129C 00001290       114	F_NEQU		.LONG	F_EQU	; link to previous
12A0 02             115			.BYTE	2	; flags + namelen
12A1 3C3E           116			.BYTE	"<>"
12A3 00             117			.ALIGN	4
12A4 00000B54       118			.LONG	C_NEQU
12A8                119	
12A8 0000129C       120	F_LT		.LONG	F_NEQU	; link to previous
12AC 01             121			.BYTE	1	; flags + namelen
12AD 3C             122			.BYTE	"<"
12AE 0000           123			.ALIGN	4
12B0 00000B6C       124	B_LT		.LONG	C_LT
12B4                125	
12B4 000012A8       126	F_GT		.LONG	F_LT	; link to previous
12B8 01             127			.BYTE	1	; flags + namelen
12B9 3E             128			.BYTE	">"
12BA 0000           129			.ALIGN	4
12BC 00000B84       130			.LONG	C_GT
12C0                131	
12C0 000012B4       132	F_LE		.LONG	F_GT	; link to previous
12C4 02             133			.BYTE	2	; flags + namelen
12C5 3C3D           134			.BYTE	"<="
12C7 00             135			.ALIGN	4
12C8 00000B9C       136			.LONG	C_LE
12CC                137	
12CC 000012C0       138	F_GE		.LONG	F_LE	; link to previous
12D0 02             139			.BYTE	2	; flags + namelen
12D1 3E3D           140			.BYTE	">="
12D3 00             141			.ALIGN	4
12D4 00000BB4       142			.LONG	C_GE
12D8                143	
12D8 000012CC       144	F_ZEQU		.LONG	F_GE	; link to previous
12DC 02             145			.BYTE	2	; flags + namelen
12DD 303D           146			.BYTE	"0="
12DF 00             147			.ALIGN	4
12E0 00000BCC       148	B_ZEQU		.LONG	C_ZEQU
12E4                149	
12E4 000012D8       150	F_ZNEQU 	.LONG	F_ZEQU	; link to previous
12E8 03             151			.BYTE	3	; flags + namelen
12E9 303C3E         152			.BYTE	"0<>"
12EC                153			.ALIGN	4
12EC 00000BDA       154			.LONG	C_ZNEQU
12F0                155	
12F0 000012E4       156	F_ZLT		.LONG	F_ZNEQU ; link to previous
12F4 02             157			.BYTE	2	; flags + namelen
12F5 303C           158			.BYTE	"0<"
12F7 00             159			.ALIGN	4
12F8 00000BE8       160	B_ZLT		.LONG	C_ZLT
12FC                161	
12FC 000012F0       162	F_ZGT		.LONG	F_ZLT	; link to previous
1300 02             163			.BYTE	2	; flags + namelen
1301 303E           164			.BYTE	"0>"
1303 00             165			.ALIGN	4
1304 00000BF6       166	B_ZGT		.LONG	C_ZGT
1308                167	
1308 000012FC       168	F_ZLE		.LONG	F_ZGT	; link to previous
130C 03             169			.BYTE	3	; flags + namelen
130D 303C3D         170			.BYTE	"0<="
1310                171			.ALIGN	4
1310 00000C04       172			.LONG	C_ZLE
1314                173	
1314 00001308       174	F_ZGE		.LONG	F_ZLE	; link to previous
1318 03             175			.BYTE	3	; flags + namelen
1319 303E3D         176			.BYTE	"0>="
131C                177			.ALIGN	4
131C 00000C12       178			.LONG	C_ZGE
1320                179	
1320 00001314       180	F_AND		.LONG	F_ZGE	; link to previous
1324 03             181			.BYTE	3	; flags + namelen
1325 414E44         182			.BYTE	"AND"
1328                183			.ALIGN	4
1328 00000C20       184			.LONG	C_AND
132C                185	
132C 00001320       186	F_OR		.LONG	F_AND	; link to previous
1330 02             187			.BYTE	2	; flags + namelen
1331 4F52           188			.BYTE	"OR"
1333 00             189			.ALIGN	4
1334 00000C36       190			.LONG	C_OR
1338                191	
1338 0000132C       192	F_XOR		.LONG	F_OR	; link to previous
133C 03             193			.BYTE	3	; flags + namelen
133D 584F52         194			.BYTE	"XOR"
1340                195			.ALIGN	4
1340 00000C4C       196			.LONG	C_XOR
1344                197	
1344 00001338       198	F_EXIT		.LONG	F_XOR	; link to previous
1348 04             199			.BYTE	4	; flags + namelen
1349 45584954       200			.BYTE	"EXIT"
134D 000000         201			.ALIGN	4
1350 00000C62       202	B_EXIT		.LONG	C_EXIT
1354                203	
1354 00001344       204	F_LIT		.LONG	F_EXIT	; link to previous
1358 03             205			.BYTE	3	; flags + namelen
1359 4C4954         206			.BYTE	"LIT"
135C                207			.ALIGN	4
135C 00000C6E       208	B_LIT		.LONG	C_LIT
1360                209	
1360 00001354       210	F_STORE 	.LONG	F_LIT	; link to previous
1364 01             211			.BYTE	1	; flags + namelen
1365 21             212			.BYTE	"!"
1366 0000           213			.ALIGN	4
1368 00000C82       214	B_STORE 	.LONG	C_STORE
136C                215	
136C 00001360       216	F_FETCH 	.LONG	F_STORE ; link to previous
1370 01             217			.BYTE	1	; flags + namelen
1371 40             218			.BYTE	"@"
1372 0000           219			.ALIGN	4
1374 00000C96       220	B_FETCH 	.LONG	C_FETCH
1378                221	
1378 0000136C       222	F_ADDSTORE	.LONG	F_FETCH ; link to previous
137C 02             223			.BYTE	2	; flags + namelen
137D 2B21           224			.BYTE	"+!"
137F 00             225			.ALIGN	4
1380 00000CA6       226	B_ADDSTORE	.LONG	C_ADDSTORE
1384                227	
1384 00001378       228	F_SUBSTORE	.LONG	F_ADDSTORE
1388 02             229			.BYTE	2	; flags + namelen
1389 2D21           230			.BYTE	"-!"
138B 00             231			.ALIGN	4
138C 00000CC0       232			.LONG	C_SUBSTORE
1390                233	
1390 00001384       234	F_STOREBYTE	.LONG	F_SUBSTORE
1394 02             235			.BYTE	2	; flags + namelen
1395 4321           236			.BYTE	"C!"
1397 00             237			.ALIGN	4
1398 00000CDA       238			.LONG	C_STOREBYTE
139C                239	
139C 00001390       240	F_FETCHBYTE	.LONG	F_STOREBYTE
13A0 02             241			.BYTE	2	; flags + namelen
13A1 4340           242			.BYTE	"C@"
13A3 00             243			.ALIGN	4
13A4 00000CEE       244			.LONG	C_FETCHBYTE
13A8                245	
13A8 0000139C       246	F_STATE 	.LONG	F_FETCHBYTE
13AC 05             247			.BYTE	5	; flags + namelen
13AD 5354415445     248			.BYTE	"STATE"
13B2 0000           249			.ALIGN	4
13B4 00000CFE       250			.LONG	C_STATE
13B8                251	
13B8 000013A8       252	F_HERE		.LONG	F_STATE
13BC 04             253			.BYTE	4	; flags + namelen
13BD 48455245       254			.BYTE	"HERE"
13C1 000000         255			.ALIGN	4
13C4 00000D0E       256	B_HERE		.LONG	C_HERE
13C8                257	
13C8 000013B8       258	F_LATEST	.LONG	F_HERE
13CC 06             259			.BYTE	6	; flags + namelen
13CD 4C4154455354   260			.BYTE	"LATEST"
13D3 00             261			.ALIGN	4
13D4 00000D1E       262	B_LATEST	.LONG	C_LATEST
13D8                263	
13D8 000013C8       264	F_S0		.LONG	F_LATEST
13DC 02             265			.BYTE	2	; flags + namelen
13DD 5330           266			.BYTE	"S0"
13DF 00             267			.ALIGN	4
13E0 00000D2E       268	B_S0		.LONG	C_S0
13E4                269	
13E4 000013D8       270	F_BASE		.LONG	F_S0
13E8 04             271			.BYTE	4	; flags + namelen
13E9 42415345       272			.BYTE	"BASE"
13ED 000000         273			.ALIGN	4
13F0 00000D3E       274	B_BASE		.LONG	C_BASE
13F4                275	
13F4 000013E4       276	F_VERSION	.LONG	F_BASE
13F8 07             277			.BYTE	7	; flags + namelen
13F9 56455253494F   278			.BYTE	"VERSION"
13FF 4E          
1400                279			.ALIGN	4
1400 00000D4E       280			.LONG	C_VERSION
1404                281	
1404 000013F4       282	F_R0		.LONG	F_VERSION
1408 02             283			.BYTE	2	; flags + namelen
1409 5230           284			.BYTE	"R0"
140B 00             285			.ALIGN	4
140C 00000D5E       286	B_R0		.LONG	C_R0
1410                287	
1410 00001404       288	F_DOCOL 	.LONG	F_R0
1414 05             289			.BYTE	5	; flags + namelen
1415 444F434F4C     290			.BYTE	"DOCOL"
141A 0000           291			.ALIGN	4
141C 00000D6E       292			.LONG	C_DOCOL
1420                293	
1420 00001410       294	F_F_IMMED	.LONG	F_DOCOL
1424 07             295			.BYTE	7	; flags + namelen
1425 465F494D4D45   296			.BYTE	"F_IMMED"
142B 44          
142C                297			.ALIGN	4
142C 00000D7E       298			.LONG	C_F_IMMED
1430                299	
1430 00001420       300	F_F_HIDDEN	.LONG	F_F_IMMED
1434 08             301			.BYTE	8	; flags + namelen
1435 465F48494444   302			.BYTE	"F_HIDDEN"
143B 454E        
143D 000000         303			.ALIGN	4
1440 00000D8E       304			.LONG	C_F_HIDDEN
1444                305	
1444 00001430       306	F_F_LENMASK	.LONG	F_F_HIDDEN
1448 09             307			.BYTE	9	; flags + namelen
1449 465F4C454E4D   308			.BYTE	"F_LENMASK"
144F 41534B      
1452 0000           309			.ALIGN	4
1454 00000D9E       310			.LONG	C_F_LENMASK
1458                311	
1458 00001444       312	F_TOR		.LONG	F_F_LENMASK
145C 02             313			.BYTE	2	; flags + namelen
145D 3E52           314			.BYTE	">R"
145F 00             315			.ALIGN	4
1460 00000DAE       316			.LONG	C_TOR
1464                317	
1464 00001458       318	F_FROMR 	.LONG	F_TOR
1468 02             319			.BYTE	2	; flags + namelen
1469 523E           320			.BYTE	"R>"
146B 00             321			.ALIGN	4
146C 00000DC2       322			.LONG	C_FROMR
1470                323	
1470 00001464       324	F_RSPFETCH	.LONG	F_FROMR
1474 04             325			.BYTE	4	; flags + namelen
1475 52535040       326			.BYTE	"RSP@"
1479 000000         327			.ALIGN	4
147C 00000DD6       328			.LONG	C_RSPFETCH
1480                329	
1480 00001470       330	F_RSPSTORE	.LONG	F_RSPFETCH
1484 04             331			.BYTE	4	; flags + namelen
1485 52535021       332			.BYTE	"RSP!"
1489 000000         333			.ALIGN	4
148C 00000DE2       334	B_RSPSTORE	.LONG	C_RSPSTORE
1490                335	
1490 00001480       336	F_RDROP 	.LONG	F_RSPSTORE
1494 05             337			.BYTE	5	; flags + namelen
1495 5244524F50     338			.BYTE	"RDROP"
149A 0000           339			.ALIGN	4
149C 00000DEE       340			.LONG	C_RDROP
14A0                341	
14A0 00001490       342	F_DSPFETCH	.LONG	F_RDROP
14A4 04             343			.BYTE	4	; flags + namelen
14A5 44535040       344			.BYTE	"DSP@"
14A9 000000         345			.ALIGN	4
14AC 00000DF6       346	B_DSPFETCH	.LONG	C_DSPFETCH
14B0                347	
14B0 000014A0       348	F_DSPSTORE	.LONG	F_DSPFETCH
14B4 04             349			.BYTE	4	; flags + namelen
14B5 44535021       350			.BYTE	"DSP!"
14B9 000000         351			.ALIGN	4
14BC 00000E04       352			.LONG	C_DSPSTORE
14C0                353	
14C0 000014B0       354	F_KEY		.LONG	F_DSPSTORE
14C4 03             355			.BYTE	3	; flags + namelen
14C5 4B4559         356			.BYTE	"KEY"
14C8                357			.ALIGN	4
14C8 00000E0C       358			.LONG	C_KEY
14CC                359	
14CC 000014C0       360	F_EMIT		.LONG	F_KEY
14D0 04             361			.BYTE	4	; flags + namelen
14D1 454D4954       362			.BYTE	"EMIT"
14D5 000000         363			.ALIGN	4
14D8 00000E1E       364	B_EMIT		.LONG	C_EMIT
14DC                365	
14DC 000014CC       366	F_WORD		.LONG	F_EMIT
14E0 04             367			.BYTE	4	; flags + namelen
14E1 574F5244       368			.BYTE	"WORD"
14E5 000000         369			.ALIGN	4
14E8 00000E30       370	B_WORD		.LONG	C_WORD
14EC                371	
14EC 000014DC       372	F_NUMBER	.LONG	F_WORD
14F0 06             373			.BYTE	6	; flags + namelen
14F1 4E554D424552   374			.BYTE	"NUMBER"
14F7 00             375			.ALIGN	4
14F8 00000EA8       376			.LONG	C_NUMBER
14FC                377	
14FC 000014EC       378	F_FIND		.LONG	F_NUMBER
1500 04             379			.BYTE	4	; flags + namelen
1501 46494E44       380			.BYTE	"FIND"
1505 000000         381			.ALIGN	4
1508 00000F3E       382	B_FIND		.LONG	C_FIND
150C                383	
150C 000014FC       384	F_TCFA		.LONG	F_FIND
1510 04             385			.BYTE	4	; flags + namelen
1511 3E434641       386			.BYTE	">CFA"
1515 000000         387			.ALIGN	4
1518 00000FA2       388	B_TCFA		.LONG	C_TCFA
151C                389	
151C 0000150C       390	F_TDFA		.LONG	F_TCFA
1520 04             391			.BYTE	4	; flags + namelen
1521 3E444641       392			.BYTE	">DFA"
1525 000000         393			.ALIGN	4
1528 0000097A       394			.LONG	DOCOL
152C 00001518       395			.LONG	B_TCFA
1530 0000124C       396			.LONG	B_INCR4
1534 00001350       397			.LONG	B_EXIT
1538                398	
1538 0000151C       399	F_CREATE	.LONG	F_TDFA
153C 06             400			.BYTE	6	; flags + namelen
153D 435245415445   401			.BYTE	"CREATE"
1543 00             402			.ALIGN	4
1544 00000FCC       403	B_CREATE	.LONG	C_CREATE
1548                404	
1548 00001538       405	F_COMMA 	.LONG	F_CREATE
154C 01             406			.BYTE	1	; flags + namelen
154D 2C             407			.BYTE	","
154E 0000           408			.ALIGN	4
1550 0000101A       409	B_COMMA 	.LONG	C_COMMA
1554                410	
1554 00001548       411	F_LBRAC 	.LONG	F_COMMA
1558 81             412			.BYTE	1 | F_IMMED
1559 5B             413			.BYTE	"["
155A 0000           414			.ALIGN	4
155C 00001040       415	B_LBRAC 	.LONG	C_LBRAC
1560                416	
1560 00001554       417	F_RBRAC 	.LONG	F_LBRAC
1564 01             418			.BYTE	1
1565 5D             419			.BYTE	"]"
1566 0000           420			.ALIGN	4
1568 0000104A       421	B_RBRAC 	.LONG	C_RBRAC
156C                422	
156C 00001560       423	F_COLON 	.LONG	F_RBRAC
1570 01             424			.BYTE	1	; flags + namelen
1571 3A             425			.BYTE	":"
1572 0000           426			.ALIGN	4
1574 0000097A       427			.LONG	DOCOL
1578 000014E8       428			.LONG	B_WORD
157C 00001544       429			.LONG	B_CREATE
1580 0000135C0000   430			.LONG	B_LIT, DOCOL, B_COMMA
1586 097A00001550
158C 000013D40000   431			.LONG	B_LATEST, B_FETCH, B_HIDDEN
1592 1374000015EC
1598 00001568       432			.LONG	B_RBRAC
159C 00001350       433			.LONG	B_EXIT
15A0                434	
15A0 0000156C       435	F_SEMICOLON	.LONG	F_COLON
15A4 81             436			.BYTE	1 | F_IMMED
15A5 3B             437			.BYTE	";"
15A6 0000           438			.ALIGN	4
15A8 0000097A       439			.LONG	DOCOL
15AC 0000135C0000   440			.LONG	B_LIT, B_EXIT, B_COMMA
15B2 135000001550
15B8 000013D40000   441			.LONG	B_LATEST, B_FETCH, B_HIDDEN
15BE 1374000015EC
15C4 0000155C       442			.LONG	B_LBRAC
15C8 00001350       443			.LONG	B_EXIT
15CC                444	
15CC 000015A0       445	F_IMMEDIATE	.LONG	F_SEMICOLON
15D0 89             446			.BYTE	9 | F_IMMED
15D1 494D4D454449   447			.BYTE	"IMMEDIATE"
15D7 415445      
15DA 0000           448			.ALIGN	4
15DC 00001056       449			.LONG	C_IMMEDIATE
15E0                450	
15E0 000015CC       451	F_HIDDEN_	.LONG	F_IMMEDIATE
15E4 06             452			.BYTE	6
15E5 48494444454E   453			.BYTE	"HIDDEN"
15EB 00             454			.ALIGN	4
15EC 0000106C       455	B_HIDDEN	.LONG	C_HIDDEN
15F0                456	
15F0 000015E0       457	F_HIDE		.LONG	F_HIDDEN_
15F4 04             458			.BYTE	4
15F5 48494445       459			.BYTE	"HIDE"
15F9 000000         460			.ALIGN	4
15FC 0000097A       461			.LONG	DOCOL
1600 000014E8       462			.LONG	B_WORD
1604 00001508       463			.LONG	B_FIND
1608 000015EC       464			.LONG	B_HIDDEN
160C 00001350       465			.LONG	B_EXIT
1610                466	
1610 000015F0       467	F_TICK		.LONG	F_HIDE
1614 01             468			.BYTE	1
1615 27             469			.BYTE	"'"
1616 0000           470			.ALIGN	4
1618 00001084       471			.LONG	C_TICK
161C                472	
161C 00001610       473	F_BRANCH	.LONG	F_TICK
1620 06             474			.BYTE	6
1621 4252414E4348   475			.BYTE	"BRANCH"
1627 00             476			.ALIGN	4
1628 00001098       477	B_BRANCH	.LONG	C_BRANCH
162C                478	
162C 0000161C       479	F_ZBRANCH	.LONG	F_BRANCH
1630 07             480			.BYTE	7
1631 304252414E43   481			.BYTE	"0BRANCH"
1637 48          
1638                482			.ALIGN	4
1638 000010A2       483	B_ZBRANCH	.LONG	C_ZBRANCH
163C                484	
163C 0000162C       485	F_LITSTRING	.LONG	F_ZBRANCH
1640 09             486			.BYTE	9
1641 4C4954535452   487			.BYTE	"LITSTRING"
1647 494E47      
164A 0000           488			.ALIGN	4
164C 000010B6       489			.LONG	C_LITSTRING
1650                490	
1650 0000163C       491	F_TELL		.LONG	F_LITSTRING
1654 04             492			.BYTE	4
1655 54454C4C       493			.BYTE	"TELL"
1659 000000         494			.ALIGN	4
165C 000010D8       495			.LONG	C_TELL
1660                496	
1660 00001650       497	F_CHAR		.LONG	F_TELL
1664 04             498			.BYTE	4
1665 43484152       499			.BYTE	"CHAR"
1669 000000         500			.ALIGN	4
166C 000010FA       501			.LONG	C_CHAR
1670                502	
1670 00001660       503	F_EXECUTE	.LONG	F_CHAR
1674 07             504			.BYTE	7
1675 455845435554   505			.BYTE	"EXECUTE"
167B 45          
167C                506			.ALIGN	4
167C 00001110       507			.LONG	C_EXECUTE
1680                508	
1680 00001670       509	F_QUIT		.LONG	F_EXECUTE
1684 04             510			.BYTE	4	; flags + namelen
1685 51554954       511			.BYTE	"QUIT"
1689 000000         512			.ALIGN	4
168C 0000097A       513	B_QUIT		.LONG	DOCOL
1690 0000140C0000   514			.LONG	B_R0, B_RSPSTORE
1696 148C        
1698 00001D54       515			.LONG	B_INTERPRET
169C 00001628FFFF   516			.LONG	B_BRANCH, -8
16A2 FFF8        
16A4                517	
16A4 00001680       518	F_NL		.LONG	F_QUIT
16A8 04             519			.BYTE	4
16A9 275C6E27       520			.BYTE	"'\n'"
16AD 000000         521			.ALIGN	4
16B0 0000097A       522	B_NL		.LONG	DOCOL
16B4 0000135C0000   523			.LONG	B_LIT, 10
16BA 000A        
16BC 00001350       524			.LONG	B_EXIT
16C0                525	
16C0 000016A4       526	F_CR		.LONG	F_NL
16C4 02             527			.BYTE	2
16C5 4352           528			.BYTE	"CR"
16C7 00             529			.ALIGN	4
16C8 0000097A       530			.LONG	DOCOL
16CC 000016B00000   531			.LONG	B_NL, B_EMIT
16D2 14D8        
16D4 00001350       532			.LONG	B_EXIT
16D8                533	
16D8 000016C0       534	F_BL		.LONG	F_CR
16DC 02             535			.BYTE	2
16DD 424C           536			.BYTE	"BL"
16DF 00             537			.ALIGN	4
16E0 0000097A       538	B_BL		.LONG	DOCOL
16E4 0000135C0000   539			.LONG	B_LIT, 32
16EA 0020        
16EC 00001350       540			.LONG	B_EXIT
16F0                541	
16F0 000016D8       542	F_SPACE 	.LONG	F_BL
16F4 05             543			.BYTE	5
16F5 5350414345     544			.BYTE	"SPACE"
16FA 0000           545			.ALIGN	4
16FC 0000097A       546	B_SPACE 	.LONG	DOCOL
1700 000016E00000   547			.LONG	B_BL, B_EMIT
1706 14D8        
1708 00001350       548			.LONG	B_EXIT
170C                549	
170C 000016F0       550	F_SPACES	.LONG	F_SPACE
1710 06             551			.BYTE	6
1711 535041434553   552			.BYTE	"SPACES"
1717 00             553			.ALIGN	4
1718 0000097A       554	B_SPACES	.LONG	DOCOL
171C 000011EC0000   555			.LONG	B_DUP, B_ZGT
1722 1304        
1724 000016380000   556			.LONG	B_ZBRANCH, 20
172A 0014        
172C 000016FC0000   557			.LONG	B_SPACE, B_DECR
1732 1240        
1734 00001628FFFF   558			.LONG	B_BRANCH, -28
173A FFE4        
173C 000011B0       559			.LONG	B_DROP
1740 00001350       560			.LONG	B_EXIT
1744                561	
1744 0000170C       562	F_TRUE		.LONG	F_SPACES
1748 04             563			.BYTE	4
1749 54525545       564			.BYTE	"TRUE"
174D 000000         565			.ALIGN	4
1750 0000097A       566			.LONG	DOCOL
1754 0000135C0000   567			.LONG	B_LIT, 1
175A 0001        
175C 00001350       568			.LONG	B_EXIT
1760                569	
1760 00001744       570	F_FALSE 	.LONG	F_TRUE
1764 05             571			.BYTE	5
1765 46414C5345     572			.BYTE	"FALSE"
176A 0000           573			.ALIGN	4
176C 0000097A       574			.LONG	DOCOL
1770 0000135C0000   575			.LONG	B_LIT, 0
1776 0000        
1778 00001350       576			.LONG	B_EXIT
177C                577	
177C 00001760       578	F_NOT		.LONG	F_FALSE
1780 03             579			.BYTE	3
1781 4E4F54         580			.BYTE	"NOT"
1784                581			.ALIGN	4
1784 0000097A       582			.LONG	DOCOL
1788 000012E0       583			.LONG	B_ZEQU
178C 00001350       584			.LONG	B_EXIT
1790                585	
1790 0000177C       586	F_NEGATE	.LONG	F_NOT
1794 06             587			.BYTE	6
1795 4E4547415445   588			.BYTE	"NEGATE"
179B 00             589			.ALIGN	4
179C 0000097A       590	B_NEGATE	.LONG	DOCOL
17A0 0000135C0000   591			.LONG	B_LIT, 0, B_SWAP, B_SUB
17A6 0000000011E0
17AC 00001270    
17B0 00001350       592			.LONG	B_EXIT
17B4                593	
17B4 00001790       594	F_DIVMOD	.LONG	F_NEGATE
17B8 04             595			.BYTE	4
17B9 2F4D4F44       596			.BYTE	"/MOD"
17BD 000000         597			.ALIGN	4
17C0 00000B22       598	B_DIVMOD	.LONG	C_DIVMOD
17C4                599	
17C4 000017B4       600	F_DIV		.LONG	F_DIVMOD
17C8 01             601			.BYTE	1
17C9 2F             602			.BYTE	"/"
17CA 0000           603			.ALIGN	4
17CC 0000097A       604	B_DIV		.LONG	DOCOL
17D0 000017C00000   605			.LONG	B_DIVMOD, B_SWAP, B_DROP
17D6 11E0000011B0
17DC 00001350       606			.LONG	B_EXIT
17E0                607	
17E0 000017C4       608	F_MOD		.LONG	F_DIV
17E4 03             609			.BYTE	3
17E5 4D4F44         610			.BYTE	"MOD"
17E8                611			.ALIGN	4
17E8 0000097A       612			.LONG	DOCOL
17EC 000017C00000   613			.LONG	B_DIVMOD, B_DROP
17F2 11B0        
17F4 00001350       614			.LONG	B_EXIT
17F8                615	
17F8 000017E0       616	F_LITERAL	.LONG	F_MOD
17FC 87             617			.BYTE	7 | F_IMMED
17FD 4C4954455241   618			.BYTE	"LITERAL"
1803 4C          
1804                619			.ALIGN	4
1804 0000097A       620			.LONG	DOCOL
1808 0000135C0000   621			.LONG	B_LIT, B_LIT, B_COMMA
180E 135C00001550
1814 00001350       622			.LONG	B_EXIT
1818                623	
1818 000017F8       624	F_COMPILE	.LONG	F_LITERAL
181C 89             625			.BYTE	9 | F_IMMED
181D 5B434F4D5049   626			.BYTE	"[COMPILE]"
1823 4C455D      
1826 0000           627			.ALIGN	4
1828 0000097A       628			.LONG	DOCOL
182C 000014E8       629			.LONG	B_WORD		; get next word
1830 00001508       630			.LONG	B_FIND		; find in dictionary
1834 00001518       631			.LONG	B_TCFA		; get codeword
1838 00001550       632			.LONG	B_COMMA 	; compile that
183C 00001350       633			.LONG	B_EXIT
1840                634	
1840 00001818       635	F_RECURSE	.LONG	F_COMPILE
1844 87             636			.BYTE	7 | F_IMMED
1845 524543555253   637			.BYTE	"RECURSE"
184B 45          
184C                638			.ALIGN	4
184C 0000097A       639			.LONG	DOCOL
1850 000013D40000   640			.LONG	B_LATEST, B_FETCH
1856 1374        
1858 000015180000   641			.LONG	B_TCFA, B_COMMA
185E 1550        
1860 00001350       642			.LONG	B_EXIT
1864                643	
1864 00001840       644	F_IF		.LONG	F_RECURSE
1868 82             645			.BYTE	2 | F_IMMED
1869 4946           646			.BYTE	"IF"
186B 00             647			.ALIGN	4
186C 0000097A       648			.LONG	DOCOL
1870 0000135C0000   649			.LONG	B_LIT, B_ZBRANCH, B_COMMA	; compile 0BRANCH
1876 163800001550
187C 000013C40000   650			.LONG	B_HERE, B_FETCH 		; save current location on stack
1882 1374        
1884 0000135C0000   651			.LONG	B_LIT, 0, B_COMMA		; compile dummy offset
188A 000000001550
1890 00001350       652			.LONG	B_EXIT
1894                653	
1894 00001864       654	F_THEN		.LONG	F_IF
1898 84             655			.BYTE	4 | F_IMMED
1899 5448454E       656			.BYTE	"THEN"
189D 000000         657			.ALIGN	4
18A0 0000097A       658			.LONG	DOCOL
18A4 000011EC       659			.LONG	B_DUP
18A8 000013C40000   660			.LONG	B_HERE, B_FETCH, B_SWAP, B_SUB	; calculate offset
18AE 1374000011E0
18B4 00001270    
18B8 000011E00000   661			.LONG	B_SWAP, B_STORE 		; store offset
18BE 1368        
18C0 00001350       662			.LONG	B_EXIT
18C4                663	
18C4 00001894       664	F_ELSE		.LONG	F_THEN
18C8 84             665			.BYTE	4 | F_IMMED
18C9 454C5345       666			.BYTE	"ELSE"
18CD 000000         667			.ALIGN	4
18D0 0000097A       668			.LONG	DOCOL
18D4 0000135C0000   669			.LONG	B_LIT, B_BRANCH, B_COMMA	; compile BRANCH to skip false part
18DA 162800001550
18E0 000013C40000   670			.LONG	B_HERE, B_FETCH 		; save current location on stack
18E6 1374        
18E8 0000135C0000   671			.LONG	B_LIT, 0, B_COMMA		; compile dummy offset
18EE 000000001550
18F4 000011E00000   672			.LONG	B_SWAP, B_DUP
18FA 11EC        
18FC 000013C40000   673			.LONG	B_HERE, B_FETCH, B_SWAP, B_SUB	; calculate offset
1902 1374000011E0
1908 00001270    
190C 000011E00000   674			.LONG	B_SWAP, B_STORE 		; store offset
1912 1368        
1914 00001350       675			.LONG	B_EXIT
1918                676	
1918 000018C4       677	F_BEGIN 	.LONG	F_ELSE
191C 85             678			.BYTE	5 | F_IMMED
191D 424547494E     679			.BYTE	"BEGIN"
1922 0000           680			.ALIGN	4
1924 0000097A       681			.LONG	DOCOL
1928 000013C40000   682			.LONG	B_HERE, B_FETCH
192E 1374        
1930 00001350       683			.LONG	B_EXIT
1934                684	
1934 00001918       685	F_UNTIL 	.LONG	F_BEGIN
1938 85             686			.BYTE	5 | F_IMMED
1939 554E54494C     687			.BYTE	"UNTIL"
193E 0000           688			.ALIGN	4
1940 0000097A       689			.LONG	DOCOL
1944 0000135C0000   690			.LONG	B_LIT, B_ZBRANCH, B_COMMA
194A 163800001550
1950 000013C40000   691			.LONG	B_HERE, B_FETCH, B_SUB, B_COMMA
1956 137400001270
195C 00001550    
1960 00001350       692			.LONG	B_EXIT
1964                693	
1964 00001934       694	F_AGAIN 	.LONG	F_UNTIL
1968 85             695			.BYTE	5 | F_IMMED
1969 414741494E     696			.BYTE	"AGAIN"
196E 0000           697			.ALIGN	4
1970 0000097A       698			.LONG	DOCOL
1974 0000135C0000   699			.LONG	B_LIT, B_BRANCH, B_COMMA
197A 162800001550
1980 000013C40000   700			.LONG	B_HERE, B_FETCH, B_SUB, B_COMMA
1986 137400001270
198C 00001550    
1990 00001350       701			.LONG	B_EXIT
1994                702	
1994 00001964       703	F_WHILE 	.LONG	F_AGAIN
1998 85             704			.BYTE	5 | F_IMMED
1999 5748494C45     705			.BYTE	"WHILE"
199E 0000           706			.ALIGN	4
19A0 0000097A       707			.LONG	DOCOL
19A4 0000135C0000   708			.LONG	B_LIT, B_ZBRANCH, B_COMMA
19AA 163800001550
19B0 000013C40000   709			.LONG	B_HERE, B_FETCH
19B6 1374        
19B8 0000135C0000   710			.LONG	B_LIT, 0, B_COMMA
19BE 000000001550
19C4 00001350       711			.LONG	B_EXIT
19C8                712	
19C8 00001994       713	F_REPEAT	.LONG	F_WHILE
19CC 86             714			.BYTE	6 | F_IMMED
19CD 524550454154   715			.BYTE	"REPEAT"
19D3 00             716			.ALIGN	4
19D4 0000097A       717			.LONG	DOCOL
19D8 0000135C0000   718			.LONG	B_LIT, B_BRANCH, B_COMMA
19DE 162800001550
19E4 000011E0       719			.LONG	B_SWAP
19E8 000013C40000   720			.LONG	B_HERE, B_FETCH, B_SUB, B_COMMA
19EE 137400001270
19F4 00001550    
19F8 000011EC       721			.LONG	B_DUP
19FC 000013C40000   722			.LONG	B_HERE, B_FETCH, B_SWAP, B_SUB
1A02 1374000011E0
1A08 00001270    
1A0C 000011E00000   723			.LONG	B_SWAP, B_STORE
1A12 1368        
1A14 00001350       724			.LONG	B_EXIT
1A18                725	
1A18 000019C8       726	F_UPOINT	.LONG	F_REPEAT
1A1C 02             727			.BYTE	2
1A1D 552E           728			.BYTE	"U."
1A1F 00             729			.ALIGN	4
1A20 0000097A       730	B_UPOINT	.LONG	DOCOL
1A24 000013F00000   731			.LONG	B_BASE, B_FETCH, B_DIVMOD
1A2A 1374000017C0
1A30 000012280000   732			.LONG	B_QDUP, B_ZBRANCH, 8
1A36 163800000008
1A3C 00001A20       733			.LONG	B_UPOINT
1A40 000011EC0000   734			.LONG	B_DUP, B_LIT, 10, B_LT
1A46 135C0000000A
1A4C 000012B0    
1A50 000016380000   735			.LONG	B_ZBRANCH, 20
1A56 0014        
1A58 0000135C0000   736			.LONG	B_LIT, $30	; '0'
1A5E 0030        
1A60 000016280000   737			.LONG	B_BRANCH, 24
1A66 0018        
1A68 0000135C0000   738			.LONG	B_LIT, 10, B_SUB, B_LIT, $41 ; 'A'
1A6E 000A00001270
1A74 0000135C0000
1A7A 0041        
1A7C 000012640000   739			.LONG	B_ADD, B_EMIT
1A82 14D8        
1A84 00001350       740			.LONG	B_EXIT
1A88                741	
1A88 00001A18       742	F_POINTS	.LONG	F_UPOINT
1A8C 02             743			.BYTE	2
1A8D 2E53           744			.BYTE	".S"
1A8F 00             745			.ALIGN	4
1A90 0000097A       746			.LONG	DOCOL
1A94 000014AC       747			.LONG	B_DSPFETCH
1A98 000011EC0000   748			.LONG	B_DUP, B_S0, B_LT
1A9E 13E0000012B0
1AA4 000016380000   749			.LONG	B_ZBRANCH, 36
1AAA 0024        
1AAC 000011EC0000   750			.LONG	B_DUP, B_FETCH, B_UPOINT, B_SPACE
1AB2 137400001A20
1AB8 000016FC    
1ABC 0000124C0000   751			.LONG	B_INCR4, B_INCR4	; stack is 8 byte aligned
1AC2 124C        
1AC4 00001628FFFF   752			.LONG	B_BRANCH, -48
1ACA FFD0        
1ACC 000011B0       753			.LONG	B_DROP
1AD0 00001350       754			.LONG	B_EXIT
1AD4                755	
1AD4 00001A88       756	F_UWIDTH	.LONG	F_POINTS
1AD8 06             757			.BYTE	6
1AD9 555749445448   758			.BYTE	"UWIDTH"
1ADF 00             759			.ALIGN	4
1AE0 0000097A       760	B_UWIDTH	.LONG	DOCOL
1AE4 000013F00000   761			.LONG	B_BASE, B_FETCH, B_DIV
1AEA 1374000017CC
1AF0 000012280000   762			.LONG	B_QDUP, B_ZBRANCH, 20
1AF6 163800000014
1AFC 00001AE00000   763			.LONG	B_UWIDTH, B_INCR
1B02 1234        
1B04 000016280000   764			.LONG	B_BRANCH, 12
1B0A 000C        
1B0C 0000135C0000   765			.LONG	B_LIT, 1
1B12 0001        
1B14 00001350       766			.LONG	B_EXIT
1B18                767	
1B18 00001AD4       768	F_UPOINTR	.LONG	F_UWIDTH
1B1C 03             769			.BYTE	3
1B1D 552E52         770			.BYTE	"U.R"
1B20                771			.ALIGN	4
1B20 0000097A       772			.LONG	DOCOL
1B24 000011E00000   773			.LONG	B_SWAP, B_DUP, B_UWIDTH, B_ROT, B_SWAP, B_SUB
1B2A 11EC00001AE0
1B30 000012080000
1B36 11E000001270
1B3C 00001718       774			.LONG	B_SPACES
1B40 00001A20       775			.LONG	B_UPOINT
1B44 00001350       776			.LONG	B_EXIT
1B48                777	
1B48 00001B18       778	F_POINTR	.LONG	F_UPOINTR
1B4C 02             779			.BYTE	2
1B4D 2E52           780			.BYTE	".R"
1B4F 00             781			.ALIGN	4
1B50 0000097A       782	B_POINTR	.LONG	DOCOL
1B54 000011E00000   783			.LONG	B_SWAP, B_DUP, B_ZLT
1B5A 11EC000012F8
1B60 000016380000   784			.LONG	B_ZBRANCH, 36
1B66 0024        
1B68 0000179C0000   785			.LONG	B_NEGATE, B_LIT, 1, B_SWAP, B_ROT, B_DECR
1B6E 135C00000001
1B74 000011E00000
1B7A 120800001240
1B80 000016280000   786			.LONG	B_BRANCH, 20
1B86 0014        
1B88 0000135C0000   787			.LONG	B_LIT, 0, B_SWAP, B_ROT
1B8E 0000000011E0
1B94 00001208    
1B98 000011E00000   788			.LONG	B_SWAP, B_DUP, B_UWIDTH, B_ROT, B_SWAP, B_SUB
1B9E 11EC00001AE0
1BA4 000012080000
1BAA 11E000001270
1BB0 000017180000   789			.LONG	B_SPACES, B_SWAP
1BB6 11E0        
1BB8 000016380000   790			.LONG	B_ZBRANCH, 16
1BBE 0010        
1BC0 0000135C0000   791			.LONG	B_LIT, '-', B_EMIT
1BC6 002D000014D8
1BCC 00001A20       792			.LONG	B_UPOINT
1BD0 00001350       793			.LONG	B_EXIT
1BD4                794	
1BD4 00001B48       795	F_POINT 	.LONG	F_POINTR
1BD8 01             796			.BYTE	1
1BD9 2E             797			.BYTE	"."
1BDA 0000           798			.ALIGN	4
1BDC 0000097A       799	B_POINT 	.LONG	DOCOL
1BE0 0000135C0000   800			.LONG	B_LIT, 0, B_POINTR, B_SPACE, B_EXIT
1BE6 000000001B50
1BEC 000016FC0000
1BF2 1350        
1BF4                801	
1BF4 00001BD4       802	F_QUESTION	.LONG	F_POINT
1BF8 01             803			.BYTE	1
1BF9 3F             804			.BYTE	"?"
1BFA 0000           805			.ALIGN	4
1BFC 0000097A       806			.LONG	DOCOL
1C00 000013740000   807			.LONG	B_FETCH, B_POINT, B_EXIT
1C06 1BDC00001350
1C0C                808	
1C0C 00001BF4       809	F_HEX		.LONG	F_QUESTION
1C10 03             810			.BYTE	3
1C11 484558         811			.BYTE	"HEX"
1C14                812			.ALIGN	4
1C14 0000097A       813			.LONG	DOCOL
1C18 0000135C0000   814			.LONG	B_LIT, 16, B_BASE, B_STORE, B_EXIT
1C1E 0010000013F0
1C24 000013680000
1C2A 1350        
1C2C                815	
1C2C 00001C0C       816	F_DECIMAL	.LONG	F_HEX
1C30 07             817			.BYTE	7
1C31 444543494D41   818			.BYTE	"DECIMAL"
1C37 4C          
1C38                819			.ALIGN	4
1C38 0000097A       820			.LONG	DOCOL
1C3C 0000135C0000   821			.LONG	B_LIT, 10, B_BASE, B_STORE, B_EXIT
1C42 000A000013F0
1C48 000013680000
1C4E 1350        
1C50                822	
1C50 00001C2C       823	F_CONSTANT	.LONG	F_DECIMAL
1C54 08             824			.BYTE	8
1C55 434F4E535441   825			.BYTE	"CONSTANT"
1C5B 4E54        
1C5D 000000         826			.ALIGN	4
1C60 0000097A       827			.LONG	DOCOL
1C64 000014E80000   828			.LONG	B_WORD, B_CREATE
1C6A 1544        
1C6C 0000135C0000   829			.LONG	B_LIT, DOCOL, B_COMMA
1C72 097A00001550
1C78 0000135C0000   830			.LONG	B_LIT, B_LIT, B_COMMA
1C7E 135C00001550
1C84 00001550       831			.LONG	B_COMMA
1C88 0000135C0000   832			.LONG	B_LIT, B_EXIT, B_COMMA
1C8E 135000001550
1C94 00001350       833			.LONG	B_EXIT
1C98                834	
1C98 00001C50       835	F_ALLOT 	.LONG	F_CONSTANT
1C9C 05             836			.BYTE	5
1C9D 414C4C4F54     837			.BYTE	"ALLOT"
1CA2 0000           838			.ALIGN	4
1CA4 0000097A       839	B_ALLOT 	.LONG	DOCOL
1CA8 000013C40000   840			.LONG	B_HERE, B_FETCH, B_SWAP, B_HERE, B_ADDSTORE, B_EXIT
1CAE 1374000011E0
1CB4 000013C40000
1CBA 138000001350
1CC0                841	
1CC0 00001C98       842	F_CELLS 	.LONG	F_ALLOT
1CC4 05             843			.BYTE	5
1CC5 43454C4C53     844			.BYTE	"CELLS"
1CCA 0000           845			.ALIGN	4
1CCC 0000097A       846	B_CELLS 	.LONG	DOCOL
1CD0 0000135C0000   847			.LONG	B_LIT, 4, B_MUL, B_EXIT
1CD6 00040000128C
1CDC 00001350    
1CE0                848	
1CE0 00001CC0       849	F_VARIABLE	.LONG	F_CELLS
1CE4 08             850			.BYTE	8
1CE5 564152494142   851			.BYTE	"VARIABLE"
1CEB 4C45        
1CED 000000         852			.ALIGN	4
1CF0 0000097A       853			.LONG	DOCOL
1CF4 0000135C0000   854			.LONG	B_LIT, 1, B_CELLS, B_ALLOT
1CFA 000100001CCC
1D00 00001CA4    
1D04 000014E80000   855			.LONG	B_WORD, B_CREATE
1D0A 1544        
1D0C 0000135C0000   856			.LONG	B_LIT, DOCOL, B_COMMA
1D12 097A00001550
1D18 0000135C0000   857			.LONG	B_LIT, B_LIT, B_COMMA
1D1E 135C00001550
1D24 00001550       858			.LONG	B_COMMA
1D28 0000135C0000   859			.LONG	B_LIT, B_EXIT, B_COMMA
1D2E 135000001550
1D34 00001350       860			.LONG	B_EXIT
1D38                861	
1D38 00001CE0       862	F_BYE		.LONG	F_VARIABLE
1D3C 03             863			.BYTE	3
1D3D 425945         864			.BYTE	"BYE"
1D40                865			.ALIGN	4
1D40 000009BA       866			.LONG	C_BYE
1D44                867	
1D44                868	# last word builtin
1D44 00001D38       869	F_INTERPRET	.LONG	F_BYE
1D48 09             870			.BYTE	9
1D49 494E54455250   871			.BYTE	"INTERPRET"
1D4F 524554      
1D52 0000           872			.ALIGN	4
1D54 0000111E       873	B_INTERPRET	.LONG	C_INTERPRET
1D58                874	
1D58                875	# QUIT word to JUMP
1D58 0000168C       876	W_QUIT		.LONG	B_QUIT
####################### string.asm
1D5C                  1	#
1D5C                  2	# string area
1D5C                  3	#
1D5C 0A454F4E2052     4	HELLO		.BYTE	LF, "EON ROM 0.2.0", 0
1D62 4F4D20302E32
1D68 2E3000      
1D6B 0A               5	MENU		.BYTE	LF
1D6C 312E20474554     6			.BYTE	"1. GET/SET DATE   5. DISK INFO", LF
1D72 2F5345542044
1D78 415445202020
1D7E 352E20444953
1D84 4B20494E464F
1D8A 0A          
1D8B 322E204D454D     7			.BYTE	"2. MEMORY MONITOR", LF
1D91 4F5259204D4F
1D97 4E49544F520A
1D9D 332E20464F52     8			.BYTE	"3. FORTH          9. ILLEGAL", LF
1DA3 544820202020
1DA9 202020202020
1DAF 392E20494C4C
1DB5 4547414C0A  
1DBA 342E2042454E     9			.BYTE	"4. BENCHMARK      0. RESET", LF
1DC0 43484D41524B
1DC6 202020202020
1DCC 302E20524553
1DD2 45540A      
1DD5 4F5054494F4E    10			.BYTE	"OPTION? ", 0
1DDB 3F2000      
1DDE 0A4A4F4E4553    11	FORTH_HELLO	.BYTE	LF, "JONES FORTH READY", LF, 0
1DE4 20464F525448
1DEA 205245414459
1DF0 0A00        
1DF2 504152534552    12	PARSER_ERROR	.BYTE	"PARSER ERROR", LF, 0
1DF8 204552524F52
1DFE 0A00        
1E00 0D202000        13	DATE_HEADER	.BYTE	CR, "  ", 0
1E04 20285441422F    14	DATE_FOOTER	.BYTE	" (TAB/SPACE=NEXT, ESC/X=EXIT ENTER=UPDATE)", ESC, "[", 0
1E0A 53504143453D
1E10 4E4558542C20
1E16 4553432F583D
1E1C 455849542045
1E22 4E5445523D55
1E28 504441544529
1E2E 1B5B00      
1E31 030405060708    15	DATE_COLS	.BYTE	3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 17, 18, 19
1E37 090A0C0E0F10
1E3D 111213      
1E40 0A4441544520    16	DATE_WRITTEN	.BYTE	LF, "DATE WRITTEN !", 0
1E46 575249545445
1E4C 4E202100    
1E50 303132333435    17	HTAB		.BYTE	"0123456789ABCDEF"
1E56 363738394142
1E5C 43444546    
1E60 5B4B00          18	ESCOFF		.BYTE	"[K", 0
1E63 0A2028455343    19	MMON_HEADER	.BYTE	LF, " (ESC/X=EXIT ENTER=GOTO TAB=NEXT Z=ZERO I=INC LINES P/K=POKE R=RUN)", LF, 0
1E69 2F583D455849
1E6F 5420454E5445
1E75 523D474F544F
1E7B 205441423D4E
1E81 455854205A3D
1E87 5A45524F2049
1E8D 3D494E43204C
1E93 494E45532050
1E99 2F4B3D504F4B
1E9F 4520523D5255
1EA5 4E290A00    
1EA9 0A4558434550    20	EXC_HEADER	.BYTE	LF, "EXCEPTION ", 0
1EAF 54494F4E2000
1EB5 2041542000      21	EXC_MIDDLE	.BYTE	" AT ", 0
1EBA 205749544820    22	EXC_FOOTER	.BYTE	" WITH REGS:", 0
1EC0 524547533A00
1EC6 0A4352433332    23	BENCH_HEADER	.BYTE	LF, "CRC32 FIRST 64 ROM BYTES 100 TIMES: ", 0
1ECC 204649525354
1ED2 20363420524F
1ED8 4D2042595445
1EDE 532031303020
1EE4 54494D45533A
1EEA 2000        
1EEC 2054454E5448    24	BENCH_FOOTER	.BYTE	" TENTHS OF A SECOND ", 0
1EF2 53204F462041
1EF8 205345434F4E
1EFE 442000      
1F01 0A4449534B20    25	DISK_HEADER	.BYTE	LF, "DISK DETECTION ... ", 0
1F07 444554454354
1F0D 494F4E202E2E
1F13 2E2000      
1F16 20534543544F    26	DISK_FOOTER	.BYTE	" SECTORS", LF, 0
1F1C 52530A00    
1F20 54494D454F55    27	DISK_TIMEOUT	.BYTE	"TIMEOUT !", LF, 0
1F26 5420210A00  
#######################     4 passes. global/local labels (MAX   512):   364 /    91
